<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>每天一探</title>
  
  <subtitle>无法停止探索的脚步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sosout.com/"/>
  <updated>2019-07-27T09:00:10.276Z</updated>
  <id>http://sosout.com/</id>
  
  <author>
    <name>Weich</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang 环境搭建</title>
    <link href="http://sosout.com/2019/07/27/go-environment-construction.html"/>
    <id>http://sosout.com/2019/07/27/go-environment-construction.html</id>
    <published>2019-07-27T03:20:33.000Z</published>
    <updated>2019-07-27T09:00:10.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Golang官网下载地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a></p></blockquote><h2 id="Linux-下安装-Go-环境"><a href="#Linux-下安装-Go-环境" class="headerlink" title="Linux 下安装 Go 环境"></a>Linux 下安装 Go 环境</h2><ol><li><p>打开官网下载地址选择对应的系统版本, 复制下载链接，这里我选择的是：<code>go1.12.7.linux-amd64.tar.gz</code>，对应下载链接：<a href="https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz" target="_blank" rel="noopener">https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz</a></p></li><li><p><code>cd</code> 进入你用来存放安装包的目录。当然你也可以直接输入cd ~，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>下载完成，执行<code>tar</code>解压到<code>/usr/loacl</code>目录下，得到<code>go</code>文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -C /usr/<span class="built_in">local</span> -zxvf  go1.12.7.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>添加<code>/usr/loacl/go/bin</code>目录到<code>PATH</code>变量中，其中添加到<code>/etc/profile</code>或<code>$HOME/.profile</code>都可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 习惯用vim，没有的话可以用命令`sudo apt-get install vim`安装一个，</span></span><br><span class="line"><span class="comment"># 按`o(在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本)`键进行编辑</span></span><br><span class="line">$ vim /etc/profile</span><br><span class="line"><span class="comment"># 在最后一行添加</span></span><br><span class="line">$ <span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line">$ <span class="built_in">export</span> GOPATH=/mnt/go_workspaces</span><br><span class="line">$ <span class="built_in">export</span> GOBIN=<span class="variable">$GOPATH</span>/bin</span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOBIN</span>:<span class="variable">$GOROOT</span>/bin</span><br><span class="line"><span class="comment"># 按`ESC`键跳到命令模式，然后`:wq`保存退出后`source`一下:</span></span><br><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>执行<code>go version</code>，如果显示版本号，则Go环境安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br></pre></td></tr></table></figure></li></ol><h2 id="Mac-下安装-Go-环境"><a href="#Mac-下安装-Go-环境" class="headerlink" title="Mac 下安装 Go 环境"></a>Mac 下安装 Go 环境</h2><p>Mac分为压缩版和安装版，他们都是64位的。压缩版和Linux的大同小异，因为Mac和Linux都是基于Unix，终端这一块基本上是相同的。<br>压缩版解压后，就可以和Linux一样放到一个目录下，这里也以<code>/usr/local/go/</code>为例。在配置环境变量的时候，针对所有用户和Linux是一样的，都是<code>/etc/profile</code>这个文件；针对当前用户，Mac下是<code>$HOME/.bash_profile</code>，其他配置都一样，包括编辑sudo权限和生效方式，最后在终端里测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Golang官网下载地址：&lt;a href=&quot;https://golang.org/dl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://golang.org/dl/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
      <category term="golang" scheme="http://sosout.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://sosout.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>征战Objective-C</title>
    <link href="http://sosout.com/2019/04/07/Objective-C-tutotial.html"/>
    <id>http://sosout.com/2019/04/07/Objective-C-tutotial.html</id>
    <published>2019-04-07T01:40:48.000Z</published>
    <updated>2019-04-07T03:38:57.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Oc语言语法快速预览"><a href="#Oc语言语法快速预览" class="headerlink" title="Oc语言语法快速预览"></a>Oc语言语法快速预览</h2><h3 id="源代码文件扩展名对比："><a href="#源代码文件扩展名对比：" class="headerlink" title="源代码文件扩展名对比："></a>源代码文件扩展名对比：</h3><table><thead><tr><th></th><th>头文件</th><th>实现文件</th></tr></thead><tbody><tr><td>c语言</td><td>.h</td><td>.c</td></tr><tr><td>c++语言</td><td>.h</td><td>.cpp</td></tr><tr><td>oc语言</td><td>.h</td><td>.m</td></tr><tr><td>oc&amp;c++</td><td>.h</td><td>.mm</td></tr></tbody></table><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 类名SimpleClass 继承 NSObject 类</span><br><span class="line">@interface SimpleClass : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="类的属性申明"><a href="#类的属性申明" class="headerlink" title="类的属性申明"></a>类的属性申明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 类名Person 继承 NSObject 类</span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">// NSString 类型的对象，因为前面有个 *（表示指针，指针指向一块堆内存）</span><br><span class="line">@property NSString *firstName;</span><br><span class="line"></span><br><span class="line">@property NSNumber *yearOfBirth;</span><br><span class="line"></span><br><span class="line">// 基础类型</span><br><span class="line">@property int yearOfBirth;</span><br><span class="line"></span><br><span class="line">// 只读属性</span><br><span class="line">@property (readonly) NSString * fristName;</span><br><span class="line"></span><br><span class="line">@property NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="减号方法（普通方法又称对象方法）申明"><a href="#减号方法（普通方法又称对象方法）申明" class="headerlink" title="减号方法（普通方法又称对象方法）申明"></a>减号方法（普通方法又称对象方法）申明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface Person: NSObject</span><br><span class="line"></span><br><span class="line">- (void)someMethod;</span><br><span class="line"></span><br><span class="line">- (void)someMethodWithValue:(SomeType)value;</span><br><span class="line"></span><br><span class="line">- (void)someMethodWithFirstValue:(SomeType)info1 secondValue:(AnotherType)info2;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="加号方法（类方法，又称静态方法）申明"><a href="#加号方法（类方法，又称静态方法）申明" class="headerlink" title="加号方法（类方法，又称静态方法）申明"></a>加号方法（类方法，又称静态方法）申明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface NSString: NSObject</span><br><span class="line"></span><br><span class="line">+ (id)string;</span><br><span class="line"></span><br><span class="line">+ (id)stringWithString:(NSString *)aString;</span><br><span class="line"></span><br><span class="line">+ (id)stringWithFormat:(NSString *)format;</span><br><span class="line"></span><br><span class="line">+ (id)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">+ (id)stringWithCString:(const char *)cString encoding:(NSStringEncoding)enc;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;XYZPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation XYZPersion</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="完整的例子"><a href="#完整的例子" class="headerlink" title="完整的例子"></a>完整的例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// XYZPerson.h文件</span><br><span class="line">@interface XYZPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sayHello;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// XYZPerson.m文件</span><br><span class="line">#import &quot;XYZPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation XYZPerson</span><br><span class="line"></span><br><span class="line">- (void)sayHello &#123;</span><br><span class="line">  // @ 表示这是一个 Oc 类型字符串，不加 @，表示是一个纯 C 语言的字符串</span><br><span class="line">  NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Oc语言语法快速预览&quot;&gt;&lt;a href=&quot;#Oc语言语法快速预览&quot; class=&quot;headerlink&quot; title=&quot;Oc语言语法快速预览&quot;&gt;&lt;/a&gt;Oc语言语法快速预览&lt;/h2&gt;&lt;h3 id=&quot;源代码文件扩展名对比：&quot;&gt;&lt;a href=&quot;#源代码文件扩展名对比
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://sosout.com/categories/Objective-C/"/>
    
    
      <category term="note" scheme="http://sosout.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Dart 开发教程</title>
    <link href="http://sosout.com/2019/01/11/dart-tutorial.html"/>
    <id>http://sosout.com/2019/01/11/dart-tutorial.html</id>
    <published>2019-01-11T13:04:10.000Z</published>
    <updated>2019-01-11T13:06:01.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;教程&quot;&gt;&lt;a href=&quot;#教程&quot; class=&quot;headerlink&quot; title=&quot;教程&quot;&gt;&lt;/a&gt;教程&lt;/h2&gt;
      
    
    </summary>
    
      <category term="dart" scheme="http://sosout.com/categories/dart/"/>
    
    
      <category term="note" scheme="http://sosout.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>flutter 开发教程</title>
    <link href="http://sosout.com/2019/01/10/flutter-tutorial.html"/>
    <id>http://sosout.com/2019/01/10/flutter-tutorial.html</id>
    <published>2019-01-10T15:00:47.000Z</published>
    <updated>2019-01-11T13:04:46.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Flutter：New-Project"><a href="#Flutter：New-Project" class="headerlink" title="Flutter：New Project"></a>Flutter：New Project</h3><h4 id="Waiting-for-another-flutter-command-to-release-the-startup-lock…"><a href="#Waiting-for-another-flutter-command-to-release-the-startup-lock…" class="headerlink" title="Waiting for another flutter command to release the startup lock…"></a>Waiting for another flutter command to release the startup lock…</h4><p>解决办法：删除<code>./flutter/bin/cache/lockfile</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h2&gt;&lt;h3 id=&quot;Flutter：New-Project&quot;&gt;&lt;a href=&quot;#Flutter：New-Project&quot; class
      
    
    </summary>
    
      <category term="flutter" scheme="http://sosout.com/categories/flutter/"/>
    
    
      <category term="note" scheme="http://sosout.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>vscode快速构建Flutter项目</title>
    <link href="http://sosout.com/2019/01/09/flutter-vscode.html"/>
    <id>http://sosout.com/2019/01/09/flutter-vscode.html</id>
    <published>2019-01-09T13:46:40.000Z</published>
    <updated>2019-01-09T14:41:34.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，在操作之前大家可以将如下环境变量加入到用户环境变量中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">$ <span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure></p><h3 id="安装-Flutter-插件"><a href="#安装-Flutter-插件" class="headerlink" title="安装 Flutter 插件"></a>安装 Flutter 插件</h3><p>插件中安装 Flutter 插件，安装完毕重新载入软件，安装 Flutter 插件的时候会默认的安装 Dart 插件（Dart是谷歌开发的计算机编程语言）:</p><p><img src="/images/flutter-vscode/img1.png" alt="img1.png"></p><h3 id="Flutter-new-project"><a href="#Flutter-new-project" class="headerlink" title="Flutter:new project"></a>Flutter:new project</h3><p>打开vscode命令面板（comm+shift+p）选择Flutter:new project：</p><p><img src="/images/flutter-vscode/img2.png" alt="img2.png"></p><h3 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h3><p>输入我们需要的项目名称选择对应存放的文件位置，等待依赖下载，我们会看到下图：</p><p><img src="/images/flutter-vscode/img3.png" alt="img3.png"></p><h3 id="添加设备"><a href="#添加设备" class="headerlink" title="添加设备"></a>添加设备</h3><p>点击设备可以创建设备，开启已有设备，开启设备后选择到调试（虫子），添加调试配置，只管添加配置，然后保存就好了：</p><p><img src="/images/flutter-vscode/img4.png" alt="img4.png"></p><h3 id="开启调试"><a href="#开启调试" class="headerlink" title="开启调试"></a>开启调试</h3><p>选择左上方的开启调试。项目开始打包构建安装到选择的选择的设备上：</p><p><img src="/images/flutter-vscode/img5.png" alt="img5.png"></p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p><code>lib/main.dart</code>中编辑插入<code>Text(&#39;hello flutter&#39;)</code>，保存文件，我们会发现效果会立马呈现到 App 上：</p><p><img src="/images/flutter-vscode/img6.png" alt="img6.png"></p><h3 id="至此，教程就到这里了。"><a href="#至此，教程就到这里了。" class="headerlink" title="至此，教程就到这里了。"></a>至此，教程就到这里了。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设置环境变量&quot;&gt;&lt;a href=&quot;#设置环境变量&quot; class=&quot;headerlink&quot; title=&quot;设置环境变量&quot;&gt;&lt;/a&gt;设置环境变量&lt;/h3&gt;&lt;p&gt;由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，在操作之前大家
      
    
    </summary>
    
      <category term="flutter" scheme="http://sosout.com/categories/flutter/"/>
    
    
      <category term="vscode" scheme="http://sosout.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 ReactDom.render</title>
    <link href="http://sosout.com/2018/12/26/react-dom-render.html"/>
    <id>http://sosout.com/2018/12/26/react-dom-render.html</id>
    <published>2018-12-26T13:09:43.000Z</published>
    <updated>2019-01-09T13:26:00.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>有没有考虑过ReactDom.render的第一个参数到底是什么？render 函数的方法签名：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(element, container[, callback])</span><br></pre></td></tr></table></figure></p><p>既然讨论类型，那不如看看强类型的 ts 对这个函数的类型定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Renderer &#123;</span><br><span class="line">    <span class="comment">// Deprecated(render): The return value is deprecated.</span></span><br><span class="line">    <span class="comment">// In future releases the render function's return type will be void.</span></span><br><span class="line"></span><br><span class="line">    &lt;T <span class="keyword">extends</span> Element&gt;(</span><br><span class="line">        element: DOMElement&lt;DOMAttributes&lt;T&gt;, T&gt;,</span><br><span class="line">        container: Element | <span class="literal">null</span>,</span><br><span class="line">        callback?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    ): T;</span><br><span class="line"></span><br><span class="line">    (</span><br><span class="line">        element: <span class="built_in">Array</span>&lt;DOMElement&lt;DOMAttributes&lt;<span class="built_in">any</span>&gt;, <span class="built_in">any</span>&gt;&gt;,</span><br><span class="line">        container: Element | <span class="literal">null</span>,</span><br><span class="line">        callback?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    ): Element;</span><br><span class="line"></span><br><span class="line">    (</span><br><span class="line">        element: SFCElement&lt;<span class="built_in">any</span>&gt; | <span class="built_in">Array</span>&lt;SFCElement&lt;<span class="built_in">any</span>&gt;&gt;,</span><br><span class="line">        container: Element | <span class="literal">null</span>,</span><br><span class="line">        callback?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    ): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">    &lt;P, T <span class="keyword">extends</span> Component&lt;P, ComponentState&gt;&gt;(</span><br><span class="line">        element: CElement&lt;P, T&gt;,</span><br><span class="line">        container: Element | <span class="literal">null</span>,</span><br><span class="line">        callback?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    ): T;</span><br><span class="line"></span><br><span class="line">    (</span><br><span class="line">        element: <span class="built_in">Array</span>&lt;CElement&lt;<span class="built_in">any</span>, Component&lt;<span class="built_in">any</span>, ComponentState&gt;&gt;&gt;,</span><br><span class="line">        container: Element | <span class="literal">null</span>,</span><br><span class="line">        callback?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    ): Component&lt;<span class="built_in">any</span>, ComponentState&gt;;</span><br><span class="line"></span><br><span class="line">    &lt;P&gt;(</span><br><span class="line">        element: ReactElement&lt;P&gt;,</span><br><span class="line">        container: Element | <span class="literal">null</span>,</span><br><span class="line">        callback?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    ): Component&lt;P, ComponentState&gt; | Element | <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">    (</span><br><span class="line">        element: <span class="built_in">Array</span>&lt;ReactElement&lt;<span class="built_in">any</span>&gt;&gt;,</span><br><span class="line">        container: Element | <span class="literal">null</span>,</span><br><span class="line">        callback?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    ): Component&lt;<span class="built_in">any</span>, ComponentState&gt; | Element | <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">    (</span><br><span class="line">        parentComponent: Component&lt;<span class="built_in">any</span>&gt; | <span class="built_in">Array</span>&lt;Component&lt;<span class="built_in">any</span>&gt;&gt;,</span><br><span class="line">        element: SFCElement&lt;<span class="built_in">any</span>&gt;,</span><br><span class="line">        container: Element,</span><br><span class="line">        callback?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    ): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>render 方法的返回值被废弃，在将来的版本中将返回 void。理由大概是将来可能会使用异步 render。</p><p>第一个参数的类型包括：</p><ul><li>DOMElement 或 DOMElement 数组，返回 Element</li><li>SFCElement 或 SFCElement 数组，返回 void</li><li>CElement 或 CElement 数组，返回 Component</li><li>ReactElement 或 ReactElement 数组，返回 Component 或 Element 或 void</li></ul><p>其中 SFCElement、CElement、DOMElement 都是 ReactElement 的子类，分别对应类组件和函数组件生成的 Element 以及 DOM 元素的包装。</p><p>还有最后一个，接收 4 个参数：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    parentComponent: Component&lt;<span class="built_in">any</span>&gt; | <span class="built_in">Array</span>&lt;Component&lt;<span class="built_in">any</span>&gt;&gt;,</span><br><span class="line">    element: SFCElement&lt;<span class="built_in">any</span>&gt;,</span><br><span class="line">    container: Element,</span><br><span class="line">    callback?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">): <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure></p><p>从方法签名看，第一个参数接收的是一个 React 组件。</p><p>我试了一下，直接报错 Target container is not a DOM element.</p><p>查看 React 的源码也没有这个方法签名，和这个接近的方法是非正式的 unstable_renderSubtreeIntoContainer。</p><p>很多人误解了 React 的 Component 和 Element。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Hello &#123;name&#125;!</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>App 就是 Component，而 <app> 是 Element。</app></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h3&gt;&lt;p&gt;有没有考虑过ReactDom.render的第一个参数到底是什么？render 函数的方法签名：&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="react" scheme="http://sosout.com/categories/react/"/>
    
    
      <category term="render" scheme="http://sosout.com/tags/render/"/>
    
  </entry>
  
  <entry>
    <title>React Fiber</title>
    <link href="http://sosout.com/2018/12/24/react-fiber.html"/>
    <id>http://sosout.com/2018/12/24/react-fiber.html</id>
    <published>2018-12-24T13:47:57.000Z</published>
    <updated>2018-12-24T13:32:54.347Z</updated>
    
    <content type="html"><![CDATA[<p>React Fiber 是对 React 核心算法的重新实现，目标是提高其对动画，布局和手势等领域的适用性。它的最重要的特性是 incremental rendering（增量渲染）：它能够将渲染 work 拆分成多块并将这些任务块分散到多个帧执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React Fiber 是对 React 核心算法的重新实现，目标是提高其对动画，布局和手势等领域的适用性。它的最重要的特性是 incremental rendering（增量渲染）：它能够将渲染 work 拆分成多块并将这些任务块分散到多个帧执行。&lt;/p&gt;

      
    
    </summary>
    
      <category term="react" scheme="http://sosout.com/categories/react/"/>
    
    
      <category term="fiber" scheme="http://sosout.com/tags/fiber/"/>
    
  </entry>
  
  <entry>
    <title>解决本地开发ajax跨域问题</title>
    <link href="http://sosout.com/2018/12/03/local-ajax-cross.html"/>
    <id>http://sosout.com/2018/12/03/local-ajax-cross.html</id>
    <published>2018-12-03T13:33:09.000Z</published>
    <updated>2018-12-13T14:16:45.099Z</updated>
    
    <content type="html"><![CDATA[<p>前后端分离，本地前端开发调用接口会有跨域问题，一般有以下几种解决方法：</p><ol><li>后端接口打包到本地运行（缺点：每次后端更新都要去测试服下一个更新包，还要在本地搭建java运行环境，麻烦）。</li><li>CORS跨域：后端接口在返回的时候，在header中加入’Access-Control-Allow-origin’:* 之类的（有的时候后端不方便这样处理，前端就蛋疼了）。</li><li>用nodejs搭建本地http服务器，并且判断访问接口URL时进行转发，完美解决本地开发时候的跨域问题。</li><li>使用谷歌的插件<code>allow-control-allow-origi</code>解决，或者谷歌开启允许跨域，参考 <a href="http://camnpr.com/archives/chrome-args-disable-web-security.html" target="_blank" rel="noopener">http://camnpr.com/archives/chrome-args-disable-web-security.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前后端分离，本地前端开发调用接口会有跨域问题，一般有以下几种解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;后端接口打包到本地运行（缺点：每次后端更新都要去测试服下一个更新包，还要在本地搭建java运行环境，麻烦）。&lt;/li&gt;
&lt;li&gt;CORS跨域：后端接口在返回的时候，在heade
      
    
    </summary>
    
      <category term="http" scheme="http://sosout.com/categories/http/"/>
    
    
      <category term="ajax" scheme="http://sosout.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>typescript 教程</title>
    <link href="http://sosout.com/2018/11/30/typescript-tutorial.html"/>
    <id>http://sosout.com/2018/11/30/typescript-tutorial.html</id>
    <published>2018-11-30T15:44:49.000Z</published>
    <updated>2018-11-29T13:35:40.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TSLint-规则"><a href="#TSLint-规则" class="headerlink" title="TSLint 规则"></a>TSLint 规则</h2><p>一套完整的 TSLint 规则，以及对每条规则的释义。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>以<code>tslint-config-alloy</code>为例：<br>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev tslint typescript tslint-config-alloy</span><br></pre></td></tr></table></figure><p>在你的项目根目录下创建 <code>tslint.json</code>，并将以下内容复制到文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [&quot;tslint-config-alloy&quot;],</span><br><span class="line">    &quot;linterOptions&quot;: &#123;</span><br><span class="line">        &quot;exclude&quot;: [&quot;**/node_modules/**&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        // 这里填入你的项目需要的个性化配置，比如：</span><br><span class="line">        //</span><br><span class="line">        // // 一个缩进必须用两个空格替代</span><br><span class="line">        // // @has-fixer 可自动修复</span><br><span class="line">        // // @prettier 可交由 prettier 控制</span><br><span class="line">        // &quot;indent&quot;: [true, &quot;spaces&quot;, 2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CLI-中运行"><a href="#CLI-中运行" class="headerlink" title="CLI 中运行"></a>CLI 中运行</h4><p>使用项目依赖中的 <code>tslint</code> 脚本，指定项目路径，检查所有 ts 后缀的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/tslint --project . ./**/*.ts</span><br></pre></td></tr></table></figure><p>将 <code>tslint</code> 作为 npm scripts 运行：</p><ol><li><code>package.json</code> 的 <code>scripts</code> 字段添加一条 <code>&quot;tslint&quot;: &quot;tslint --project . ./**/*.ts&quot;</code></li><li>运行 <code>npm run tslint</code></li></ol><h4 id="与-VSCode-集成"><a href="#与-VSCode-集成" class="headerlink" title="与 VSCode 集成"></a>与 VSCode 集成</h4><ol><li>在 VSCode 中安装 tslint 插件</li><li>按下 <code>Cmd</code> + <code>,</code> 或 <code>Ctrl</code> + <code>,</code>，打开设置</li><li>将 <code>tslint.autoFixOnSave</code>，配置为 <code>true</code></li></ol><h4 id="与-Prettier-集成"><a href="#与-Prettier-集成" class="headerlink" title="与 Prettier 集成"></a>与 Prettier 集成</h4><p>Prettier 是一个专注于对代码风格进行统一格式化的工具，由于与 TSLint 的部分配置冲突，故需要使用 tslint-config-prettier 禁用掉 TSLint 的部分规则。</p><p>首先安装 prettier 和 tslint-config-prettier：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev prettier tslint-config-prettier</span><br></pre></td></tr></table></figure><p>然后为 <code>tslint.config</code> 的 <code>extends</code> 添加 <code>tslint-config-prettier</code> 即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [&quot;tslint-config-alloy&quot;, &quot;tslint-config-prettier&quot;],</span><br><span class="line">    &quot;linterOptions&quot;: &#123;</span><br><span class="line">        &quot;exclude&quot;: [&quot;**/node_modules/**&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        // 这里填入你的项目需要的个性化配置，比如：</span><br><span class="line">        //</span><br><span class="line">        // // 一个缩进必须用两个空格替代</span><br><span class="line">        // // @has-fixer 可自动修复</span><br><span class="line">        // // @prettier 可交由 prettier 控制</span><br><span class="line">        // &quot;indent&quot;: [true, &quot;spaces&quot;, 2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要在 VSCode 中实现保存时修复 Prettier 的问题，则可以按照以下步骤配置：</p><ol><li>VSCode 安装 Prettier - Code formatter 插件</li><li>按下 <code>Cmd</code> + <code>,</code> 或 <code>Ctrl</code> + <code>,</code>，打开设置</li><li>将 <code>tslint.formatOnSave</code>，配置为 <code>true</code></li></ol><p>Prettier 的配置文件 <code>prettier.config.js</code> 可以参考这个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prettier.config.js or .prettierrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 一行最多 100 字符</span></span><br><span class="line">    printWidth: <span class="number">100</span>,</span><br><span class="line">    <span class="comment">// 使用 4 个空格缩进</span></span><br><span class="line">    tabWidth: <span class="number">4</span>,</span><br><span class="line">    <span class="comment">// 不使用缩进符，而使用空格</span></span><br><span class="line">    useTabs: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 行尾需要有分号</span></span><br><span class="line">    semi: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 使用单引号</span></span><br><span class="line">    singleQuote: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// jsx 不使用单引号，而使用双引号</span></span><br><span class="line">    jsxSingleQuote: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 末尾不需要逗号</span></span><br><span class="line">    trailingComma: <span class="string">'none'</span>,</span><br><span class="line">    <span class="comment">// 大括号内的首尾需要空格</span></span><br><span class="line">    bracketSpacing: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// jsx 标签的反尖括号需要换行</span></span><br><span class="line">    jsxBracketSameLine: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 箭头函数，只有一个参数的时候，也需要括号</span></span><br><span class="line">    arrowParens: <span class="string">'always'</span>,</span><br><span class="line">    <span class="comment">// 每个文件格式化的范围是文件的全部内容</span></span><br><span class="line">    rangeStart: <span class="number">0</span>,</span><br><span class="line">    rangeEnd: <span class="literal">Infinity</span>,</span><br><span class="line">    <span class="comment">// 不需要写文件开头的 @prettier</span></span><br><span class="line">    requirePragma: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 不需要自动在文件开头插入 @prettier</span></span><br><span class="line">    insertPragma: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 使用默认的折行标准</span></span><br><span class="line">    proseWrap: <span class="string">'preserve'</span>,</span><br><span class="line">    <span class="comment">// 根据显示样式决定 html 要不要折行</span></span><br><span class="line">    htmlWhitespaceSensitivity: <span class="string">'css'</span>,</span><br><span class="line">    <span class="comment">// 换行符使用 lf</span></span><br><span class="line">    endOfLine: <span class="string">'lf'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="规则列表"><a href="#规则列表" class="headerlink" title="规则列表"></a>规则列表</h3><h4 id="TypeScript-相关"><a href="#TypeScript-相关" class="headerlink" title="TypeScript 相关"></a>TypeScript 相关</h4><p>与 TypeScript 特性相关的规则。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://palantir.github.io/tslint/rules/adjacent-overload-signatures/" target="_blank" rel="noopener">adjacent-overload-signatures</a></td><td>重载的函数<strong>必须</strong>写在一起</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/ban-types/" target="_blank" rel="noopener">ban-types</a></td><td>禁用特定的类型</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/member-access/" target="_blank" rel="noopener">member-access</a></td><td><strong>必须</strong>指定类的成员的可访问性</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/member-ordering/" target="_blank" rel="noopener">member-ordering</a></td><td>指定类成员的排序规则</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-any/" target="_blank" rel="noopener">no-any</a></td><td><strong>禁止</strong>使用any</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-empty-interface/" target="_blank" rel="noopener">no-empty-interface</a></td><td><strong>禁止</strong>定义空的接口</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-import-side-effect/" target="_blank" rel="noopener">no-import-side-effect</a></td><td><strong>禁止</strong>导入立即执行的模块，除了<code>css</code>、<code>less</code>、<code>sass</code>、<code>scss</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-inferrable-types/" target="_blank" rel="noopener">no-inferrable-types</a></td><td><strong>禁止</strong>给一个初始化时直接赋值为<code>number</code>、<code>string</code>或<code>boolean</code>的变量显式的指定类型</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-internal-module/" target="_blank" rel="noopener">no-internal-module</a></td><td><strong>禁止</strong>使用<code>module</code>来定义命名空间</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-magic-numbers/" target="_blank" rel="noopener">no-magic-numbers</a></td><td><strong>禁止</strong>使用魔法数字，仅允许使用一部分白名单中的数字</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-any/" target="_blank" rel="noopener">no-namespace</a></td><td><strong>禁止</strong>使用<code>namespace</code>来定义命名空间</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-non-null-assertion/" target="_blank" rel="noopener">no-non-null-assertion</a></td><td><strong>禁止</strong>使用 non-null 断言（感叹号）</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-parameter-reassignment/" target="_blank" rel="noopener">no-parameter-reassignment</a></td><td><strong>禁止</strong>对函数的参数重新赋值</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-reference/" target="_blank" rel="noopener">no-reference</a></td><td><strong>禁止</strong>使用三斜线引入模块<code>/// &lt;reference path=&quot;foo&quot; /&gt;</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-unnecessary-type-assertion/" target="_blank" rel="noopener">no-unnecessary-type-assertion</a></td><td><strong>禁止</strong>无用的类型断言</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-unnecessary-type-assertion/" target="_blank" rel="noopener">no-var-requires</a></td><td><strong>禁止</strong>使用<code>require</code>来引入模块</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/only-arrow-functions/" target="_blank" rel="noopener">only-arrow-functions</a></td><td><strong>必须</strong>使用箭头函数，除非是单独的函数声明或是命名函数</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/prefer-for-of/" target="_blank" rel="noopener">prefer-for-of</a></td><td>使用<code>for</code>循环遍历数组时，如果<code>index</code>仅用于获取成员，则<strong>必须</strong>使用<code>for of</code>循环替代<code>for</code>循环</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/promise-function-async/" target="_blank" rel="noopener">promise-function-async</a></td><td><code>async</code>函数的返回值<strong>必须</strong>是<code>Promise</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/typedef/" target="_blank" rel="noopener">typedef</a></td><td>变量、函数返回值、函数参数等<strong>必须</strong>要有类型定义</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/typedef-whitespace/" target="_blank" rel="noopener">typedef-whitespace</a></td><td>类型定义的冒号前面<strong>必须</strong>没有空格，后面<strong>必须</strong>有一个空格</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/unified-signatures/" target="_blank" rel="noopener">unified-signatures</a></td><td>函数重载时，若能通过联合类型将两个函数的类型声明合为一个，则使用联合类型而不是两个函数声明</td></tr></tbody></table><h4 id="功能性检查"><a href="#功能性检查" class="headerlink" title="功能性检查"></a>功能性检查</h4><p>找出可能的错误，以及可能会产生 bug 的编码习惯。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://palantir.github.io/tslint/rules/await-promise/" target="_blank" rel="noopener">await-promise</a></td><td><code>await</code><strong>必须</strong>接受<code>Promise</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/ban/" target="_blank" rel="noopener">ban</a></td><td>禁用指定的函数或全局方法</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/ban-comma-operator/" target="_blank" rel="noopener">ban-comma-operator</a></td><td><strong>禁止</strong>使用逗号操作符</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/curly/" target="_blank" rel="noopener">curly</a></td><td><code>if</code>后面<strong>必须</strong>有<code>{</code>，除非是单行<code>if</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/forin/" target="_blank" rel="noopener">forin</a></td><td><code>for in</code>内部<strong>必须</strong>有<code>hasOwnProperty</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/import-blacklist/" target="_blank" rel="noopener">import-blacklist</a></td><td>禁用指定的模块</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/label-position/" target="_blank" rel="noopener">label-position</a></td><td>只允许在<code>do</code>, <code>for</code>, <code>while</code> 或 <code>switch</code> 中使用 <code>label</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-arg/" target="_blank" rel="noopener">no-arg</a></td><td><strong>禁止</strong>使用<code>arguments.callee</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-bitwise/" target="_blank" rel="noopener">no-bitwise</a></td><td><strong>禁止</strong>使用位运算</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-conditional-assignment/" target="_blank" rel="noopener">no-conditional-assignment</a></td><td><strong>禁止</strong>在分支条件判断中有赋值操作</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-console/" target="_blank" rel="noopener">no-console</a></td><td><strong>禁止</strong>使用<code>console</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-construct/" target="_blank" rel="noopener">no-construct</a></td><td><strong>禁止</strong>使用<code>new</code>来生成<code>String</code>,<code>Number</code>或<code>Boolean</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-debugger/" target="_blank" rel="noopener">no-debugger</a></td><td><strong>禁止</strong>使用<code>debugger</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-duplicate-super/" target="_blank" rel="noopener">no-duplicate-super</a></td><td><strong>禁止</strong><code>super</code>在一个构造函数中出现两次</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-duplicate-switch-case/" target="_blank" rel="noopener">no-duplicate-switch-case</a></td><td><strong>禁止</strong>在<code>switch</code>语句中出现重复测试表达式的<code>case</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-duplicate-variable/" target="_blank" rel="noopener">no-duplicate-variable</a></td><td><strong>禁止</strong>出现重复的变量定义或函数参数名</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-dynamic-delete/" target="_blank" rel="noopener">no-dynamic-delete</a></td><td><strong>禁止</strong><code>delete</code>动态的值</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-empty/" target="_blank" rel="noopener">no-empty</a></td><td><strong>禁止</strong>出现空代码块，允许<code>catch</code>是空代码块</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-eval/" target="_blank" rel="noopener">no-eval</a></td><td><strong>禁止</strong>使用<code>eval</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-floating-promises/" target="_blank" rel="noopener">no-floating-promises</a></td><td>函数返回值为<code>Promise</code>时，<strong>必须</strong>被处理</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-for-in-array/" target="_blank" rel="noopener">no-for-in-array</a></td><td><strong>禁止</strong>对<code>array</code>使用<code>for in</code>循环</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-implicit-dependencies/" target="_blank" rel="noopener">no-implicit-dependencies</a></td><td><strong>禁止</strong>引入<code>package.json</code>中不存在的模块</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-inferred-empty-object-type/" target="_blank" rel="noopener">no-inferred-empty-object-type</a></td><td><strong>禁止</strong>推论出的类型是空对象类型</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-invalid-template-strings/" target="_blank" rel="noopener">no-invalid-template-strings</a></td><td><strong>禁止</strong>在非模版字符串中出现<code>${}</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-invalid-this/" target="_blank" rel="noopener">no-invalid-this</a></td><td><strong>禁止</strong>在类外面使用<code>this</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-misused-new/" target="_blank" rel="noopener">no-misused-new</a></td><td><strong>禁止</strong>在接口中定义<code>constructor</code>，或在类中定义<code>new</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-null-keyword/" target="_blank" rel="noopener">no-null-keyword</a></td><td><strong>禁止</strong>使用<code>null</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-object-literal-type-assertion/" target="_blank" rel="noopener">no-object-literal-type-assertion</a></td><td><strong>禁止</strong>对对象字面量进行类型断言（断言成<code>any</code>是允许的）</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-return-await/" target="_blank" rel="noopener">no-return-await</a></td><td><strong>禁止</strong>没必要的<code>return await</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-shadowed-variable/" target="_blank" rel="noopener">no-shadowed-variable</a></td><td><strong>禁止</strong>变量名与上层作用域内的定义过的变量重复</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-sparse-arrays/" target="_blank" rel="noopener">no-sparse-arrays</a></td><td><strong>禁止</strong>在数组中出现连续的逗号，如<code>let foo = [,,]</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-string-literal/" target="_blank" rel="noopener">no-string-literal</a></td><td><strong>禁止</strong>出现<code>foo[&#39;bar&#39;]</code>，必须写成<code>foo.bar</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-string-throw/" target="_blank" rel="noopener">no-string-throw</a></td><td><strong>禁止</strong><code>throw</code>字符串，必须<code>throw</code>一个<code>Error</code>对象</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-submodule-imports/" target="_blank" rel="noopener">no-submodule-imports</a></td><td><strong>禁止</strong><code>import</code>模块的子文件</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-switch-case-fall-through/" target="_blank" rel="noopener">no-switch-case-fall-through</a></td><td><code>switch</code> 的 <code>case</code> 必须 <code>return</code> 或 <code>break</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-this-assignment/" target="_blank" rel="noopener">no-this-assignment</a></td><td><strong>禁止</strong>将<code>this</code>赋值给其他变量，除非是解构赋值</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-unbound-method/" target="_blank" rel="noopener">no-unbound-method</a></td><td>使用实例的方法时，<strong>必须</strong><code>bind</code>到实例上</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-unnecessary-class/" target="_blank" rel="noopener">no-unnecessary-class</a></td><td><strong>禁止</strong>定义没必要的类，比如只有静态方法的类</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-unsafe-any/" target="_blank" rel="noopener">no-unsafe-any</a></td><td><strong>禁止</strong>取用一个类型为<code>any</code>的对象的属性</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-unsafe-finally/" target="_blank" rel="noopener">no-unsafe-finally</a></td><td><strong>禁止</strong><code>finally</code>内出现<code>return</code>,<code>continue</code>,<code>break</code>,<code>throw</code>等</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-unused-expression/" target="_blank" rel="noopener">no-unused-expression</a></td><td><strong>禁止</strong>无用的表达式</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-use-before-declare/" target="_blank" rel="noopener">no-use-before-declare</a></td><td>变量<code>必须</code>先定义后使用</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-var-keyword/" target="_blank" rel="noopener">no-var-keyword</a></td><td><strong>禁止</strong>使用<code>var</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-void-expression/" target="_blank" rel="noopener">no-void-expression</a></td><td><strong>禁止</strong>返回值为<code>void</code>类型</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/prefer-conditional-expression/" target="_blank" rel="noopener">prefer-conditional-expression</a></td><td>可以用三元表达式时，就不用<code>if else</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/prefer-object-spread/" target="_blank" rel="noopener">prefer-object-spread</a></td><td>使用<code>{ ...foo, bar: 1 }</code>代替<code>Object.assign({}, foo, { bar: 1 })</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/radix/" target="_blank" rel="noopener">radix</a></td><td><code>parseInt</code><strong>必须</strong>传入第二个参数</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/restrict-plus-operands/" target="_blank" rel="noopener">restrict-plus-operands</a></td><td>使用加号时，两者<strong>必须</strong>同为数字或同为字符串</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/strict-boolean-expressions/" target="_blank" rel="noopener">strict-boolean-expressions</a></td><td>在分支条件判断中<strong>必须</strong>传入布尔类型的值</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/strict-type-predicates/" target="_blank" rel="noopener">strict-type-predicates</a></td><td><strong>禁止</strong>出现永远为<code>true</code>或永远为<code>false</code>的条件判断（通过类型预测出一个表达式为<code>true</code>还是<code>false</code>）</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/switch-default/" target="_blank" rel="noopener">switch-default</a></td><td><code>switch</code>语句<strong>必须</strong>有<code>default</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/triple-equals/" target="_blank" rel="noopener">triple-equals</a></td><td><strong>必须</strong>使用<code>===</code>或<code>!==</code>，<strong>禁止</strong>使用<code>==</code>或<code>!=</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/typeof-compare/" target="_blank" rel="noopener">typeof-compare</a></td><td><code>typeof</code>表达式比较的对象<strong>必须</strong>是<code>&#39;undefined&#39;</code>,<code>&#39;object&#39;</code>,<code>&#39;boolean&#39;</code>,<code>&#39;number&#39;</code>,<code>&#39;string&#39;</code>,<code>&#39;function&#39;</code>或<code>&#39;symbol&#39;</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/use-default-type-parameter/" target="_blank" rel="noopener">use-default-type-parameter</a></td><td>传入的类型与默认类型一致时，<strong>必须</strong>省略传入的类型</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/use-isnan/" target="_blank" rel="noopener">use-isnan</a></td><td><strong>必须</strong>使用<code>isNaN(foo)</code>而不是<code>foo === NaN</code></td></tr></tbody></table><h4 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h4><p>增强代码可维护性的规则。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://palantir.github.io/tslint/rules/cyclomatic-complexity/" target="_blank" rel="noopener">cyclomatic-complexity</a></td><td><strong>禁止</strong>函数的循环复杂度超过 20，详见 <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cyclomatic_complexity</a></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/deprecation/" target="_blank" rel="noopener">deprecation</a></td><td><strong>禁止</strong>使用废弃（被标识了<code>@deprecated</code>）的<code>API</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/eofline/" target="_blank" rel="noopener">eofline</a></td><td>文件最后一行<strong>必须</strong>有一个空行</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/indent/" target="_blank" rel="noopener">indent</a></td><td>一个缩进<strong>必须</strong>用四个空格替代</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/linebreak-style/" target="_blank" rel="noopener">linebreak-style</a></td><td>限制换行符为 LF 或 CRLF</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/max-classes-per-file/" target="_blank" rel="noopener">max-classes-per-file</a></td><td>限制每个文件的类的数量</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/max-file-line-count/" target="_blank" rel="noopener">max-file-line-count</a></td><td>限制每个文件的行数</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/max-line-length/" target="_blank" rel="noopener">max-line-length</a></td><td>限制每行字符数</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-default-export/" target="_blank" rel="noopener">no-default-export</a></td><td><strong>禁止</strong>使用<code>default export</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-duplicate-imports/" target="_blank" rel="noopener">no-duplicate-imports</a></td><td><strong>禁止</strong>出现重复的<code>import</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-require-imports/" target="_blank" rel="noopener">no-require-imports</a></td><td><strong>禁止</strong>使用<code>require</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/object-literal-sort-keys/" target="_blank" rel="noopener">object-literal-sort-keys</a></td><td>对象字面量<strong>必须</strong>按<code>key</code>排序</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/prefer-const/" target="_blank" rel="noopener">prefer-const</a></td><td>申明后不再被修改的变量<strong>必须</strong>使用<code>const</code>来申明</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/prefer-readonly/" target="_blank" rel="noopener">prefer-readonly</a></td><td>如果私有变量只在构造函数中被赋值，则<strong>必须</strong>使用<code>readonly</code>修饰符</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/trailing-comma/" target="_blank" rel="noopener">trailing-comma</a></td><td>限制对象、数组、解构赋值等的最后一项末尾是否需要逗号</td></tr></tbody></table><h4 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h4><p>与代码风格相关的规则。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://palantir.github.io/tslint/rules/align/" target="_blank" rel="noopener">align</a></td><td>变量定义需要竖向对其</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/array-type/" target="_blank" rel="noopener">array-type</a></td><td>限制<strong>必须</strong>使用<code>T[]</code>或<code>Array&lt;T&gt;</code>之中的一种来定义数组的类型</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/arrow-parens/" target="_blank" rel="noopener">arrow-parens</a></td><td>箭头函数的参数<strong>必须</strong>有小括号</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/arrow-return-shorthand/" target="_blank" rel="noopener">arrow-return-shorthand</a></td><td>箭头函数的函数体只有<code>return</code>语句的时候，<strong>必须</strong>简写</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/binary-expression-operand-order/" target="_blank" rel="noopener">binary-expression-operand-order</a></td><td>数字字面量<strong>必须</strong>在加号的右边，即<strong>禁止</strong><code>1 + x</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/callable-types/" target="_blank" rel="noopener">callable-types</a></td><td>可以简写为函数类型的接口或字面类似，<strong>必须</strong>简写</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/class-name/" target="_blank" rel="noopener">class-name</a></td><td>类名与接口名<strong>必须</strong>为驼峰式</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/comment-format/" target="_blank" rel="noopener">comment-format</a></td><td>限制单行注释的规则</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/completed-docs/" target="_blank" rel="noopener">completed-docs</a></td><td>类、函数等<strong>必须</strong>写注释</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/encoding/" target="_blank" rel="noopener">encoding</a></td><td>文件类型<strong>必须</strong>是<code>utf-8</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/file-header/" target="_blank" rel="noopener">file-header</a></td><td>文件的开头<strong>必须</strong>有指定的字符串</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/file-name-casing/" target="_blank" rel="noopener">file-name-casing</a></td><td>约束文件命名规范</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/import-spacing/" target="_blank" rel="noopener">import-spacing</a></td><td><code>import</code>语句中，关键字之间的间距<strong>必须</strong>是一个空格</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/interface-name/" target="_blank" rel="noopener">interface-name</a></td><td>接口名称<strong>必须</strong>已<code>I</code>开头</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/interface-over-type-literal/" target="_blank" rel="noopener">interface-over-type-literal</a></td><td>优先使用接口而不是字面类型</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/jsdoc-format/" target="_blank" rel="noopener">jsdoc-format</a></td><td>注释<strong>必须</strong>符合<code>JSDoc</code>规范</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/match-default-export-name/" target="_blank" rel="noopener">match-default-export-name</a></td><td><code>import</code>的名称<strong>必须</strong>和<code>export default</code>的名称一致</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/new-parens/" target="_blank" rel="noopener">new-parens</a></td><td><code>new</code>后面只<strong>必须</strong>有一个空格</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/newline-before-return/" target="_blank" rel="noopener">newline-before-return</a></td><td><code>return</code>语句前<strong>必须</strong>有空行</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/newline-per-chained-call/" target="_blank" rel="noopener">newline-per-chained-call</a></td><td>链式调用时，每次调用都<strong>必须</strong>占用一行</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-angle-bracket-type-assertion/" target="_blank" rel="noopener">no-angle-bracket-type-assertion</a></td><td>类型断言<strong>必须</strong>使用<code>as Type</code>，<strong>禁止</strong>使用<code>&lt;Type&gt;</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-boolean-literal-compare/" target="_blank" rel="noopener">no-boolean-literal-compare</a></td><td><strong>禁止</strong>变量与<code>true</code>或<code>false</code>比较</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-consecutive-blank-lines/" target="_blank" rel="noopener">no-consecutive-blank-lines</a></td><td><strong>禁止</strong>连续超过三行空行</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-irregular-whitespace/" target="_blank" rel="noopener">no-irregular-whitespace</a></td><td><strong>禁止</strong>使用特殊空白符（比如全角空格</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-parameter-properties/" target="_blank" rel="noopener">no-parameter-properties</a></td><td><strong>禁止</strong>给类的构造函数的参数添加修饰符</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-redundant-jsdoc/" target="_blank" rel="noopener">no-redundant-jsdoc</a></td><td><strong>禁止</strong>JSDoc 中的冗余类型声明，因为 TypeScirpt 已经包含了大部分功能</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-reference-import/" target="_blank" rel="noopener">no-reference-import</a></td><td>如果已经引入过库，则<strong>禁止</strong>使用三斜杠引入类型定义文件</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-trailing-whitespace/" target="_blank" rel="noopener">no-trailing-whitespace</a></td><td><strong>禁止</strong>行尾有空格</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-unnecessary-callback-wrapper/" target="_blank" rel="noopener">no-unnecessary-callback-wrapper</a></td><td><strong>禁止</strong>没必要的函数调用，如<code>x =&gt; f(x)</code>应该简写为<code>f</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-unnecessary-initializer/" target="_blank" rel="noopener">no-unnecessary-initializer</a></td><td><strong>禁止</strong>变量定义时赋值为<code>undefined</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/no-unnecessary-qualifier/" target="_blank" rel="noopener">no-unnecessary-qualifier</a></td><td>在命名空间中，可以直接使用内部变量，不需要添加命名空间前缀</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/number-literal-format/" target="_blank" rel="noopener">number-literal-format</a></td><td>小数<strong>必须</strong>以<code>0.</code>开头，<strong>禁止</strong>以<code>.</code>开头，并且不能以<code>0</code>结尾</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/object-literal-key-quotes/" target="_blank" rel="noopener">object-literal-key-quotes</a></td><td>对象的<code>key</code><strong>必须</strong>用引号包起来</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/object-literal-shorthand/" target="_blank" rel="noopener">object-literal-shorthand</a></td><td><strong>必须</strong>使用<code>a = {b}</code>而不是<code>a = {b: b}</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/one-line/" target="_blank" rel="noopener">one-line</a></td><td><code>if</code>后的<code>{</code><strong>禁止</strong>换行</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/one-variable-per-declaration/" target="_blank" rel="noopener">one-variable-per-declaration</a></td><td>变量申明<strong>必须</strong>每行一个，<code>for</code>循环的初始条件中除外</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/ordered-imports/" target="_blank" rel="noopener">ordered-imports</a></td><td><code>import</code><strong>必须</strong>排序</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/prefer-function-over-method/" target="_blank" rel="noopener">prefer-function-over-method</a></td><td>类中没有使用<code>this</code>的方法应该提取成类外的函数</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/prefer-method-signature/" target="_blank" rel="noopener">prefer-method-signature</a></td><td><strong>必须</strong>使用<code>foo(): void</code>而不是<code>foo: () =&gt; void</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/prefer-switch/" target="_blank" rel="noopener">prefer-switch</a></td><td>当<code>if</code>中只有<code>===</code>时，<strong>必须</strong>使用<code>switch</code>替换<code>if</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/prefer-template/" target="_blank" rel="noopener">prefer-template</a></td><td><strong>必须</strong>使用模版字符串而不是字符串连接</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/prefer-while/" target="_blank" rel="noopener">prefer-while</a></td><td>当没有初始值的时候，<strong>必须</strong>使用<code>while</code>而不是<code>for</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/quotemark/" target="_blank" rel="noopener">quotemark</a></td><td><strong>必须</strong>使用单引号，<code>jsx</code>中<strong>必须</strong>使用双引号</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/return-undefined/" target="_blank" rel="noopener">return-undefined</a></td><td>使用<code>return;</code>而不是<code>return undefined;</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/semicolon/" target="_blank" rel="noopener">semicolon</a></td><td>行尾<strong>必须</strong>有分号</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/space-before-function-paren/" target="_blank" rel="noopener">space-before-function-paren</a></td><td>函数名前<strong>必须</strong>有空格</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/space-within-parens/" target="_blank" rel="noopener">space-within-parens</a></td><td>括号内首尾<strong>禁止</strong>有空格</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/switch-final-break/" target="_blank" rel="noopener">switch-final-break</a></td><td><code>switch</code>的最后一项<strong>禁止</strong>有<code>break</code></td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/type-literal-delimiter/" target="_blank" rel="noopener">type-literal-delimiter</a></td><td>字面类型的每个成员都<strong>必须</strong>有分号</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/variable-name/" target="_blank" rel="noopener">variable-name</a></td><td>限制变量命名规则</td></tr><tr><td><a href="https://palantir.github.io/tslint/rules/whitespace/" target="_blank" rel="noopener">whitespace</a></td><td>限制空格的位置</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TSLint-规则&quot;&gt;&lt;a href=&quot;#TSLint-规则&quot; class=&quot;headerlink&quot; title=&quot;TSLint 规则&quot;&gt;&lt;/a&gt;TSLint 规则&lt;/h2&gt;&lt;p&gt;一套完整的 TSLint 规则，以及对每条规则的释义。&lt;/p&gt;
&lt;h3 id=&quot;使用
      
    
    </summary>
    
      <category term="typescript" scheme="http://sosout.com/categories/typescript/"/>
    
    
      <category term="note" scheme="http://sosout.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>React refs 的前世今生</title>
    <link href="http://sosout.com/2018/11/30/react-refs.html"/>
    <id>http://sosout.com/2018/11/30/react-refs.html</id>
    <published>2018-11-30T12:12:47.000Z</published>
    <updated>2018-11-30T14:14:12.258Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，React 通过声明式的渲染机制把复杂的 DOM 操作抽象成为简单的 state 与 props 操作，一时间将前端工程师从面条式的 DOM 操作中拯救出来。尽管我们一再强调在 React 开发中尽量避免 DOM 操作，但在一些场景中仍然无法避免。当然 React 并没有把路堵死，它提供了 ref 用于访问在 render 方法中创建的 DOM 元素或者是 React 组件实例。</p><h3 id="React-ref-使用"><a href="#React-ref-使用" class="headerlink" title="React ref 使用"></a>React ref 使用</h3><p>在 React v16.3 之前，ref 通过字符串（string ref）或者回调函数（callback ref）的形式进行获取，在 v16.3 中，经<a href="https://github.com/reactjs/rfcs/blob/master/text/0017-new-create-ref.md" target="_blank" rel="noopener">0017-new-create-ref</a>提案引入了新的 React.createRef API。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string ref</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.refs.myRef.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"myRef"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// callback ref</span></span><br><span class="line"><span class="xml">class MyComponent extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  componentDidMount() &#123;</span></span><br><span class="line"><span class="xml">    this.myRef.focus();</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line">    return &lt;input ref=&#123;(ele) =&gt; &#123;</span><br><span class="line">      this.myRef = ele;</span><br><span class="line">    &#125;&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// React.createRef</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.myRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;input ref=&#123;this.myRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="string-ref"><a href="#string-ref" class="headerlink" title="string ref"></a>string ref</h3><p>在 React.createRef 出现之前，string ref 就已被诟病已久，React 官方文档直接提出 string ref 将会在未来版本被移出，建议用户使用 callback ref 来代替，为何需要这么做呢？主要原因集中于以下几点：</p><ul><li><p>当 ref 定义为 string 时，需要 React 追踪当前正在渲染的组件，在 reconciliation 阶段，React Element 创建和更新的过程中，ref 会被封装为一个闭包函数，等待 commit 阶段被执行，这会对 React 的性能产生一些影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coerceRef</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> stringRef = <span class="string">''</span> + element.ref;</span><br><span class="line">  <span class="comment">// 从 fiber 中得到实例</span></span><br><span class="line">  <span class="keyword">let</span> inst = ownerFiber.stateNode;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ref 闭包函数</span></span><br><span class="line">  <span class="keyword">const</span> ref = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> refs = inst.refs === emptyObject ? (inst.refs = &#123;&#125;) : inst.refs;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> refs[stringRef];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      refs[stringRef] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  ref._stringRef = stringRef;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当使用 render callback 模式时，使用 string ref 会造成 ref 挂载位置产生歧义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  renderRow = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// string ref 会挂载在 DataTable this 上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;</span>'<span class="attr">input-</span>' + <span class="attr">index</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // callback ref 会挂载在 MyComponent this 上</span></span><br><span class="line">    return &lt;input ref=&#123;input =&gt; this['input-' + index] = input&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;DataTable data=&#123;this.props.data&#125; renderRow=&#123;this.renderRow&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>string ref 无法被组合，例如一个第三方库的父组件已经给子组件传递了 ref，那么我们就无法再在子组件上添加 ref 了，而 callback ref 可完美解决此问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** string ref **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 可获取到 this.refs.childRef</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> React.cloneElement(children, &#123;</span><br><span class="line">      ref: <span class="string">'childRef'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// this.refs.child 无法获取到</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Parent&gt;</span><br><span class="line">        &lt;Child ref=<span class="string">"child"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Parent&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>** callback ref **<span class="regexp">/</span></span><br><span class="line"><span class="regexp">class Parent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 可以获取到 child ref</span></span><br><span class="line"><span class="regexp">    console.log(this.childRef);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    const &#123; children &#125; = this.props;</span></span><br><span class="line"><span class="regexp">    return React.cloneElement(children, &#123;</span></span><br><span class="line"><span class="regexp">      ref: (child) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        this.childRef = child;</span></span><br><span class="line"><span class="regexp">        children.ref &amp;&amp; children.ref(child);</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 可以获取到 child ref</span></span><br><span class="line"><span class="regexp">    console.log(this.child);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Parent&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Child ref=&#123;(child) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          this.child = child;</span></span><br><span class="line"><span class="regexp">        &#125;&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Parent&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在根组件上使用无法生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">ref</span>=<span class="string">"app"</span> /&gt;</span>, document.getElementById('main'));</span></span><br></pre></td></tr></table></figure></li><li><p>对于静态类型较不友好，当使用 string ref 时，必须显式声明 refs 的类型，无法完成自动推导。</p></li><li><p>编译器无法将 string ref 与其 refs 上对应的属性进行混淆，而使用 callback ref，可被混淆。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** string ref，无法混淆 */</span></span><br><span class="line"><span class="keyword">this</span>.refs.myRef</span><br><span class="line">&lt;div ref=<span class="string">"myRef"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** callback ref, 可以混淆 */</span></span><br><span class="line"><span class="keyword">this</span>.myRef</span><br><span class="line">&lt;div ref=&#123;(dom) =&gt; &#123; <span class="keyword">this</span>.myRef = dom; &#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.r</span><br><span class="line">&lt;div ref=&#123;(e) =&gt; &#123; <span class="keyword">this</span>.r = e; &#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="createRef-vs-callback-ref"><a href="#createRef-vs-callback-ref" class="headerlink" title="createRef vs callback ref"></a>createRef vs callback ref</h3><p>对比新的 createRef 与 callback ref，并没有压倒性的优势，只是希望成为一个便捷的特性，在性能上会会有微小的优势，callback ref 采用了组件 render 过程中在闭包函数中分配 ref 的模式，而 createRef 则采用了 object ref。</p><p>createRef 显得更加直观，类似于 string ref，避免了 callback ref 的一些理解问题，对于 callback ref 我们通常会使用内联函数的形式，那么每次渲染都会重新创建，由于 react 会清理旧的 ref 然后设置新的（见下图，commitDetachRef -&gt; commitAttachRef），因此更新期间会调用两次，第一次为 null，如果在 callback 中带有业务逻辑的话，可能会出错，当然可以通过将 callback 定义成类成员函数并进行绑定的方式避免。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      a: <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;(dom) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 输出 3 次</span></span><br><span class="line">        <span class="comment">// &lt;div data-reactroot&gt;&lt;/div&gt;</span></span><br><span class="line">        <span class="comment">// null</span></span><br><span class="line">        <span class="comment">// &lt;div data-reactroot&gt;&lt;/div&gt;</span></span><br><span class="line">        <span class="built_in">console</span>.log(dom);</span><br><span class="line">      &#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.refCallback = <span class="keyword">this</span>.refCallback.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      a: <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  refCallback(dom) &#123;</span><br><span class="line">    <span class="comment">// 只输出 1 次</span></span><br><span class="line">    <span class="comment">// &lt;div data-reactroot&gt;&lt;/div&gt;</span></span><br><span class="line">    <span class="built_in">console</span>.log(dom);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.refCallback&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过不得不承认，createRef 在能力上仍逊色于 callback ref，例如上一节提到的组合问题，createRef 也是无能为力的。在 React v16.3 中，string ref/callback ref 与 createRef 的处理略有差别，让我们来看一下 ref 整个构建流程。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// markRef 前会进行新旧 ref 的引用比较</span></span><br><span class="line"><span class="keyword">if</span> (current.ref !== workInProgress.ref) &#123;</span><br><span class="line">  markRef(workInProgress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectTag 基于位操作，其中有 ref 的变更标志位</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markRef</span>(<span class="params">workInProgress: Fiber</span>) </span>&#123;</span><br><span class="line">  workInProgress.effectTag |= Ref;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// effectTag 与 Ref 的 &amp; 操作表示当前 fiber 有 ref 变更</span></span><br><span class="line"><span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">  commitAttachRef(nextEffect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAttachRef</span>(<span class="params">finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = finishedWork.ref;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">    <span class="keyword">let</span> instanceToUse;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="comment">// 当前 Host 环境为 DOM 环境，HostComponent 即为 DOM 元素，需要借助实例获取原生 DOM 元素</span></span><br><span class="line">      <span class="keyword">case</span> HostComponent:</span><br><span class="line">        instanceToUse = getPublicInstance(instance);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 对于 ClassComponent 等而言，直接返回实例即可</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        instanceToUse = instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// string ref 与 callback 都会去执行 ref 闭包函数</span></span><br><span class="line">    <span class="comment">// createRef 会直接挂在 object ref 的 current 上</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">'function'</span>) &#123;</span><br><span class="line">      ref(instanceToUse);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.current = instanceToUse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上会涉及 react fiber 的一些概念与细节，比如：fiber 对象含义，fiber tree 构建更新过程，effectTag 的含义与收集过程等等，如果读者对上述细节不熟悉，可暂时跳过此段内容，不影响对于 ref 的掌握与理解。</p><h3 id="React-forwardRef"><a href="#React-forwardRef" class="headerlink" title="React.forwardRef"></a>React.forwardRef</h3><p>除了 createRef 以外，React16 还另外提供了一个关于 ref 的 API React.forwardRef，主要用于穿过父元素直接获取子元素的 ref。在提到 forwardRef 的使用场景之前，我们先来回顾一下，HOC（higher-order component）在 ref 使用上的问题，HOC 的 ref 是无法通过 props 进行传递的，因此无法直接获取被包裹组件（WrappedComponent），需要进行中转。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOCProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOCComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.setWrappedInstance = <span class="keyword">this</span>.setWrappedInstance.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getWrappedInstance() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.wrappedInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 ref 的访问</span></span><br><span class="line">    setWrappedInstance(ref) &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrappedInstance = ref;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">ref</span>=<span class="string">&#123;this.setWrappedInstance&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return HOCComponent;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const App = HOCProps(Wrap);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">&lt;App ref=&#123;(dom) =&gt; &#123;</span><br><span class="line">  // 只能获取到 HOCComponent</span><br><span class="line">  console.log(dom);</span><br><span class="line">  // 通过中转后可以获取到 WrappedComponent</span><br><span class="line">  console.log(dom.getWrappedInstance());</span><br><span class="line">&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>React.forwardRef 的原理其实非常简单，forwardRef 会生成 react 内部一种较为特殊的 Component。当进行创建更新操作时，会将 forwardRef 组件上的 props 与 ref 直接传递给提前注入的 render 函数，来生成 children。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextChildren = render(workInProgress.pendingProps, workInProgress.ref);</span><br></pre></td></tr></table></figure></p><p>React refs 到此就全部介绍完了，在 React16 新版本中，新引入了 React.createRef 与 React.forwardRef 两个 API，有计划移除老的 string ref，使 ref 的使用更加便捷与明确。如果你的应用已经升级到 React16.3+ 版本，那就放心大胆使用 React.createRef 吧，如果暂时没有的话，建议使用 callback ref 来代替 string ref。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/40462264" target="_blank" rel="noopener">React ref 的前世今生</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知，React 通过声明式的渲染机制把复杂的 DOM 操作抽象成为简单的 state 与 props 操作，一时间将前端工程师从面条式的 DOM 操作中拯救出来。尽管我们一再强调在 React 开发中尽量避免 DOM 操作，但在一些场景中仍然无法避免。当然 React
      
    
    </summary>
    
      <category term="react" scheme="http://sosout.com/categories/react/"/>
    
    
      <category term="refs" scheme="http://sosout.com/tags/refs/"/>
    
  </entry>
  
  <entry>
    <title>npx—npm 5.2.0 内置的包执行器</title>
    <link href="http://sosout.com/2018/11/29/npm-npx.html"/>
    <id>http://sosout.com/2018/11/29/npm-npx.html</id>
    <published>2018-11-29T12:19:27.000Z</published>
    <updated>2018-11-29T10:56:39.081Z</updated>
    
    <content type="html"><![CDATA[<p>最近在更新 npm 5.2.0 的时候，我发现除了可以使用npm命令，还有一个命令可以使用，这就是npx。</p><p>npm使得安装和管理依赖包变得非常简单，和npm的类似，npx这款工具旨在提供给用户更方便的包操作体验。当我们使用一些工具命令或者可执行文件时，相对于npm，npx把这个过程变得更加简单了。</p><p>根据<a href="https://github.com/zkat/npx" target="_blank" rel="noopener">zkat/npx</a> 的描述，npx 会帮我们执行依赖包里的二进制文件。<br>举例来说，之前我们可能会写这样的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack</span><br><span class="line">./node_modules/.bin/webpack -v</span><br></pre></td></tr></table></figure></p><p>如果你对 bash 比较熟，可能会写成这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack</span><br><span class="line">`npm bin`/webpack -v</span><br></pre></td></tr></table></figure></p><p>有了 npx，我们只需要这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx webpack -v</span><br></pre></td></tr></table></figure></p><p>也就是说 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！<br>npx 甚至支持运行远程仓库的可执行文件，如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ npx github:piuccio/cowsay hello</span><br><span class="line">npx: 1 安装成功，用时 1.663 秒</span><br><span class="line"> _______</span><br><span class="line">&lt; hello &gt;</span><br><span class="line"> -------</span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\/\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br></pre></td></tr></table></figure></p><p>再比如 npx http-server 可以一句话帮你开启一个静态服务器！（第一次运行会稍微慢一些）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npx http-server</span><br><span class="line">npx: 23 安装成功，用时 48.633 秒</span><br><span class="line">Starting up http-server, serving ./</span><br><span class="line">Available on:</span><br><span class="line">  http://127.0.0.1:8080</span><br><span class="line">  http://192.168.5.14:8080</span><br><span class="line">Hit CTRL-C to stop the server</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在更新 npm 5.2.0 的时候，我发现除了可以使用npm命令，还有一个命令可以使用，这就是npx。&lt;/p&gt;
&lt;p&gt;npm使得安装和管理依赖包变得非常简单，和npm的类似，npx这款工具旨在提供给用户更方便的包操作体验。当我们使用一些工具命令或者可执行文件时，相对于n
      
    
    </summary>
    
      <category term="npm" scheme="http://sosout.com/categories/npm/"/>
    
    
      <category term="npx" scheme="http://sosout.com/tags/npx/"/>
    
  </entry>
  
  <entry>
    <title>Node 定时器详解</title>
    <link href="http://sosout.com/2018/11/24/node-timer.html"/>
    <id>http://sosout.com/2018/11/24/node-timer.html</id>
    <published>2018-11-24T09:17:20.000Z</published>
    <updated>2018-11-24T11:35:05.051Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 是单线程运行，异步操作特别重要。</p><p>只要用到引擎之外的功能，就需要跟外部交互，从而形成异步操作。由于异步操作实在太多，JavaScript 不得不提供很多异步语法。这就好比，有些人老是受打击， 他的抗打击能力必须变得很强，否则他就完蛋了。</p><p>Node 的异步语法比浏览器更复杂，因为它可以跟内核对话，不得不搞了一个专门的库 libuv 做这件事。这个库负责各种回调函数的执行时间，毕竟异步任务最后还是要回到主线程，一个个排队执行。</p><p>为了协调异步任务，Node 居然提供了四个定时器，让任务可以在指定的时间运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout()</span><br><span class="line">setInterval()</span><br><span class="line">setImmediate()</span><br><span class="line">process.nextTick()</span><br></pre></td></tr></table></figure></p><p>前两个是语言的标准，后两个是 Node 独有的。它们的写法差不多，作用也差不多，不太容易区别。</p><p>你能说出下面代码的运行结果吗？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))();</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><p>首先，同步任务总是比异步任务更早执行。</p><p>前面的那段代码，只有最后一行是同步任务，因此最早执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))();</span><br></pre></td></tr></table></figure></p><h3 id="本轮循环和次轮循环"><a href="#本轮循环和次轮循环" class="headerlink" title="本轮循环和次轮循环"></a>本轮循环和次轮循环</h3><p>异步任务可以分成两种：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">追加在本轮循环的异步任务</span><br><span class="line">追加在次轮循环的异步任务</span><br></pre></td></tr></table></figure></p><p>所谓”循环”，指的是事件循环（event loop）。这是 JavaScript 引擎处理异步任务的方式，后文会详细解释。这里只要理解，本轮循环一定早于次轮循环执行即可。</p><p>Node 规定，process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环。</p><p>这就是说，文首那段代码的第三行和第四行，一定比第一行和第二行更早执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两行，次轮循环执行</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 下面两行，本轮循环执行</span></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br></pre></td></tr></table></figure></p><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h3><p>process.nextTick这个名字有点误导，它是在本轮循环执行的，而且是所有异步任务里面最快执行的。</p><p>Node 执行完所有同步任务，接下来就会执行process.nextTick的任务队列。所以，下面这行代码是第二个输出结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p><p>基本上，如果你希望异步任务尽可能快地执行，那就使用process.nextTick。</p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>根据语言规格，Promise对象的回调函数，会进入异步任务里面的”微任务”（microtask）队列。</p><p>微任务队列追加在process.nextTick队列的后面，也属于本轮循环。所以，下面的代码总是先输出3，再输出4。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><p>注意，只有前一个队列全部清空以后，才会执行下一个队列。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，全部process.nextTick的回调函数，执行都会早于Promise的。</p><p>至此，本轮循环的执行顺序就讲完了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步任务</span><br><span class="line">process.nextTick()</span><br><span class="line">微任务</span><br></pre></td></tr></table></figure></p><h3 id="事件循环的概念"><a href="#事件循环的概念" class="headerlink" title="事件循环的概念"></a>事件循环的概念</h3><p>下面开始介绍次轮循环的执行顺序，这就必须理解什么是事件循环（event loop）了。</p><p>首先，有些人以为，除了主线程，还存在一个单独的事件循环线程。不是这样的，只有一个主线程，事件循环是在主线程上完成的。</p><p>其次，Node 开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同步任务</span><br><span class="line">发出异步请求</span><br><span class="line">规划定时器生效的时间</span><br><span class="line">执行process.nextTick()等等</span><br></pre></td></tr></table></figure></p><p>最后，上面这些事情都干完了，事件循环就正式开始了。</p><h3 id="事件循环的六个阶段"><a href="#事件循环的六个阶段" class="headerlink" title="事件循环的六个阶段"></a>事件循环的六个阶段</h3><p>事件循环会无限次地执行，一轮又一轮。只有异步任务的回调函数队列清空了，才会停止执行。</p><p>每一轮的事件循环，分成六个阶段。这些阶段会依次执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">timers</span><br><span class="line">I/O callbacks</span><br><span class="line">idle, prepare</span><br><span class="line">poll</span><br><span class="line">check</span><br><span class="line">close callbacks</span><br></pre></td></tr></table></figure></p><p>每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。</p><p>下面简单介绍一下每个阶段的含义：</p><h4 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h4><p>这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。</p><h4 id="I-O-callbacks"><a href="#I-O-callbacks" class="headerlink" title="I/O callbacks"></a>I/O callbacks</h4><p>除了以下操作的回调函数，其他的回调函数都在这个阶段执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout()和setInterval()的回调函数</span><br><span class="line">setImmediate()的回调函数</span><br><span class="line">用于关闭请求的回调函数，比如socket.on(<span class="string">'close'</span>, ...)</span><br></pre></td></tr></table></figure></p><h4 id="idle-prepare"><a href="#idle-prepare" class="headerlink" title="idle, prepare"></a>idle, prepare</h4><p>该阶段只供 libuv 内部调用，这里可以忽略。</p><h4 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h4><p>这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。</p><p>这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。</p><h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>该阶段执行setImmediate()的回调函数。</p><h4 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h4><p>该阶段执行关闭请求的回调函数，比如socket.on(‘close’, …)。</p><h3 id="事件循环的示例"><a href="#事件循环的示例" class="headerlink" title="事件循环的示例"></a>事件循环的示例</h3><p>下面是来自官方文档的一个示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务一：100ms 后执行的定时器</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务二：文件读取后，有一个 200ms 的回调函数</span></span><br><span class="line">fs.readFile(<span class="string">'test.js'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - startCallback &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 什么也不做</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码有两个异步任务，一个是 100ms 后执行的定时器，一个是文件读取，它的回调函数需要 200ms。请问运行结果是什么？</p><p>脚本进入第一轮事件循环以后，没有到期的定时器，也没有已经可以执行的 I/O 回调函数，所以会进入 Poll 阶段，等待内核返回文件读取的结果。由于读取小文件一般不会超过 100ms，所以在定时器到期之前，Poll 阶段就会得到结果，因此就会继续往下执行。</p><p>第二轮事件循环，依然没有到期的定时器，但是已经有了可以执行的 I/O 回调函数，所以会进入 I/O callbacks 阶段，执行fs.readFile的回调函数。这个回调函数需要 200ms，也就是说，在它执行到一半的时候，100ms 的定时器就会到期。但是，必须等到这个回调函数执行完，才会离开这个阶段。</p><p>第三轮事件循环，已经有了到期的定时器，所以会在 timers 阶段执行定时器。最后输出结果大概是200多毫秒。</p><h3 id="setTimeout-和-setImmediate"><a href="#setTimeout-和-setImmediate" class="headerlink" title="setTimeout 和 setImmediate"></a>setTimeout 和 setImmediate</h3><p>由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p><p>上面代码应该先输出1，再输出2，但是实际执行的时候，结果却是不确定，有时还会先输出2，再输出1。</p><p>这是因为setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，根据官方文档，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。</p><p>实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。</p><p>但是，下面的代码一定是先输出2，再输出1。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'test.js'</span>, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript 是单线程运行，异步操作特别重要。&lt;/p&gt;
&lt;p&gt;只要用到引擎之外的功能，就需要跟外部交互，从而形成异步操作。由于异步操作实在太多，JavaScript 不得不提供很多异步语法。这就好比，有些人老是受打击， 他的抗打击能力必须变得很强，否则他就完蛋了。&lt;
      
    
    </summary>
    
      <category term="nodejs" scheme="http://sosout.com/categories/nodejs/"/>
    
    
      <category term="timer" scheme="http://sosout.com/tags/timer/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript函数柯里化</title>
    <link href="http://sosout.com/2018/11/23/javascript-currying.html"/>
    <id>http://sosout.com/2018/11/23/javascript-currying.html</id>
    <published>2018-11-23T14:01:35.000Z</published>
    <updated>2018-11-23T10:59:55.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h3><h4 id="官方的说法"><a href="#官方的说法" class="headerlink" title="官方的说法"></a>官方的说法</h4><p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由克里斯托弗·斯特雷奇以逻辑学家哈斯凯尔·加里命名的，尽管它是Moses Schönfinkel和戈特洛布·弗雷格发明的。</p><p>在直觉上，柯里化声称如果你固定某些参数，你将得到接受余下参数的一个函数。<br>在理论计算机科学中，柯里化提供了在简单的理论模型中，比如：只接受一个单一参数的lambda演算中，研究带有多个参数的函数的方式。<br>函数柯里化的对偶是Uncurrying，一种使用匿名单参数函数来实现多参数函数的方法。</p><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><blockquote><p>高阶函数定义：将函数作为参数或者返回值是函数的函数。</p></blockquote><p>所以高阶函数分两种：</p><ul><li>我们常见的 sort,reduce 等函数。</li><li>返回值是函数的函数。</li></ul><p>一般而言，我们要理解常见的高阶函数还是很容易的。比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add3 = add(<span class="number">3</span>)</span><br><span class="line">add3(<span class="number">4</span>) === <span class="number">3</span> + <span class="number">4</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>add 函数 在 es6 里的写法等价为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br></pre></td></tr></table></figure></p><p>其实以上就是 柯里化函数 只不过用 es6 写，变了一个样子，后面详细介绍它的原理和特点。</p><h3 id="柯里化或偏函数有什么用？"><a href="#柯里化或偏函数有什么用？" class="headerlink" title="柯里化或偏函数有什么用？"></a>柯里化或偏函数有什么用？</h3><p>无论是柯里化还是偏应用，我们都能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。</p><p>另一个最能体现柯里化应用的的是，当函数只有一个形参时，我们能够比较容易地组合它们（单一职责原则（Single responsibility principle））。因此，如果一个函数最终需要三个实参，那么它被柯里化以后会变成需要三次调用，每次调用需要一个实参的函数。当我们组合函数时，这种单元函数的形式会让我们处理起来更简单。</p><p>归纳下来，主要为以下常见的三个用途：</p><ul><li>延迟计算</li><li>参数复用</li><li>动态生成函数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是柯里化？&quot;&gt;&lt;a href=&quot;#什么是柯里化？&quot; class=&quot;headerlink&quot; title=&quot;什么是柯里化？&quot;&gt;&lt;/a&gt;什么是柯里化？&lt;/h3&gt;&lt;h4 id=&quot;官方的说法&quot;&gt;&lt;a href=&quot;#官方的说法&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="javascript" scheme="http://sosout.com/categories/javascript/"/>
    
    
      <category term="currying" scheme="http://sosout.com/tags/currying/"/>
    
  </entry>
  
  <entry>
    <title>es6 教程</title>
    <link href="http://sosout.com/2018/11/23/es6-tutorial.html"/>
    <id>http://sosout.com/2018/11/23/es6-tutorial.html</id>
    <published>2018-11-23T13:39:37.000Z</published>
    <updated>2018-11-24T01:19:33.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>Symbol 是EC6规格所支持的一种新的数据类型</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>作为属性名避免属性名冲突</li><li>替代代码中多次使用的字符串（例如：abc），多次使用的字符串在代码中不易维护，而这时候定义一个对象的属性（属性名用Symbol格式），值为abc，就可以作为全局变量来使用了。</li><li>由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</li><li>这个有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</li></ul><h3 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h3><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>按照MDN上的说明：</p><blockquote><p>WeakMap 对象是键/值对的集合，且其中的键是弱引用的。其键只能是对象，而值则可以是任意的。</p></blockquote><p>从这段描述来看，我们可以大致推断出，WeakMap与Map的主要区别在于两点：</p><ul><li>WeakMap对key的引用是弱引用</li><li>WeakMap的key只能是对象null除外），不接受其他类型的值作为键名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.set(key, <span class="number">2</span>);</span><br><span class="line">wm1.get(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[k1, <span class="string">'foo'</span>], [k2, <span class="string">'bar'</span>]]);</span><br><span class="line">wm2.get(k2) <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><p>具体而言，WeakMap大致有如下一些明显的特性：<br><strong>1、WeakMap的key只能是对象（null除外），不接受其他类型的值作为键名</strong><br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">var</span> k = &#123;&#125;;</span><br><span class="line"><span class="comment">// 设置键值对</span></span><br><span class="line">m.set(k, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">m.get(k);   <span class="comment">//1</span></span><br><span class="line"><span class="comment">// 非对象的key会报错</span></span><br><span class="line">m.set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">m.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">m.set(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure></p><p>在上例中，我们使用了对象k作为WeakMap的key，设置了value为1。到下面取值的时候，只能使用同一个对象k去取。也就是说WeakMap是按照key的引用来对value进行存取的。如果将数值1和Symbol值作为 WeakMap 的键名，都会报错。</p><blockquote><p>关于“key只能使用对象”和“value的查找是通过比较key的引用”这两个命题，其实是互为因果的，本质上是一个先有鸡还是先有蛋的问题：<br>正因为WeakMap只能使用对象作为key，所以取值的时候对key进行查找也只能按对象引用进行查找。<br>正因为WeakMap在查找的时候只能按对象引用进行查找，所以只能使用对象作为key，否则存进去的值根本无法查找取出。</p></blockquote><p><strong>2、key中的对象保持弱引用，不计入垃圾回收机制</strong><br>弱引用正是WeakMap中“Weak”的含义。熟悉JavaScript的朋友都知道引用是怎么回事，简单地说，当一个对象被引用的时候，往往意味着它正在被使用，或者在将来有可能会被使用。此时对象不会被垃圾回收机制回收掉。<br>WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [e1, <span class="string">'foo 元素'</span>],</span><br><span class="line">  [e2, <span class="string">'bar 元素'</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>上面代码中，e1和e2是两个对象，我们通过arr数组对这两个对象添加一些文字说明。这就形成了arr对e1和e2的引用。</p><p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要 e1 和 e2 的时候</span></span><br><span class="line"><span class="comment">// 必须手动删除引用</span></span><br><span class="line">arr [<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p><p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p><p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p><p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><p>也就是说，上面的 DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p><p>总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p><p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// size、forEach、clear 方法都不存在</span></span><br><span class="line">wm.size <span class="comment">// undefined</span></span><br><span class="line">wm.forEach <span class="comment">// undefined</span></span><br><span class="line">wm.clear <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><p>WeakMap 应用的典型场合就是 DOM 节点作为键名。</p><h3 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h3><h4 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h4><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure></p><p>上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。</p><p>模块的接口改名和整体输出，也可以采用这种写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> myFoo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体输出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure></p><p>默认接口的写法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure></p><p>具名接口改为默认接口的写法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure></p><p>同样地，默认接口也可以改名为具名接口。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br></pre></td></tr></table></figure></p><p>下面三种import语句，没有对应的复合写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> someIdentifier <span class="keyword">from</span> <span class="string">"someModule"</span>;</span><br><span class="line"><span class="keyword">import</span> someIdentifier <span class="keyword">from</span> <span class="string">"someModule"</span>;</span><br><span class="line"><span class="keyword">import</span> someIdentifier, &#123; namedIdentifier &#125; <span class="keyword">from</span> <span class="string">"someModule"</span>;</span><br></pre></td></tr></table></figure></p><p>为了做到形式的对称，现在有提案，提出补上这三种复合写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> someIdentifier <span class="keyword">from</span> <span class="string">"someModule"</span>;</span><br><span class="line"><span class="keyword">export</span> someIdentifier <span class="keyword">from</span> <span class="string">"someModule"</span>;</span><br><span class="line"><span class="keyword">export</span> someIdentifier, &#123; namedIdentifier &#125; <span class="keyword">from</span> <span class="string">"someModule"</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;h3 id=&quot;Symbol&quot;&gt;&lt;a href=&quot;#Symbol&quot; class=&quot;headerlink&quot; title=&quot;Symbo
      
    
    </summary>
    
      <category term="es6" scheme="http://sosout.com/categories/es6/"/>
    
    
      <category term="note" scheme="http://sosout.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks — 新一代 React API</title>
    <link href="http://sosout.com/2018/11/14/react-hooks.html"/>
    <id>http://sosout.com/2018/11/14/react-hooks.html</id>
    <published>2018-11-14T14:08:41.000Z</published>
    <updated>2018-11-23T10:59:55.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不得不说 React 等优秀框架的出现为前端开发带来了极大的便利，但是在<code>React v16.7</code>提出<code>Hooks</code>之前我们依旧不得不面对一些很恶心的问题：</p><h3 id="组件逻辑复用麻烦且很有可能造成嵌套黑洞（Wrapper-Hell）"><a href="#组件逻辑复用麻烦且很有可能造成嵌套黑洞（Wrapper-Hell）" class="headerlink" title="组件逻辑复用麻烦且很有可能造成嵌套黑洞（Wrapper Hell）"></a>组件逻辑复用麻烦且很有可能造成嵌套黑洞（Wrapper Hell）</h3><p>我们都知道react的核心思想是：将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来，但如果我们在大型项目中用react，我们便会发现项目中很多react组件冗长且难以复用，尤其是那些写成class的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。在 hooks 之前官方推荐的解决方式：<a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">渲染属性（Render Props）</a>和<a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件（Higher-Order Components）</a>，我们现在简单看一下这两种模式：</p><h4 id="渲染属性（Render-Props）"><a href="#渲染属性（Render-Props）" class="headerlink" title="渲染属性（Render Props）"></a>渲染属性（Render Props）</h4><p><code>渲染属性（Render Props）</code>是一个组件间共享代码逻辑的小技巧, 通过props传递函数来实现。组件中有一个叫做<code>render</code>的<code>prop</code>, 值是一个返回React元素的函数, 在组件内部调用这个函数渲染组件。语言描述不够直观, 我们来看一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> mouse = <span class="keyword">this</span>.props.mouse;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;img src=<span class="string">"/cat.jpg"</span> style=&#123;&#123; <span class="attr">position</span>: <span class="string">'absolute'</span>, <span class="attr">left</span>: mouse.x, <span class="attr">top</span>: mouse.y &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleMouseMove = <span class="keyword">this</span>.handleMouseMove.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">height</span>: <span class="string">'100%'</span> &#125;&#125; onMouseMove=&#123;<span class="keyword">this</span>.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">          使用传入函数的逻辑动态渲染</span></span><br><span class="line"><span class="comment">          而不是硬编码地渲染固定内容</span></span><br><span class="line"><span class="comment">        */</span>&#125;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class MouseTracker extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1&gt;Move the mouse around!&lt;/</span>h1&gt;</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Cat mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>可以看到我们的<code>Mouse</code>组件包含了所有跟状态相关的代码，而<code>Cat</code>组件则只是一个单纯的展示型组件，这样一来我们可以随处复用<code>Mouse</code>组件了。</p><p>虽然这个技巧或者说模式(Pattern)叫<code>Render Props</code>, 但不是说非用一个叫render的props来传递渲染函数, 习惯上我们更常写成下面这种：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mouse&gt;</span><br><span class="line">  &#123;mouse =&gt; (</span><br><span class="line">    &lt;p&gt;The mouse position is &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Mouse&gt;</span><br></pre></td></tr></table></figure></p><h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4><p>简单说高阶组件就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，withUser函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withUser = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = sessionStorage.getItem(<span class="string">"user"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">props</span> =&gt;</span> &lt;WrappedComponent user=&#123;user&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserPage = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"user-container"</span>&gt;</span><br><span class="line">    &lt;p&gt;My name is &#123;props.user&#125;!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withUser(UserPage);</span></span><br></pre></td></tr></table></figure></p><p>以上这两种模式看上去都挺不错的，有许多库(比如React Router, React Motion)都有使用这些模式。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开devtool看看我们的组件层级嵌套是不是很夸张吧。如果我们采用 hooks 方式，把各种想要的功能写成一个一个可复用的自定义hook，当我们的组件想用什么功能时，直接在组件里调用这个hook即可，这样就简洁了许多，也没有多余的层级嵌套。</p><h3 id="组件生命周期混乱"><a href="#组件生命周期混乱" class="headerlink" title="组件生命周期混乱"></a>组件生命周期混乱</h3><p>由于React生命周期的存在，我们常常将一些逻辑强相关的代码分散地放置在组件的不同位置，造成我们的组件中出现了许多零散的、重复的代码，比如我们在 componentDidMount 中绑定事件、添加定时器，然后在 componentWillUnmount 中移除他们；又或者频繁地在 componentDidUpdate 中比较变化前和变化后的state来决定是否执行某些逻辑。</p><h3 id="无状态组件（Function）和有状态组件（Class）选择问题"><a href="#无状态组件（Function）和有状态组件（Class）选择问题" class="headerlink" title="无状态组件（Function）和有状态组件（Class）选择问题"></a>无状态组件（Function）和有状态组件（Class）选择问题</h3><p>回想我们在刚开始学习React的时候常常会疑惑该使用Functional Component(那个时候我们叫Stateless Component)还是有状态组件（Class Component），虽然两者得到的结果大致相同，但是书写方式却迥然不同。有些组件可能最开始的时候使用Functional，后来发现需要加入生命周期和state的支持又不得不大费周折地改成Class。这样不清不楚的定位对许多初学者来说，无疑造成了很大的困扰。更有些开发者便无脑的都使用 Class Component。</p><h3 id="Class-Component-的-this-指向问题"><a href="#Class-Component-的-this-指向问题" class="headerlink" title="Class Component 的 this 指向问题"></a>Class Component 的 this 指向问题</h3><p>我们用class创建react组件时，还有一件很麻烦的事情，就是this的指向问题。为了保证this的指向正确，我们要经常写这样的代码：<code>this.handleClick = this.handleClick.bind(this)</code>，或者是这样的代码：<code>&lt;button onClick={() =&gt; this.handleClick(e)}&gt;</code>。一旦我们不小心忘了绑定this，各种bug就随之而来，很麻烦。</p><h3 id="Class-Component-无法-prepack-优化"><a href="#Class-Component-无法-prepack-优化" class="headerlink" title="Class Component 无法 prepack 优化"></a>Class Component 无法 prepack 优化</h3><p>在 class 里，类的属性即便内部没用到，对外部还是可访问的，所以类的属性在Uglify的时候是不会被编译的，同时如果一个类的方法没有被使用，编译器也无法将它识别出来并精简掉。</p><p>在这样的背景下，Hooks便横空出世了！</p><h2 id="什么是-Hooks"><a href="#什么是-Hooks" class="headerlink" title="什么是 Hooks"></a>什么是 Hooks</h2><p><code>Hooks</code>是 React 提供的一系列新的方法（习惯上以useXXX命名）。这些方法将state、context和Class组件中的生命周期，统统抽象成了函数，使得我们在Functional组件中也能使用它们，甚至我们还可以将它们彼此进行组合，从而将特定的逻辑进一步进行抽象和封装，进一步作为npm包的形式进行发布！</p><p>接下来我们一起认识一下新增的几个方法：</p><ul><li>State Hook: 为组件提供访问state的能力</li><li>Effect Hook: 监听state的变动，并在合适的时候调用</li><li>Custom Hooks: 用户自定义的钩子，是以上两者的组合。方便用户对操作state的逻辑进行封装</li><li>Other Hooks: 主要包括访问Context的钩子和管理复杂state的钩子</li></ul><h3 id="State-Hook-React-useState"><a href="#State-Hook-React-useState" class="headerlink" title="State Hook: React.useState"></a>State Hook: React.useState</h3><p><strong>useState: (any<t>) =&gt; [state: <t>, (newState) =&gt; null]</t></t></strong><br>useState 方法比较简单，基本就是一个简化版的 setState 。每次调用会生成一个新的state，并将状态与组件绑定。来看一个简单的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Declare a new state variable, which we'll call "count"</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>我们再来看一下使用class component后的版本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Click me</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>可以看出，使用hooks后，代码简单了许多。我们分解来看到底state hooks做了什么：</p><h4 id="声明状态变量"><a href="#声明状态变量" class="headerlink" title="声明状态变量"></a>声明状态变量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>useState是react自带的一个hook函数，它的作用就是用来声明状态变量。useState这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第<code>[0]</code>项是当前的状态值，第<code>[1]</code>项是可以改变状态值的函数，所以其实useState做的事情就是：声明了一个状态变量count，把它的初始值设为0，同时提供了一个可以更改count的函数setCount。上面这种表达形式，是借用了<a href="http://es6.ruanyifeng.com/#docs/destructuring#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" target="_blank" rel="noopener">es6的数组解构（array destructuring）</a>，让我们的代码看起来更简洁。实际上数组解构是一件开销很大的事情，用下面这种写法，或者改用对象解构，性能会有很大的提升。如果不用数组解构的话，也可以写成下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _useState = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> count = _useState[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> setCount = _useState[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p><h4 id="使用状态值"><a href="#使用状态值" class="headerlink" title="使用状态值"></a>使用状态值</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是不是超简单？因为我们的状态count就是一个单纯的变量而已，我们再也不需要写成<code>{this.state.count}</code>这样了。</p><h4 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="line">  Click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当用户点击按钮时，我们调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给react了，react将会重新渲染我们的Example组件，并且使用的是更新后的新状态，即count=1。这里我们要停下来思考一下，Example本质上也是一个普通的函数，为什么它可以记住之前的状态？</p><h4 id="React-帮忙记住之前的状态"><a href="#React-帮忙记住之前的状态" class="headerlink" title="React 帮忙记住之前的状态"></a>React 帮忙记住之前的状态</h4><p>通常来说我们在一个函数中声明的变量，当函数运行完成后，这个变量也就销毁了（这里我们先不考虑闭包等情况），比如考虑下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line">add(<span class="number">1</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p>不管我们反复调用add函数多少次，结果都是1。因为每一次我们调用add时，result变量都是从初始值0开始的。那为什么上面的Example函数每次执行的时候，都是拿的上一次执行完的状态值作为初始值？答案是：是react帮我们记住的。至于react是用什么机制记住的，我们可以再思考一下。</p><h4 id="React-记住状态的关键点"><a href="#React-记住状态的关键点" class="headerlink" title="React 记住状态的关键点"></a>React 记住状态的关键点</h4><p>首先，useState是可以多次调用的，所以我们完全可以这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</span><br><span class="line">  <span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">'banana'</span>);</span><br><span class="line">  <span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">'Learn Hooks'</span> &#125;]);</span><br></pre></td></tr></table></figure></p><p>其次，useState接收的初始值没有规定一定要是string/number/boolean这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的this.setState做的是合并状态后返回一个新状态，而useState是直接替换老状态后返回新状态。最后，react也给我们提供了一个useReducer的hook，如果我们更喜欢redux式的状态管理方案的话。</p><p>从ExampleWithManyStates函数我们可以看到，useState无论调用多少次，相互之间是独立的。这一点至关重要。为什么这么说呢？</p><p>其实我们看hook的“形态”，有点类似之前被官方否定掉的Mixins这种方案，都是提供一种“插拔式的功能注入”的能力。而mixins之所以被否定，是因为Mixins机制是让多个Mixins共享一个对象的数据空间，这样就很难确保不同Mixins依赖的状态不发生冲突。</p><p>而现在我们的hook，一方面它是直接用在function当中，而不是class；另一方面每一个hook都是相互独立的，不同组件调用同一个hook也能保证各自状态的独立性，这就是两者的本质区别。</p><h4 id="react是根据useState出现的顺序记住状态"><a href="#react是根据useState出现的顺序记住状态" class="headerlink" title="react是根据useState出现的顺序记住状态"></a>react是根据useState出现的顺序记住状态</h4><p>还是看上面给出的ExampleWithManyStates例子，我们调用了三次useState，每次我们传的参数只是一个值（如42，‘banana’），我们根本没有告诉react这些值对应的key是哪个，那react是怎么保证这三个useState找到它对应的state呢？</p><p>答案是，react是根据useState出现的顺序来定的。我们具体来看一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次渲染</span></span><br><span class="line">useState(<span class="number">42</span>);  <span class="comment">//将age初始化为42</span></span><br><span class="line">useState(<span class="string">'banana'</span>);  <span class="comment">//将fruit初始化为banana</span></span><br><span class="line">useState([&#123; <span class="attr">text</span>: <span class="string">'Learn Hooks'</span> &#125;]); <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次渲染</span></span><br><span class="line">useState(<span class="number">42</span>);  <span class="comment">//读取状态变量age的值（这时候传的参数42直接被忽略）</span></span><br><span class="line">useState(<span class="string">'banana'</span>);  <span class="comment">//读取状态变量fruit的值（这时候传的参数banana直接被忽略）</span></span><br><span class="line">useState([&#123; <span class="attr">text</span>: <span class="string">'Learn Hooks'</span> &#125;]); <span class="comment">//...</span></span><br></pre></td></tr></table></figure></p><p>假如我们改一下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> showFruit = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(showFruit) &#123;</span><br><span class="line">    <span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">'banana'</span>);</span><br><span class="line">    showFruit = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">'Learn Hooks'</span> &#125;]);</span><br></pre></td></tr></table></figure></p><p>这样一来，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次渲染</span></span><br><span class="line">useState(<span class="number">42</span>);  <span class="comment">//将age初始化为42</span></span><br><span class="line">useState(<span class="string">'banana'</span>);  <span class="comment">//将fruit初始化为banana</span></span><br><span class="line">useState([&#123; <span class="attr">text</span>: <span class="string">'Learn Hooks'</span> &#125;]); <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次渲染</span></span><br><span class="line">useState(<span class="number">42</span>);  <span class="comment">//读取状态变量age的值（这时候传的参数42直接被忽略）</span></span><br><span class="line"><span class="comment">// useState('banana');  </span></span><br><span class="line">useState([&#123; <span class="attr">text</span>: <span class="string">'Learn Hooks'</span> &#125;]); <span class="comment">//读取到的却是状态变量fruit的值，导致报错</span></span><br></pre></td></tr></table></figure></p><p>鉴于此，react规定我们必须把hooks写在函数的最外层，不能写在ifelse等条件语句当中，来确保hooks的执行顺序一致。</p><h3 id="Effect-Hook-React-useEffect"><a href="#Effect-Hook-React-useEffect" class="headerlink" title="Effect Hook: React.useEffect"></a>Effect Hook: React.useEffect</h3><p><strong>useEffect: (() =&gt; {do sth…; return () =&gt; null}, []) =&gt; null</strong><br>因为通过useEffect，我们可以完成对Class Component所有关键生命周期的访问。 我们详细来看一下：</p><p>首先 useEffect 方法接收两个参数：</p><ul><li><p>第一个参数是一个函数<br>这个函数会在每次组件重新update后被调用（我们也可以理解为每次render之后会调用一遍这个方法）。只使用这个方法的作用和 componentDidUpdate 差不多，比如要实现输入和document.title的双向绑定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">''</span>)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = value</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> &#123;setValue(e.target.value)&#125;&#125; /&gt;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>这个函数的返回值也是一个函数<br>回想一下，在使用class组件时， componentDidMount 其实是一类特殊的 componentDidUpdate —— 前者只会在第一次update时调用。所以在functional组件中，我们也可以使用useEffect来模拟 componentDidUpdate，只要区分函数的调用时机就可以。</p></li></ul><p>不过在useEffect里不是这样做的。useEffect的做法更简单粗暴一些：在state更新时调用，在下一次render之前清理。useEffect方法接收一个函数作为返回值，返回的函数会在下一次render之前被调用。 (总觉得这样会不会太粗暴了一点，因为每次重新render都会绑定一次事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#example).addEventListener('</span>click<span class="string">', handleClick)</span></span><br><span class="line"><span class="string">    return () =&gt; &#123;</span></span><br><span class="line">      document.querySelector('#example).removeEventListener('click', handleClick)  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span>Lorem<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>第三个知识点是这个函数的第二个参数是一个数组<br>这个数组里的值可以等同于我们在写 componentDidUpdate 里的条件判断。只有当数组中包含的值变化的时候才会触发当前的useEffect。</li></ul><p>我们在上一节的例子中增加一个新功能：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似于componentDidMount 和 componentDidUpdate:</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 更新文档的标题</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>我们对比看一下，如果没有hooks，我们会怎么写？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Click me</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起ajax请求获取数据，添加一些监听的注册和取消注册，手动修改dom等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如componentDidMount，componentDidUpdate和componentWillUnmount。而现在的useEffect就相当与这些声明周期函数钩子的集合体。它以一抵三。</p><p>同时，由于前文所说hooks可以反复多次使用，相互独立。所以我们合理的做法是，给每一个副作用一个单独的useEffect钩子。这样一来，这些副作用不再一股脑堆在生命周期钩子里，代码变得更加清晰。</p><h4 id="useEffect做了什么？"><a href="#useEffect做了什么？" class="headerlink" title="useEffect做了什么？"></a>useEffect做了什么？</h4><p>我们再梳理一遍下面代码的逻辑：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p>首先，我们声明了一个状态变量count，将它的初始值设为0。然后我们告诉react，我们的这个组件有一个副作用。我们给useEffecthook传了一个匿名函数，这个匿名函数就是我们的副作用。在这个例子里，我们的副作用是调用browser API来修改文档标题。当react要渲染我们的组件时，它会先记住我们用到的副作用。等react更新了DOM之后，它再依次执行我们定义的副作用函数。</p><p>这里要注意几点：</p><p>第一，react首次渲染和之后的每次渲染都会调用一遍传给useEffect的函数。而之前我们要用两个声明周期函数来分别表示首次渲染（componentDidMount）和之后的更新导致的重新渲染（componentDidUpdate）。</p><p>第二，useEffect中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的componentDidMount或componentDidUpdate中的代码则是同步执行的。这种安排对大多数副作用说都是合理的，但有的情况除外，比如我们有时候需要先根据DOM计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生。</p><h4 id="useEffect怎么解绑一些副作用"><a href="#useEffect怎么解绑一些副作用" class="headerlink" title="useEffect怎么解绑一些副作用"></a>useEffect怎么解绑一些副作用</h4><p>这种场景很常见，当我们在componentDidMount里添加了一个注册，我们得马上在componentWillUnmount中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。</p><p>怎么清除呢？让我们传给useEffect的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。这种模式在一些pubsub模式的实现中很常见。看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    <span class="comment">// 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有一个点需要重视！这种解绑的模式跟componentWillUnmount不一样。componentWillUnmount只会在组件被销毁前执行一次而已，而useEffect里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。所以我们一起来看一下下面这个问题。</p><h4 id="为什么要让副作用函数每次组件更新都执行一遍？"><a href="#为什么要让副作用函数每次组件更新都执行一遍？" class="headerlink" title="为什么要让副作用函数每次组件更新都执行一遍？"></a>为什么要让副作用函数每次组件更新都执行一遍？</h4><p>我们先看以前的模式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  ChatAPI.subscribeToFriendStatus(</span><br><span class="line">    <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">    <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">    <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">    <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很清除，我们在componentDidMount注册，再在componentWillUnmount清除注册。但假如这时候props.friend.id变了怎么办？我们不得不再添加一个componentDidUpdate来处理这种情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  componentDidUpdate(prevProps) &#123;</span><br><span class="line">    <span class="comment">// 先把上一个friend.id解绑</span></span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">      prevProps.friend.id,</span><br><span class="line">      <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 再重新注册新但friend.id</span></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">      <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">      <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>看到了吗？很繁琐，而我们但useEffect则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>页面首次渲染</span><br><span class="line"><span class="number">2.</span>替friend.id=<span class="number">1</span>的朋友注册</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>突然friend.id变成了<span class="number">2</span></span><br><span class="line"><span class="number">4.</span>页面重新渲染</span><br><span class="line"><span class="number">5.</span>清除friend.id=<span class="number">1</span>的绑定</span><br><span class="line"><span class="number">6.</span>替friend.id=<span class="number">2</span>的朋友注册</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="怎么跳过一些不必要的副作用函数"><a href="#怎么跳过一些不必要的副作用函数" class="headerlink" title="怎么跳过一些不必要的副作用函数"></a>怎么跳过一些不必要的副作用函数</h4><p>按照上一节的思路，每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给useEffect传第二个参数即可。用第二个参数来告诉react只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 只有当count的值发生变化时，才会重新执行`document.title`这一句</span></span><br></pre></td></tr></table></figure></p><p>当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。也就是componentDidMount加componentWillUnmount的模式。不过这种用法可能带来bug，少用。</p><h3 id="还有哪些自带的Effect-Hooks"><a href="#还有哪些自带的Effect-Hooks" class="headerlink" title="还有哪些自带的Effect Hooks?"></a>还有哪些自带的Effect Hooks?</h3><p>除了上文重点介绍的useState和useEffect，react还给我们提供来很多有用的hooks：<br>useContext<br>useReducer<br>useCallback<br>useMemo<br>useRef<br>useImperativeMethods<br>useMutationEffect<br>useLayoutEffect</p><h3 id="怎么写自定义的Effect-Hooks"><a href="#怎么写自定义的Effect-Hooks" class="headerlink" title="怎么写自定义的Effect Hooks?"></a>怎么写自定义的Effect Hooks?</h3><p>为什么要自己去写一个Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。</p><p>比如我们可以把上面写的FriendStatus组件中判断朋友是否在线的功能抽出来，新建一个useFriendStatus的hook专门用来判断某个id是否在线。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候FriendStatus组件就可以简写为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简直Perfect！假如这个时候我们又有一个朋友列表也需要显示是否在线的信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;li style=&#123;&#123; <span class="attr">color</span>: isOnline ? <span class="string">'green'</span> : <span class="string">'black'</span> &#125;&#125;&gt;</span><br><span class="line">      &#123;props.friend.name&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>简直Fabulous！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;不得不说 React 等优秀框架的出现为前端开发带来了极大的便利，但是在&lt;code&gt;React v16.7&lt;/code&gt;提出&lt;code&gt;Ho
      
    
    </summary>
    
      <category term="react" scheme="http://sosout.com/categories/react/"/>
    
    
      <category term="hooks" scheme="http://sosout.com/tags/hooks/"/>
    
  </entry>
  
  <entry>
    <title>Nuxtjs 开发笔记</title>
    <link href="http://sosout.com/2018/11/03/nuxt-tutorial.html"/>
    <id>http://sosout.com/2018/11/03/nuxt-tutorial.html</id>
    <published>2018-11-03T13:13:56.000Z</published>
    <updated>2018-11-03T06:32:50.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发用法"><a href="#开发用法" class="headerlink" title="开发用法"></a>开发用法</h2><h3 id="按需引入UI组件库"><a href="#按需引入UI组件库" class="headerlink" title="按需引入UI组件库"></a>按需引入UI组件库</h3><p>这边以 element-ui 组件库为例：</p><h4 id="使用-babel-plugin-import"><a href="#使用-babel-plugin-import" class="headerlink" title="使用 babel-plugin-import"></a>使用 babel-plugin-import</h4><p><code>babel-plugin-import</code>是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 babel-plugin-import 插件</span></span><br><span class="line">npm i babel-plugin-import -D</span><br></pre></td></tr></table></figure></p><h4 id="配置nuxt-config-js："><a href="#配置nuxt-config-js：" class="headerlink" title="配置nuxt.config.js："></a>配置nuxt.config.js：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'universal'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  ** Headers of the page</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  head: &#123;</span><br><span class="line">    title: pkg.name,</span><br><span class="line">    meta: [</span><br><span class="line">      &#123; <span class="attr">charset</span>: <span class="string">'utf-8'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">'viewport'</span>, <span class="attr">content</span>: <span class="string">'width=device-width, initial-scale=1'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">hid</span>: <span class="string">'description'</span>, <span class="attr">name</span>: <span class="string">'description'</span>, <span class="attr">content</span>: pkg.description &#125;</span><br><span class="line">    ],</span><br><span class="line">    link: [</span><br><span class="line">      &#123; <span class="attr">rel</span>: <span class="string">'icon'</span>, <span class="attr">type</span>: <span class="string">'image/x-icon'</span>, <span class="attr">href</span>: <span class="string">'/favicon.ico'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  ** Customize the progress-bar color</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  loading: &#123; <span class="attr">color</span>: <span class="string">'#fff'</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  ** Global CSS</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  css: [</span><br><span class="line">    <span class="comment">// 自定义公共 CSS 文件</span></span><br><span class="line">    <span class="string">'@/assets/css/common.css'</span></span><br><span class="line">    <span class="comment">// 全部引用的时候需要用到</span></span><br><span class="line">    <span class="comment">// 'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  ** Plugins to load before mounting the App</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  plugins: [</span><br><span class="line">    &#123; <span class="attr">src</span>: <span class="string">'@/plugins/element-ui'</span>, <span class="attr">ssr</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  ** Nuxt.js modules</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  modules: [</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  ** Build configuration</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  build: &#123;</span><br><span class="line">    analyze: <span class="literal">true</span>,</span><br><span class="line">    vendor: [<span class="string">'element-ui'</span>],</span><br><span class="line">    maxChunkSize: <span class="number">300000</span>,</span><br><span class="line">    babel: &#123;</span><br><span class="line">      plugins: [</span><br><span class="line">        [</span><br><span class="line">          <span class="string">'component'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">'libraryName'</span>: <span class="string">'element-ui'</span>,</span><br><span class="line">            <span class="string">'styleLibraryName'</span>: <span class="string">'theme-chalk'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ** You can extend webpack config here</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    extend(config, ctx) &#123;</span><br><span class="line">      <span class="comment">// Run ESLint on save</span></span><br><span class="line">      <span class="keyword">if</span> (ctx.isDev &amp;&amp; ctx.isClient) &#123;</span><br><span class="line">        config.module.rules.push(&#123;</span><br><span class="line">          enforce: <span class="string">'pre'</span>,</span><br><span class="line">          test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">          loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">          exclude: <span class="regexp">/(node_modules)/</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改plugins-element-ui-js："><a href="#修改plugins-element-ui-js：" class="headerlink" title="修改plugins/element-ui.js："></a>修改plugins/element-ui.js：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line">Vue.component(Button.name, Button)</span><br></pre></td></tr></table></figure><h4 id="最后使用组件"><a href="#最后使用组件" class="headerlink" title="最后使用组件"></a>最后使用组件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>主要按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开发用法&quot;&gt;&lt;a href=&quot;#开发用法&quot; class=&quot;headerlink&quot; title=&quot;开发用法&quot;&gt;&lt;/a&gt;开发用法&lt;/h2&gt;&lt;h3 id=&quot;按需引入UI组件库&quot;&gt;&lt;a href=&quot;#按需引入UI组件库&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Nuxtjs" scheme="http://sosout.com/categories/Nuxtjs/"/>
    
    
      <category term="note" scheme="http://sosout.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库自增主键归零的几种方法</title>
    <link href="http://sosout.com/2018/11/02/mysql-rzero.html"/>
    <id>http://sosout.com/2018/11/02/mysql-rzero.html</id>
    <published>2018-11-02T07:01:48.000Z</published>
    <updated>2018-11-03T03:12:52.182Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL自增主键归零的方法：</p><h3 id="一、如果曾经的数据都不需要的话，可以直接清空所有数据，并将自增字段恢复从1开始计数："><a href="#一、如果曾经的数据都不需要的话，可以直接清空所有数据，并将自增字段恢复从1开始计数：" class="headerlink" title="一、如果曾经的数据都不需要的话，可以直接清空所有数据，并将自增字段恢复从1开始计数："></a>一、如果曾经的数据都不需要的话，可以直接清空所有数据，并将自增字段恢复从1开始计数：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table table_name;</span><br></pre></td></tr></table></figure><h3 id="二、当用户没有truncate的权限时且曾经的数据不需要时："><a href="#二、当用户没有truncate的权限时且曾经的数据不需要时：" class="headerlink" title="二、当用户没有truncate的权限时且曾经的数据不需要时："></a>二、当用户没有truncate的权限时且曾经的数据不需要时：</h3><ul><li>1、删除原有主键：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table <span class="string">'table_name'</span> drop <span class="string">'id'</span>;</span><br></pre></td></tr></table></figure><ul><li>2、添加新主键：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table <span class="string">'table_name'</span> add <span class="string">'id'</span> int(<span class="number">11</span>) not <span class="literal">null</span> first;</span><br></pre></td></tr></table></figure><ul><li>3、设置新主键：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table <span class="string">'table_name'</span> modify column <span class="string">'id'</span> int(<span class="number">11</span>) not <span class="literal">null</span> auto_increment, add primary key(id);</span><br></pre></td></tr></table></figure><h3 id="三、当用户没有权限时："><a href="#三、当用户没有权限时：" class="headerlink" title="三、当用户没有权限时："></a>三、当用户没有权限时：</h3><ul><li>1、可以直接设置数据表的 AUTO_INCREMENT 值为想要的初始值，比如10000：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table <span class="string">'table_name'</span> auto_increment = <span class="number">10000</span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL自增主键归零的方法：&lt;/p&gt;
&lt;h3 id=&quot;一、如果曾经的数据都不需要的话，可以直接清空所有数据，并将自增字段恢复从1开始计数：&quot;&gt;&lt;a href=&quot;#一、如果曾经的数据都不需要的话，可以直接清空所有数据，并将自增字段恢复从1开始计数：&quot; class=&quot;head
      
    
    </summary>
    
      <category term="mysql" scheme="http://sosout.com/categories/mysql/"/>
    
    
      <category term="rzero" scheme="http://sosout.com/tags/rzero/"/>
    
  </entry>
  
  <entry>
    <title>参与一个 GitHub 开源项目</title>
    <link href="http://sosout.com/2018/11/01/part-github-open-project.html"/>
    <id>http://sosout.com/2018/11/01/part-github-open-project.html</id>
    <published>2018-11-01T12:43:12.000Z</published>
    <updated>2018-11-03T03:12:52.185Z</updated>
    
    <content type="html"><![CDATA[<p>gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。gitHub作为开源项目的著名托管地，可谓无人不知，越来越多的个人和公司纷纷加入到Github的大家族里来，好多人都想为开源尽一份绵薄之力。对于个人来讲，我们把自己的项目托管到gitHub上并不表示我们参与了gitHub开源项目，只能说我们开源了自己的项目，可以任别人自由下载。那么该如何参与gitHub的开源项目呢？相信很多人都有这方面的疑问，网上也有一些参差不齐的教程教大家如何“pull request”、如何“commit”等等。但这些教程往往不够全面或不够完全正确，搞不好可能让我们陷入一个误区。<br>下面将涵盖我们在一个典型的项目中可能出现的事情以及如何为开源项目作出贡献。</p><h2 id="找项目"><a href="#找项目" class="headerlink" title="找项目"></a>找项目</h2><p>我们推荐从已正在使用的或感兴趣的项目开始。这里有几个很棒的地方供参考：</p><p><strong><a href="https://github.com/explore" target="_blank" rel="noopener">GitHub Explore</a></strong>：受欢迎和热门的项目。<br><strong><a href="https://github.com/stars?direction=desc&amp;sort=created" target="_blank" rel="noopener">GitHub Stars</a></strong>：被其他人star过的项目（指的是我们自己库的项目）。<br><strong><a href="https://github.com/collections" target="_blank" rel="noopener">GitHub Showcases</a></strong>：一个能搜索相关库的方法。<br><strong><a href="https://www.designernews.co/" target="_blank" rel="noopener">LayerVault News</a></strong>：前端和设计相关的项目。</p><h2 id="Github开源项目中可能遇到的因素"><a href="#Github开源项目中可能遇到的因素" class="headerlink" title="Github开源项目中可能遇到的因素"></a>Github开源项目中可能遇到的因素</h2><h3 id="Community（社区）"><a href="#Community（社区）" class="headerlink" title="Community（社区）"></a>Community（社区）</h3><p>项目通常会有一个社区维护，由不同角色（正规或非正规）的其他用户组成：<br><strong>所有者（Owner）</strong>：即创建该项目且在他们Github账户上有该项目的用户或组织。<br><strong>维护者和协作者（Maintainers and Collaborators）</strong>：致力于一个项目并促进该项目发展的用户。通常所有者和维护者是同一个用户或组织，他们对项目库都有写的权限。<br><strong>贡献者（Contributors）</strong>：每一个对该项目发出过pull request并合并到项目中的用户都是贡献者。<br><strong>社区成员（Community Members）</strong>：即那些经常使用且非常关心该项目的用户，他们在讨论功能特征和pull request上非常活跃。</p><h3 id="Docs（文档）"><a href="#Docs（文档）" class="headerlink" title="Docs（文档）"></a>Docs（文档）</h3><p>一般项目中都有的文件。</p><h3 id="Readme"><a href="#Readme" class="headerlink" title="Readme"></a>Readme</h3><p>几乎所有的Github项目都包含一个<code>README.md</code>文件。readme提供了该项目的一个概览及关于如何使用、构建甚至如何贡献于一个项目的相关细节。</p><h3 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h3><p>项目和项目维护者不同，所以每个项目所期望的作贡献的最佳方法也会有所不同。一定要注意一个标注为<code>CONTRIBUTING</code>的文档，Contributing文档详细描述了一个项目的维护者希望看到贡献的补丁或功能应该符合怎样的规格。这可能包含要写什么测试，代码语法规范或补丁集中的区域。</p><h3 id="License"><a href="#License" class="headerlink" title="License"></a>License</h3><p>一个LICENSE文件当然就是该项目的许可证了。一个开源项目的license会告诉用户他们能做和不能做的（例如使用、修改、重新发布），及告诉贡献者他们允许其他人做的。有许多的办法对开源项目加上许可证，我们可以在<a href="https://choosealicense.com/" target="_blank" rel="noopener">choosealicense.com</a>读到更多的关于每个许可证的含义。</p><h3 id="Documentation-and-Wikis"><a href="#Documentation-and-Wikis" class="headerlink" title="Documentation and Wikis"></a>Documentation and Wikis</h3><p>许多大型项目有的不只有一个readme来指导人么如何使用他们的项目。在这种情况下我们通常能够发现一个指向库中名为“docs”的另一个文件或文件夹的链接。另外，该库也可能使用Github wiki来代替文档。</p><h2 id="参与项目"><a href="#参与项目" class="headerlink" title="参与项目"></a>参与项目</h2><p>既然我们已经找到了理解该项目的相关资料，下面我们就可以采取一些行动了。</p><h3 id="创建话题"><a href="#创建话题" class="headerlink" title="创建话题"></a>创建话题</h3><p>如果我们发现了正在使用的项目中的一个bug（但是我们不知道怎么去修复它），或对文档有不解或对项目有疑问 — 那么创建一个话题吧！这非常容易且一般我们不管创建什么话题，我们都可能不是唯一一个出现该问题的人，所以其他人可能会发现我们的话题很有帮助。关于更多的话题介绍，请查看我们的<a href="https://guides.github.com/features/issues/" target="_blank" rel="noopener">Issues guide</a>。</p><h4 id="话题专业提示"><a href="#话题专业提示" class="headerlink" title="话题专业提示"></a>话题专业提示</h4><p>在建话题之前检查已有的话题：话题重复对双方都无利，所以搜索整个正开放和已关闭的话题以检查我们遇到的问题是否已经有人解决了。<br>务必对自己的问题有清晰的认识：期望的结果是什么？然而却发生了什么？ 详细描述其他人如何重现该问题。<br>在像<a href="http://jsfiddle.net/" target="_blank" rel="noopener">JSFiddle</a>或<a href="https://codepen.io/" target="_blank" rel="noopener">CodePen</a>类似的平台上重现该问题并给出问题demo的链接。<br>包含一些系统相关的细节，比如用的什么浏览器、库或操作系统及版本号。<br>在我们的话题或在Gist里贴出我们的错误输出或日志。如果在话题里贴出来，请用三个反引号 ```，包围起来使得能够良好的呈现给大家。</p><h3 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h3><p>如果我们能够修复bug或自己添加功能 — 太棒了，请发一个pull request 吧！确保我们已经读过任何关于contributing的文档，且需要理解license以及已经签过CLA（如果需要的话）。一旦我们提交了一个pull request，维护者就会将我们的分支与已有的分支作比较来决定是否要合并（即pull in）我们作的改动。</p><h4 id="Pull-Request专业提示"><a href="#Pull-Request专业提示" class="headerlink" title="Pull Request专业提示"></a>Pull Request专业提示</h4><ul><li><a href="https://guides.github.com/activities/forking/" target="_blank" rel="noopener">Fork</a><strong>该项目库</strong>及将它clone到本地。通过添加为远程的方式在本地连接到原来的‘upstream’库。经常从‘upstream’库<strong>pull in</strong>改动以保持库最新，这样当我们提交pull request时，就不大可能发生合并冲突了。点<a href="https://help.github.com/articles/syncing-a-fork/" target="_blank" rel="noopener">这里</a>看更多的指导细节。</li><li>为我们的编辑<strong>单独建立一个</strong><a href="https://guides.github.com/introduction/flow/" target="_blank" rel="noopener">分支</a>。</li><li><strong>务必清楚</strong>所出现的问题以及如何重现该问题或为什么我们的功能有帮助。然后同样的要清楚做一些改变有哪些步骤。</li><li>最好测试一下。在任何已有的测试（如果存在）上运行我们所做的改动并在必要时创建新的测试。不管测试存不存在，都要确保我们的改动不会破坏已有的项目。</li><li>如果我们的改动包含了HTML/CSS方面的不同，那么请包含改动前和改动后的截图。将我们的图片拖放到我们pull request的正文里。</li><li>尽我们所能的在项目的风格上多做努力。这可能意味着使用不同于我们自己Github库中采用的缩进，分号或注释，但是这让维护者更容易合并，也让其他人更容易理解和以后的维护。</li></ul><h3 id="开放的Pull-Requests"><a href="#开放的Pull-Requests" class="headerlink" title="开放的Pull Requests"></a>开放的Pull Requests</h3><p>一旦我们打开一个pull request，就会有一个讨论，围绕我们提出的改变作出探讨。其他的贡献者和用户可能会参与进来，但最终由维护者做决定。我们可能会被要求对我们的pull request做一些改变，如果这样，请给我们的分支添加更多的commit并push它们 — 它们将自动的加入到已有的pull request里。</p><p>如果我们的pull request被合并了 — 太好了！如果没被合并的话，也没什么大不了的，也许这不是项目维护者所期望看到的改动，亦或者他们已经致力于该bug或功能。这种情况有可能发生，所以我们的建议是：对收到的结果做出反馈，进一步努力然后再次pull request出去— 或者创建我们自己的开源项目。</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><h3 id="首先需要在github上注册账号并登陆，这个不多说了"><a href="#首先需要在github上注册账号并登陆，这个不多说了" class="headerlink" title="首先需要在github上注册账号并登陆，这个不多说了"></a>首先需要在github上注册账号并登陆，这个不多说了</h3><h3 id="安装git，到github官网下载安装包。"><a href="#安装git，到github官网下载安装包。" class="headerlink" title="安装git，到github官网下载安装包。"></a>安装git，到github官网下载安装包。</h3><h3 id="为账号添加添加ssh-key"><a href="#为账号添加添加ssh-key" class="headerlink" title="为账号添加添加ssh key"></a>为账号添加添加ssh key</h3><h3 id="fork我们想参与的开源项目"><a href="#fork我们想参与的开源项目" class="headerlink" title="fork我们想参与的开源项目"></a>fork我们想参与的开源项目</h3><p>浏览github上的开源项目，然后点击fork，这时就跳转到了我们的账号下，此项目就是我们账号下的一个项目了。fork就相当于把别人的项目克隆到自己的账号下一份，以后我们的修改都应是提交到我们自己github账号下的这个项目中，我们是没有权限直接push到原作者账号下的项目中的。</p><h3 id="clone项目到本地"><a href="#clone项目到本地" class="headerlink" title="clone项目到本地"></a>clone项目到本地</h3><h4 id="复制项目clone地址"><a href="#复制项目clone地址" class="headerlink" title="复制项目clone地址"></a>复制项目clone地址</h4><p>注意是clone自己账号下的项目地址，不是原作者的，原作者的我们虽然也可以clone到本地，但是我们是没push权限的。还要注意这里咱们使用ssh协议，所以要选择ssh类型的地址。</p><h3 id="将项目原地址添加为远程仓库"><a href="#将项目原地址添加为远程仓库" class="headerlink" title="将项目原地址添加为远程仓库"></a>将项目原地址添加为远程仓库</h3><p>复制原作者的项目地址，添加为自己的一个远程仓库，用来实时将原项目的修改更新到咱们本地并合并。注意也是复制ssh协议类型的地址哦。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add upstream 原作者的远程仓库</span><br></pre></td></tr></table></figure></p><p>使用 git remote -v可以看到我们有两个仓库一个origin，咱们自己的github仓库；一个upstream，原作者的远程仓库。当然也可以不用upstream这个名字。</p><h3 id="创建branch，用于添加自己的修改"><a href="#创建branch，用于添加自己的修改" class="headerlink" title="创建branch，用于添加自己的修改"></a>创建branch，用于添加自己的修改</h3><p>这只是一个约定成俗的方式，当然我们也可以在master上添加修改，创建新的branch添加自己的修改的好处是，我们可以同时添加多个修改，在一个修改还没有被原作者merge时，我们可以用master创建新的branch继续我们的其它修改。<br>在这里我们在新添加的分支上修改：执行如下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="built_in">test</span>  <span class="comment"># 创建test分支</span></span><br><span class="line"></span><br><span class="line">$ git checkout <span class="built_in">test</span>   <span class="comment"># 切换到test分支</span></span><br></pre></td></tr></table></figure></p><p>然后就可以添加我们的修改了。</p><h3 id="将修改push到我们的github上"><a href="#将修改push到我们的github上" class="headerlink" title="将修改push到我们的github上"></a>将修改push到我们的github上</h3><p>由于我们的github上还没有test分支，所以我们得把命令写全了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin <span class="built_in">test</span>:<span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>我们的修改已经push到了我们的github下了，但是我们要向原作者请求合并到原项目中，如果原作者合并了，也就意味着我们是此项目的贡献者了。到我们的github上点击pull request按钮，创建一个pull request。提交完pull request，原作者就会看到我们的合并请求，我们就等待原作者是否采纳了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、clone时一定要注意选择ssh协议的链接。否则可能导致clone失败，或者后续push失败。</p><p>2、将公钥添加到github后，一定要更新自己当前的私钥（命令：ssh-add ~/.ssh/id_rsa），否则会push失败。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。gitHub作为开源项目的著名托管地，可谓无人不知，越来越多的个人和公司纷纷加入到Github的大家族里来，好多人都想为开源尽一份绵薄之力。对于个人来讲，我
      
    
    </summary>
    
      <category term="github" scheme="http://sosout.com/categories/github/"/>
    
    
      <category term="open" scheme="http://sosout.com/tags/open/"/>
    
  </entry>
  
  <entry>
    <title>Shell 开发汇总</title>
    <link href="http://sosout.com/2018/10/31/shell-tutorial.html"/>
    <id>http://sosout.com/2018/10/31/shell-tutorial.html</id>
    <published>2018-10-31T13:09:06.000Z</published>
    <updated>2018-11-03T03:12:52.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell-教程"><a href="#Shell-教程" class="headerlink" title="Shell 教程"></a>Shell 教程</h2><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><h3 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h3><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。</p><h3 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h3><p>Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。Linux 的 Shell 种类众多，常见的有：</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="bash-usr-local-bin-Permission-denied"><a href="#bash-usr-local-bin-Permission-denied" class="headerlink" title="bash: /usr/local/bin: Permission denied"></a>bash: /usr/local/bin: Permission denied</h3><p>原因：数据权限问题</p><p>解决办法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod 755 /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">$ sudo chmod -R 755 /usr/<span class="built_in">local</span>/bin <span class="comment"># 递归下面</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shell-教程&quot;&gt;&lt;a href=&quot;#Shell-教程&quot; class=&quot;headerlink&quot; title=&quot;Shell 教程&quot;&gt;&lt;/a&gt;Shell 教程&lt;/h2&gt;&lt;p&gt;Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是
      
    
    </summary>
    
      <category term="shell" scheme="http://sosout.com/categories/shell/"/>
    
    
      <category term="note" scheme="http://sosout.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>揭秘 http</title>
    <link href="http://sosout.com/2018/10/30/http-tutorial.html"/>
    <id>http://sosout.com/2018/10/30/http-tutorial.html</id>
    <published>2018-10-30T03:34:58.000Z</published>
    <updated>2018-11-03T03:12:52.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="options-请求"><a href="#options-请求" class="headerlink" title="options 请求"></a>options 请求</h3><p>当我们的 ajax 的请求为非简单请求时，浏览器会进行预检，即发送 OPTIONS 请求到服务器，询问是否允许跨域。如果响应中允许我们预检请求的跨域行为，则浏览器会进行真正的请求。否则，会报 405 错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;options-请求&quot;&gt;&lt;a href=&quot;#options-请求&quot; class=&quot;headerlink&quot; title=&quot;options 请求&quot;&gt;&lt;/a&gt;options 请求&lt;/h3&gt;&lt;p&gt;当我们的 ajax 的请求为非简单请求时，浏览器会进行预检，即发送 OPTI
      
    
    </summary>
    
      <category term="javascript" scheme="http://sosout.com/categories/javascript/"/>
    
    
      <category term="http" scheme="http://sosout.com/tags/http/"/>
    
  </entry>
  
</feed>
