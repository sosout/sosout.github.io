<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[有史以来最小的编译器源码解析]]></title>
    <url>%2F2018%2F09%2F14%2Fthe-super-tiny-compiler.html</url>
    <content type="text"><![CDATA[the-super-tiny-compiler详细中文注释 the-super-tiny-compiler 前言稍微接触一点前端，我们都知道现在前端“ES6即正义”，然而浏览器的支持还处于进行阶段，所以我们常常会用一个神奇的工具将 ES6 语法转换为目前支持比较广泛的 ES5 语法，这里我们所说的神奇的工具就是编译器。编译器功能非常纯粹，将字符串形式的输入语言编译成目标语言的代码字符串（以及sourcemap），常用的编译器除了我们熟知的 Babel 之外，还有 gcc。不过我们今天的主角是号称可能是有史以来最小的编译器the-super-tiny-compiler，去掉注释也就200多行代码，作者 James Kyle 更是 Babel 的活跃维护者之一。这个编译器的功能很简单，主要把 Lisp 风格的函数调用转换成 C 风格的，例如： Lisp 风格（转化前） C 风格（转化后） 2 + 2 (add 2 2) add(2, 2) 4 - 2 (subtract 4 2) subtract(4, 2) 2 + (4 - 2) (add 2 (subtract 4 2)) add(2, subtract(4, 2)) 编译器工作的三个阶段绝大多数编译器的编译过程都差不多，主要分为三个阶段：解析：将代码字符串解析成抽象语法树。转换：对抽象语法树进行转换操作。代码生成：根据转换后的抽象语法树生成目标代码字符串。 解析解析过程主要分为两部分：词法分析和语法分析。1、词法分析是由词法分析器把原始代码字符串转换成一系列词法单元（token），词法单元是一个数组，由一系列描述独立语法的对象组成，它们可以是数值、标签、标点符号、运算符、括号等。2、语法分析是由语法分析器将词法分析器生成的词法单元转化为能够描述语法结构（包括语法成分及其关系）的中间表示形式（Intermediate Representation）或抽象语法树（Abstract Syntax Tree），其中抽象语法树（简称AST）是个深层嵌套的对象。 我们简单看一下 the-super-tiny-compiler 的整个解析过程：1234567891011121314151617181920212223242526272829303132333435363738// 原始代码字符串(add 2 (subtract 4 2))// 词法分析转化后生成的词法单元[ &#123; type: 'paren', value: '(' &#125;, &#123; type: 'name', value: 'add' &#125;, &#123; type: 'number', value: '2' &#125;, &#123; type: 'paren', value: '(' &#125;, &#123; type: 'name', value: 'subtract' &#125;, &#123; type: 'number', value: '4' &#125;, &#123; type: 'number', value: '2' &#125;, &#123; type: 'paren', value: ')' &#125;, &#123; type: 'paren', value: ')' &#125;,]// 语法分析转化后生成的抽象语法树（AST）&#123; type: 'Program', body: [&#123; type: 'CallExpression', name: 'add', params: [&#123; type: 'NumberLiteral', value: '2', &#125;, &#123; type: 'CallExpression', name: 'subtract', params: [&#123; type: 'NumberLiteral', value: '4', &#125;, &#123; type: 'NumberLiteral', value: '2', &#125;] &#125;] &#125;]&#125; 转换转换过程主要任务是修改 AST，即遍历解析过程生成的 AST，同时进行一系列操作，比如增/删/改节点、增/删/改属性、创建新树等，我们简单看一下 the-super-tiny-compiler 的整个转换过程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 原始代码字符串(add 2 (subtract 4 2))// 解析过程生成的 AST&#123; type: 'Program', body: [&#123; type: 'CallExpression', name: 'add', params: [&#123; type: 'NumberLiteral', value: '2', &#125;, &#123; type: 'CallExpression', name: 'subtract', params: [&#123; type: 'NumberLiteral', value: '4', &#125;, &#123; type: 'NumberLiteral', value: '2', &#125;] &#125;] &#125;]&#125;// 转换过程生成的 AST&#123; type: 'Program', body: [&#123; type: 'ExpressionStatement', expression: &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: 'add' &#125;, arguments: [&#123; type: 'NumberLiteral', value: '2' &#125;, &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: 'subtract' &#125;, arguments: [&#123; type: 'NumberLiteral', value: '4' &#125;, &#123; type: 'NumberLiteral', value: '2' &#125;] &#125; &#125; &#125;]&#125; 代码生成根据转换过程生成的抽象语法树生成目标代码字符串。 源码实现接下来我们根据编译器工作的三个阶段逐一分析一下 the-super-tiny-compiler 源码实现。 词法分析词法分析器主要任务把原始代码字符串转换成一系列词法单元（token）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 词法分析器 参数：代码字符串inputfunction tokenizer(input) &#123; // 当前正在处理的字符索引 let current = 0; // 词法单元数组 let tokens = []; // 遍历字符串，获得词法单元数组 while (current &lt; input.length) &#123; let char = input[current]; // 匹配左括号 if (char === '(') &#123; // type 为 'paren'，value 为左圆括号的对象 tokens.push(&#123; type: 'paren', value: '(' &#125;); // current 自增 current++; // 结束本次循环，进入下一次循环 continue; &#125; // 匹配右括号 if (char === ')') &#123; tokens.push(&#123; type: 'paren', value: ')' &#125;); current++; continue; &#125; // \s：匹配任何空白字符，包括空格、制表符、换页符、换行符、垂直制表符等 let WHITESPACE = /\s/; // 跳过空白字符 if (WHITESPACE.test(char)) &#123; current++; continue; &#125; // [0-9]：匹配一个数字字符 let NUMBERS = /[0-9]/; // 匹配数值 if (NUMBERS.test(char)) &#123; let value = ''; // 匹配连续数字，作为数值 while (NUMBERS.test(char)) &#123; value += char; char = input[++current]; &#125; tokens.push(&#123; type: 'number', value &#125;); continue; &#125; // 匹配形如"abc"的字符串 if (char === '"') &#123; let value = ''; // 跳跃左双引号 char = input[++current]; // 获取两个双引号之间的所有字符 while (char !== '"') &#123; value += char; char = input[++current]; &#125; // 跳跃右双引号 char = input[++current]; tokens.push(&#123; type: 'string', value &#125;); continue; &#125; // [a-z]：匹配1个小写字符 i 模式中的字符将同时匹配大小写字母 let LETTERS = /[a-z]/i; // 匹配函数名，要求只含大小写字母 if (LETTERS.test(char)) &#123; let value = ''; // 获取连续字符 while (LETTERS.test(char)) &#123; value += char; char = input[++current]; &#125; tokens.push(&#123; type: 'name', value &#125;); continue; &#125; // 无法识别的字符，抛出错误提示 throw new TypeError('I dont know what this character is: ' + char); &#125; // 词法分析器的最后返回词法单元数组 return tokens;&#125; 通过遍历代码字符串，分拣出各个词素，然后构成由一系列描述独立语法的对象组成的数组的词法单元。 语法分析语法分析器主要任务是将词法分析器生成的词法单元转化为能够描述语法结构（包括语法成分及其关系）的中间表示形式（Intermediate Representation）或抽象语法树（Abstract Syntax Tree）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 语法分析器 参数：词法单元数组function parser(tokens) &#123; // 当前正在处理的 token 索引 let current = 0; // 递归遍历（因为函数调用允许嵌套），将 token 转成 AST 节点 function walk() &#123; // 获取当前 token let token = tokens[current]; // 数值 if (token.type === 'number') &#123; // current 自增 current++; // 生成一个 AST节点 'NumberLiteral'，用来表示数值字面量 return &#123; type: 'NumberLiteral', value: token.value, &#125;; &#125; // 字符串 if (token.type === 'string') &#123; current++; // 生成一个 AST节点 'StringLiteral'，用来表示字符串字面量 return &#123; type: 'StringLiteral', value: token.value, &#125;; &#125; // 函数 if (token.type === 'paren' &amp;&amp; token.value === '(') &#123; // 跳过左括号，获取下一个 token 作为函数名 token = tokens[++current]; let node = &#123; type: 'CallExpression', name: token.value, params: [] &#125;; // 再次自增 `current` 变量，获取参数 token token = tokens[++current]; // 右括号之前的所有token都属于参数 while ((token.type !== 'paren') || (token.type === 'paren' &amp;&amp; token.value !== ')')) &#123; node.params.push(walk()); token = tokens[current]; &#125; // 跳过右括号 current++; return node; &#125; // 无法识别的字符，抛出错误提示 throw new TypeError(token.type); &#125; // AST的根节点 let ast = &#123; type: 'Program', body: [], &#125;; // 填充ast.body while (current &lt; tokens.length) &#123; ast.body.push(walk()); &#125; // 最后返回ast return ast;&#125; 通过递归来将词法分析器生成的词法单元转化为能够描述语法结构的 ast。 遍历12345678910111213141516171819202122232425262728293031323334353637383940414243// 遍历器function traverser(ast, visitor) &#123; // 遍历 AST节点数组 对数组中的每一个元素调用 `traverseNode` 函数。 function traverseArray(array, parent) &#123; array.forEach(child =&gt; &#123; traverseNode(child, parent); &#125;); &#125; // 接受一个 `node` 和它的父节点 `parent` 作为参数 function traverseNode(node, parent) &#123; // 从 visitor 获取对应方法的对象 let methods = visitor[node.type]; // 通过 visitor 对应方法操作当前 node if (methods &amp;&amp; methods.enter) &#123; methods.enter(node, parent); &#125; switch (node.type) &#123; // 根节点 case 'Program': traverseArray(node.body, node); break; // 函数调用 case 'CallExpression': traverseArray(node.params, node); break; // 数值和字符串，不用处理 case 'NumberLiteral': case 'StringLiteral': break; // 无法识别的字符，抛出错误提示 default: throw new TypeError(node.type); &#125; if (methods &amp;&amp; methods.exit) &#123; methods.exit(node, parent); &#125; &#125; // 开始遍历 traverseNode(ast, null);&#125; 通过递归遍历 AST，在遍历过程中通过 visitor 对应方法操作当前 node，这里和切面差不多。 转换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 转化器，参数：ASTfunction transformer(ast) &#123; // 创建 `newAST`，它与之前的 AST 类似，Program：新AST的根节点 let newAst = &#123; type: 'Program', body: [], &#125;; // 通过 _context 维护新旧 AST，注意 _context 是一个引用，从旧的 AST 到新的 AST。 ast._context = newAst.body; // 通过遍历器遍历 参数：AST 和 visitor traverser(ast, &#123; // 数值，直接原样插入新AST NumberLiteral: &#123; enter(node, parent) &#123; parent._context.push(&#123; type: 'NumberLiteral', value: node.value, &#125;); &#125;, &#125;, // 字符串，直接原样插入新AST StringLiteral: &#123; enter(node, parent) &#123; parent._context.push(&#123; type: 'StringLiteral', value: node.value, &#125;); &#125;, &#125;, // 函数调用 CallExpression: &#123; enter(node, parent) &#123; // 创建不同的AST节点 let expression = &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: node.name, &#125;, arguments: [], &#125;; // 函数调用有子类，建立节点对应关系，供子节点使用 node._context = expression.arguments; // 顶层函数调用算是语句，包装成特殊的AST节点 if (parent.type !== 'CallExpression') &#123; expression = &#123; type: 'ExpressionStatement', expression: expression, &#125;; &#125; parent._context.push(expression); &#125;, &#125; &#125;); // 最后返回新 AST return newAst;&#125; 这里通过 _context 引用维护新旧 AST，简单方便，但会污染旧AST。 代码生成1234567891011121314151617181920212223242526272829303132333435363738394041// 代码生成器 参数：新 ASTfunction codeGenerator(node) &#123; switch (node.type) &#123; // 遍历 body 属性中的节点，且递归调用 codeGenerator，结果按行输出 case 'Program': return node.body.map(codeGenerator) .join('\n'); // 表达式，处理表达式内容，并用分号结尾 case 'ExpressionStatement': return ( codeGenerator(node.expression) + ';' ); // 函数调用，添加左右括号，参数用逗号隔开 case 'CallExpression': return ( codeGenerator(node.callee) + '(' + node.arguments.map(codeGenerator) .join(', ') + ')' ); // 标识符，数值，原样输出 case 'Identifier': return node.name; case 'NumberLiteral': return node.value; // 字符串，用双引号包起来再输出 case 'StringLiteral': return '"' + node.value + '"'; // 无法识别的字符，抛出错误提示 default: throw new TypeError(node.type); &#125;&#125; 根据转换后的新AST生成目标代码字符串。 编译器12345678function compiler(input) &#123; let tokens = tokenizer(input); let ast = parser(tokens); let newAst = transformer(ast); let output = codeGenerator(newAst); return output;&#125; 编译器整个工作流程：1、input =&gt; tokenizer =&gt; tokens2、tokens =&gt; parser =&gt; ast3、ast =&gt; transformer =&gt; newAst4、newAst =&gt; generator =&gt; output将上面流程串起来，就构成了简单的编译器。]]></content>
      <categories>
        <category>babel</category>
      </categories>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-thunk 源码全方位剖析]]></title>
    <url>%2F2018%2F09%2F09%2Fredux-thunk-source-analysis.html</url>
    <content type="text"><![CDATA[前言redux 的核心概念很简单：将需要修改的 state 都储存在 store 里，发起一个 action 用来描述发生了什么，用 reducers 描述 action 如何改变 state tree，创建 store 的时候需要传入 reducer，真正能改变 store 中数据的是 API store.dispatch。纯粹使用 redux 时，我们需要 dispatch 的是一个 action 对象。当我们使用 redux-thunk 后，我们 dispatch 的是一个 function，redux-thunk 中间件会自动调用这个 function，并且传递 dispatch 方法作为其第一个参数，于是我们就能在这个 function 内根据我们的请求状态：开始，请求中，请求成功／失败，dispatch 我们期望的任何 action 了，这也是为什么它能支持异步 dispatch action，自然的请求的逻辑就需要放到这里面调用了。换言之，redux-thunk 改写了 dispatch API，使其具备接受一个函数作为参数的能力，从而达到 middleware 的效果，即在 redux 的 dispatch action =&gt; reducer =&gt; store 这个流程中，在 action 被发起之后，到达 reducer 之前的扩展点，加入相关操作，比如发生请求、log信息等。一句话：redux-thunk 就是对 store.dispatch() 的增强。 示例以动态收藏功能为例:纯粹使用 redux：12345678// action.jsconst addFavor = (id) =&gt; (&#123; type: 'FAVOR', id:id&#125;)// componentfetchFavor(&#123;id: id&#125;).then(res =&gt; &#123; dispatch(addFavor(id)) &#125;) 可以看到，我们在请求以后的回调函数中 dispatch action 去同步 redux store 中的状态。 使用 redux-thunk：1234567891011121314151617181920212223242526// store.jsimport &#123;createStore, combineReducers, applyMiddleware&#125; from 'redux';import * as reducers from './reducers';import thunk from 'redux-thunk';var store = createStore( combineReducers(reducers), applyMiddleware(thunk));export default store;// action.jsconst addFavor = (id) =&gt; &#123; return function (dispatch, getState) &#123; reqFavor(&#123;id: id&#125;).then(res =&gt; &#123; dispatch(&#123; type: "FAVOR", id:id &#125;) &#125;) &#125;&#125;// componentdispatch(addFavor(id)) 改变以后，从功能层面上来说，两者并无差别，都可以满足业务场景需求。但除此之外我们可以发现:一：dispatch 接受的参数由一个 PlainObject 变为一个函数二：我们把请求的异步操作从 dispatch action 这个 redux 流程外塞到的流程里，这看起来将异步操作内聚到这个流程中，无论是从逻辑上理解（这很 middleware！）还是项目代码开发维护（区分异步与同步状态管理流程进行维护管理）上都是很大的改进三：如果项目中有多处需要实现收藏功能，我们可以节省很多冗余代码，不用到处在 dispatch 外层套上 reqLike(id).then。。。 直接将 thunk 中间件引入，作为 applyMiddleware 参数，然后传入 createStore 方法，就完成了 store.dispatch() 的功能增强，这样就可以进行一些异步的操作了。其中 applyMiddleware 是 Redux 的一个原生方法，将所有中间件组成一个数组，依次执行，中间件多了可以当做参数依次传进去。1234const store = createStore( reducers, applyMiddleware(thunk, logger)); 源码了解了 redux-thunk 的基本概念以及应用后，我们一起看看源码加深下理解，源码十分精巧。在了解 redux-thunk 源码之前，我们很有必要先看看 redux 源码中 applyMiddleware 的部分：1234567891011121314151617181920212223export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 我们将 thunk 作为参数传入之后，直接返回了一个函数，这个函数作为 enhancer 传入 redux 源码中的 createStore 函数中：1234567891011121314export default function createStore(reducer, preloadedState, enhancer) &#123; if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125;&#125; 在 redux 源码中的 createStore 函数中，enhancer 被执行，传入参数 createStore，又紧接着执行其返回的函数，传入 reducer 和 preloadedState。接下来，我们进入 applyMiddleware 和 thunk 的关键部分，上面 applyMiddleware 接受的最初的 (…middlewares) 参数其实就是 thunk，thunk 会被执行，并且传入参数 getState 和 dispatch：123456789//传入到 thunk 的参数const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action)&#125;//在 map 中执行 thunkchain = middlewares.map(middleware =&gt; middleware(middlewareAPI))//重新改写 dispatchdispatch = compose(...chain)(store.dispatch) 那么上面的chain是什么呢，我们现在就可以去看 redux-thunk 的源码了：1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; redux-thunk 中间件 export default 的就是 createThunkMiddleware() 过的 thunk，再看 createThunkMiddleware 这个函数，返回的是一个柯里化过的函数。我们将上述代码编译成ES5的代码看一看：123456789101112131415function createThunkMiddleware(extraArgument) &#123; return function(&#123; dispatch, getState &#125;) &#123; // 这里返回的函数就是chain return function(next) &#123; // 这里返回的函数就是改写的dispatch return function(action) &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;; &#125; &#125;&#125; 从源码我们可以看出，chain 就是以 next 作为形参的匿名函数，至于 compose 只是不断传递每个函数的返回值给下一个执行函数，然后依次去执行它所有传入的函数而已，它源码中的注释说的很清楚：For example, compose(f, g, h) is identical to doing (...args) =&gt; f(g(h(...args)))。我们这里的 chain 只是一个函数而已，所以很简单，就是执行 chain，并且传入 store.dispatch 作为 next 就行。 接下来，进入最后一步，改写了 dispatch，最终变为:1234567function (action) &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; // next为之前传入的store.dispatch,即改写前的dispatch return next(action);&#125;; 如果传入的参数是函数，则执行函数，否则还是跟之前一样 dispatch(PlainObject)。 总结redux-thunk 实现了相关异步流程内聚到 redux 的流程中，实现 middleware 的功能，也便于项目的开发与维护，避免冗余代码。而实现的方式便是改写 redux 中的 dispatch API，使其可以除 PlainObject 外，接受一个函数作为参数。]]></content>
      <categories>
        <category>redux</category>
      </categories>
      <tags>
        <tag>middleware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端加密JS库--CryptoJS 使用指南]]></title>
    <url>%2F2018%2F09%2F05%2Fcryptojs-tutorial.html</url>
    <content type="text"><![CDATA[有时候项目涉及到的敏感数据比较多，为了信息安全，我们常常需要对一些数据进行接口加密处理，如编码、将明文转化为暗文、加密比对、AES + BASE64 算法加密等。接下来我们就分别说一下 CryptoJS 常用的一些方法。 CryptoJS文档 Base64 编码为什么要编码？ 由于一些网络通讯协议的限制, 又或者是出于信息加密的目的, 我们就需要将原信息转换为base64编码,然后才能进行传输.例如，发送某些含有 ASCII 码表中0到31之间的控制字符的数据。 window.btoa 对字符串进行 base64编码（注意不能编码中文）;winodw.atob 对 base64字符串 进行解码（对于包含中文的 base64编码，不能正确解码）; 通常的方法是通过 window.btoa() 方法对源数据进行编码, 然后接收方使用 window.atob() 方法对其进行解码, 从而得到原数据。但是这种方法存在的问题是：window.btoa() 不支持中文, window.atob() 转换含有中文的 base64编码 的时候中文部分会变为乱码。另一个存在的问题是解码github的readme数据的时候也是乱码。经过查找相关资料发现了 Base64的编码与解码转的最优方案: 12345678910111213141516171819202122// 编码function utf8_to_b64(str) &#123; return window.btoa(unescape(encodeURIComponent(str)));&#125;// 解码function b64_to_utf8(str) &#123; return decodeURIComponent(escape(window.atob(str)));&#125;// Usage:utf8_to_b64('✓ à la mode'); // 4pyTIMOgIGxhIG1vZGU=b64_to_utf8('4pyTIMOgIGxhIG1vZGU='); // "✓ à la mode"utf8_to_b64('I \u2661 Unicode!'); // SSDimaEgVW5pY29kZSE=b64_to_utf8('SSDimaEgVW5pY29kZSE='); // "I ♡ Unicode!"utf8_to_b64('我爱中国'); // 5oiR54ix5Lit5Zu9b64_to_utf8('SSDimaEgVW5pY29kZSE='); // "我爱中国"utf8_to_b64(123456); // MTIzNDU2b64_to_utf8("MTIzNDU2"); // 123456 AES 加密安装 1$ npm install crypto-js aes加密: crypto.js1234567891011121314151617181920212223242526272829303132333435363738394041import CryptoJS from "crypto-js";const key = CryptoJS.enc.Utf8.parse("1234567890000000"); //16位const iv = CryptoJS.enc.Utf8.parse("1234567890000000");export default &#123; //aes加密 encrypt(word) &#123; let encrypted = ""; if (typeof word == "string") &#123; const srcs = CryptoJS.enc.Utf8.parse(word); encrypted = CryptoJS.AES.encrypt(srcs, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); &#125; else if (typeof word == "object") &#123; //对象格式的转成json字符串 const data = JSON.stringify(word); const srcs = CryptoJS.enc.Utf8.parse(data); encrypted = CryptoJS.AES.encrypt(srcs, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); &#125; return encrypted.ciphertext.toString(); &#125;, // aes解密 decrypt(word) &#123; const encryptedHexStr = CryptoJS.enc.Hex.parse(word); const srcs = CryptoJS.enc.Base64.stringify(encryptedHexStr); const decrypt = CryptoJS.AES.decrypt(srcs, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); const decryptedStr = decrypt.toString(CryptoJS.enc.Utf8); return decryptedStr.toString(); &#125;&#125;; 使用12345678910111213import Crypto from "@/utils/crypto";Crypto.encrypt("✓ à la mode"); // b915bf40c4795227488da86978f55fceCrypto.decrypt(userPwd); // "✓ à la mode"Crypto.encrypt("✓ à la mode"); // 6317313288b32bf1909f165ec530d60aCrypto.decrypt(userPwd); // "I ♡ Unicode!"Crypto.encrypt("我爱中国"); // 1898a34273855f55255437aa22f87504Crypto.decrypt(userPwd); // "我爱中国"Crypto.encrypt("123456"); // dd7a6c4edc68e683b700a7a2846a2bc6Crypto.decrypt(userPwd); // "123456" 前后端数据通信参数加密加密代码实现: 项目中需要将所有传到后台的参数分5个步骤处理： 第一步：排序 第二步：将排序好的参数进行MD5加密作为接口的签名 第三步：将排序好的参数和接口签名拼接上进行AES加密 第四部：将AES加密后的密文Base64加密 第五步：将最终的密文encodeURIComponent； 代码如下： 1234567891011121314151617function encryption(data) &#123; let strs=[]; for(let i in data)&#123; strs.push(i+'='+data[i]); &#125; strs.sort(); // 数组排序 strs=strs.join('&amp;'); // 数组变字符串 let endData=strs+'&amp;sign='+CryptoJS.MD5(strs+'ADfj3kcadc2349akvm1CPFFCD84f').toString(); // MD5加密 let key = CryptoJS.enc.Utf8.parse("0880076B18D7EE81"); // 加密秘钥 let iv = CryptoJS.enc.Utf8.parse("CB3EC842D7C69578"); // 矢量 let encryptResult = CryptoJS.AES.encrypt(endData,key, &#123; // AES加密 iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 // 后台用的是pad.Pkcs5,前台对应为Pkcs7 &#125;); return encodeURIComponent(CryptoJS.enc.Base64.stringify(encryptResult.ciphertext)); // Base64加密encode;&#125; 加密最终的密文拼接在接口地址后面，请求接口。后台返回的数据也是密文；解密方法如下： 1234567891011121314function decryption(data) &#123; let key = CryptoJS.enc.Utf8.parse("0880076B18D7EE81"); // 加密秘钥 let iv = CryptoJS.enc.Utf8.parse("CB3EC842D7C69578"); // 矢量 let baseResult=CryptoJS.enc.Base64.parse(data); // Base64解密 let ciphertext=CryptoJS.enc.Base64.stringify(baseResult); // Base64解密 let decryptResult = CryptoJS.AES.decrypt(ciphertext,key, &#123; // AES解密 iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); let resData=decryptResult.toString(CryptoJS.enc.Utf8).toString(); return JSON.parse(resData);&#125; 备注：因为后台返回的数据是json格式；所以做种return的时候使用JSON.parse();如果解密的目标为字符串，比如说需要解密的是一个加密的token值。那就要做相应的改动：123456789101112function decryption(data) &#123; let key = CryptoJS.enc.Utf8.parse("0880076B18D7EE81"); // 加密秘钥 let iv = CryptoJS.enc.Utf8.parse("CB3EC842D7C69578"); // 矢量 let baseResult=CryptoJS.enc.Base64.parse(data); // Base64解密 let ciphertext=CryptoJS.enc.Base64.stringify(baseResult); // Base64解密 let decryptResult = CryptoJS.AES.decrypt(ciphertext,key, &#123; // AES解密 iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); return CryptoJS.enc.Utf8.stringify(decryptResult);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>cryptojs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 背后的工具体系]]></title>
    <url>%2F2018%2F08%2F30%2Freact-source-tools.html</url>
    <content type="text"><![CDATA[北京时间2017年9月27日，Facebook 官方发布了 React v16.0。相较于之前的 v15.x 版本，v16 发生了很大的变化。 React v16.0 API 变化1.render 函数支持返回数组和字符串：我们终于不需要再将多个同级元素包裹在一个冗余的 DOM 元素中了，但每个同级元素还是需要唯一的 key 值以便 React 进行更新，而且在未来版本，React 可能还会提供一个特殊的 jsx 片段来支持无 key 值的 DOM 元素。 2.更好的异常处理：在之前版本的 React 中，某个组件在 Render 阶段的运行错误可能会 break 掉整个应用，而且抛出的异常信息含义也非常模糊，难以确定错误的发生位置。在 v16.0 中，如果某个组件在执行 render 或其他生命周期函数时出错，整个组件将被从根节点上移除掉，方便开发者快速定位异常组件。在定位到异常组件后，开发者可以为该组件添加 componentDidCatch 方法，并在这个方法中为组件定义一个备用视图用于渲染异常状态下的组件。当然，在这个新的生命周期函数中，开发者也可以获得更加有帮助的错误信息进行 debug。这被称作组件的错误边界，大家可以理解为组件层面的 try catch 声明。 3.新的组件类型 portals：ReactDOM.createPortal(child, container) 可以将子组件直接渲染到当前容器组件 DOM 结构之外的任意 DOM 节点中，这将使得开发对话框，浮层，提示信息等需要打破当前 DOM 结构的组件更为方便。 4.更好的服务端渲染：与之前 renderToString 方法不同，新版本提供的 renderToNodeStream 将返回 Readable，可以持续产生字节流（a stream of bytes）并在下一部分的 document 生成之前将之前已生成的部分 document 传回给客户端。通常来讲，新的服务端渲染将比老的快3倍以上。在 document 到达客户端之后，新版本的 react 也将不会再去将客户端的初次渲染结果与服务端的渲染结果进行比较，而是尽可能地去重用相同的 DOM 元素。 5.支持自定义 DOM 元素：新版本将不会再抛出不支持的 DOM 元素错误，而是将所有开发者自定义的 DOM 元素都传递到相应的 DOM 节点上。 6.更小的打包大小：总体体积减少 30% react is 5.3 kb (2.2 kb gzipped), 老版本 20.7 kb (6.9 kb gzipped)react-dom is 103.7 kb (32.6 kb gzipped), 老版本 141 kb (42.9 kb gzipped)react + react-dom is 109 kb (34.8 kb gzipped), 老版本 161.7 kb (49.8 kb gzipped) 7.MIT 许可：除了最新的 16.0 版本外，Facebook 还发布了使用 MIT 许可的 15.6.2 版本，以方便无法立刻升级的使用者。 8.新的核心架构 Fiber：React v16.0 使用了 Fiber 作为底层架构。正是得益于 Fiber，返回数组和字符串及错误边界等功能才变得可能。Fiber 相较于之前最大的不同是它支持异步渲染（async rendering），这意味着 React 可以在更细的粒度上控制组件的绘制过程，从最终的用户体验来讲，用户可以体验到更流畅交互及动画体验。而因为异步渲染涉及到 React 的方方面面甚至未来，在 16.0 版本中 React 还暂时没有启用，并将在未来几个月陆续推出。 其实，以上种种变化都离不开背后构建工具的变化。 React 构建工具1234567891011# 开发工具ES Module, Flow, ESLint, Prettier, Yarn workspace, HUBOT(GitHub Bot), [x]Haste, [x]CommonJS Module# 构建工具Rollup, Closure Compiler, Error Code System, React DevTools, [x]Gulp/Grunt+Browserify# 测试工具Jest, Prettier# 发布工具npm 以上前面带[x]的表示之前在用，React v16.0 已不再使用。简单说一下上面的工具都有什么作用？ 开发时，按照 ES Module 机制编写源码，用 flow 进行类型检查、ESLint 语法规则和代码风格的检查、Prettier 来统一代码风格，借助 Yarn workspace 处理模块依赖，HUBOT(GitHub Bot) 检查PR； 开发过程中，用 Jest 单元测试，Prettier 来统一代码风格 开发完成，用 Rollup + Closure Compiler 构建，利用 Error Code System 机制实现生产环境错误追踪，React DevTools 侧面辅助 bundle 检查； 最后通过 npm 发布新 package。 开发工具ES ModuleReact 16 之前的版本都用 CommonJS Module 定义，例如：123'use strict';module.exports = require('./lib/React'); React 16 为什么选择使用 ES Module，有以下几个原因： 1.编译期发现模块导入/导出问题：我们都知道使用 CommonJS Module 的 require 一个未定义的方法时，不调用我们是发现不了错误的。而 ES Module 由于静态的模块机制，import 与 export 必须按名匹配，否则编译构建就会出错。 2.更小的打包大小： 众所周知 module.exports 是对象级别导出，而ES Module 支持更细粒度的原子级导出，我们把这个特性叫做 tree-shaking，这个特性可以帮助你将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。 这里只是把源码切换到了 ES Module，单元测试用例并未切换，主要原因是 CommonJS Module 对 Jest 的一些特性（resetModules）更友好，即便切换到 ES Module，在需要模块状态隔离的场景，仍然要用 require，所以切换意义不是很大。 还有 Haste，则是 React 团队自定义的模块处理工具，用来解决长相对路径的问题，例如：123456// ref: react-15.5.4var ReactCurrentOwner = require('ReactCurrentOwner');var warning = require('warning');var canDefineProperty = require('canDefineProperty');var hasOwnProperty = Object.prototype.hasOwnProperty;var REACT_ELEMENT_TYPE = require('ReactElementSymbol'); Haste 模块机制下模块引用不需要给出明确的相对路径，而是通过项目级唯一的模块名来自动查找，例如：1234567// 声明/** * @providesModule ReactClass */// 引用var ReactClass = require('ReactClass'); 从表面上解决了长路径引用的问题（并没有解决项目结构深层嵌套的根本问题），使用非标准模块机制有几个典型的坏处： 1.与标准不和，接入标准生态中的工具时会面临适配问题 2.源码难读，不容易弄明白模块依赖关系 React 16 去掉了大部分自定义的模块机制（ReactNative 里还有一小部分），采用 Node 标准的相对路径引用，长路径的问题通过重构项目结构来彻底解决，采用扁平化目录结构（同 package 下最深2级引用，跨 package 的经 Yarn 处理以顶层绝对路径引用） Flow + ESLintFlow 是 facebook 出品的 JavaScript 静态类型检查工具，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。我们看一下 React 使用实例： 12345678910111213141516export type ReactElement = &#123; $$typeof: any, type: any, key: any, ref: any, props: any, _owner: any, // ReactInstance or ReactFiber // __DEV__ _store: &#123; validated: boolean, &#125;, _self: React$Element&lt;any&gt;, _shadowChildren: any, _source: Source,&#125;; 除了静态类型声明及检查外，Flow 最大的特点是对React组件及JSX的深度支持：123456789101112131415type Props = &#123; foo: number,&#125;;type State = &#123; bar: number,&#125;;class MyComponent extends React.Component&lt;Props, State&gt; &#123; state = &#123; bar: 42, &#125;; render() &#123; return this.props.foo + this.state.bar; &#125;&#125; 另外还有导出类型检查的 Flow “魔法”，用来校验 mock 模块的导出类型是否与源模块一致：12type Check&lt;_X, Y: _X, X: Y = _X&gt; = null;(null: Check&lt;FeatureFlagsShimType, FeatureFlagsType&gt;); Eslint 解决了代码格式检查的问题，同时，一些有用的提示能让我们发现 bug 和无用代码（如 no-unused-vars, no-extra-bind, no-implicit-globals），例如： 12345678rules: &#123; 'no-unused-expressions': ERROR, 'no-unused-vars': [ERROR, &#123;args: 'none'&#125;], // React &amp; JSX // Our transforms set this automatically 'react/jsx-boolean-value': [ERROR, 'always'], 'react/jsx-no-undef': ERROR,&#125; PrettierPrettier 可以制定想要的代码风格，然后通过脚本或编辑器插件来一键格式化/美化代码，我发现使用 Prettier 有很多益处： 1.代码格式化成统一风格 2.提交之前对有改动的部分进行格式化，也可以保存文件的时候自动统一风格。 3.配合持续集成，保证PR代码风格完全一致（否则build失败，并输出风格存在差异的部分） 4.对构建结果进行格式化，一方面提升dev bundle可读性，另外还有助于发现prod bundle中的冗余代码 5.开源代码开发者不需要去学习项目的代码风格。 Yarn workspaceYarn 的 workspace 特性用来解决 monorepo 的 package 依赖（作用类似于 lerna bootstrap），通过在 node_modules 下建立软链接“骗过”Node模块机制。 通过 package.json/workspaces 配置 Yarn workspaces： 1234567&#123; // ... "workspaces": [ "packages/*" ], // ...&#125; 注意：Yarn 的实际处理与 Lerna 类似，都通过软链接来实现，只是在包管理器这一层提供 monorepo package 支持更合理一些，具体原因见Workspaces in Yarn | Yarn Blog 1234import &#123;enableUserTimingAPI&#125; from 'shared/ReactFeatureFlags';import getComponentName from 'shared/getComponentName';import invariant from 'fbjs/lib/invariant';import warning from 'fbjs/lib/warning'; 另外，Yarn 与 Lerna 可以无缝结合，通过 useWorkspaces 选项把依赖处理部分交由 Yarn 来做，详细见Integrating with Lerna HUBOTHUBOT 是指 Github 机器人，通常用于： 1. 持续集成、PR 触发构建/检查2. 管理 Issue，关掉不活跃的讨论帖 主要围绕 PR 与 Issue 做一些自动化的事情，比如 React 团队计划（目前还没这么做）机器人回复 PR 对 bundle size 的影响，以此督促持续优化 bundle size。 目前每次构建把 bundle size 变化输出到文件，并交由 Git 追踪变化（提交上去），例如： 123456789101112131415161718&#123; "bundleSizes": [ &#123; "filename": "react.development.js", "bundleType": "UMD_DEV", "packageName": "react", "size": 59086, "gzip": 16296 &#125;, &#123; "filename": "react.production.min.js", "bundleType": "UMD_PROD", "packageName": "react", "size": 7217, "gzip": 3050 &#125;, // ...&#125; 缺点可想而知，这个json文件经常冲突，要么需要浪费精力 merge 冲突，要么就懒得提交这个自动生成的麻烦文件，导致版本滞后，所以计划通过 GitHub Bot 把这个麻烦抽离出去。 构建工具bundle形式React16 之前提供了两种 bundle 形式： 第一种：UMD 单文件，用作外部依赖。 第二种：CJS 散文件，用于支持自行构建 bundle（把 React 作为源码依赖）。 存在一些问题： 一：自行构建的版本不一致：不同的 build 环境/配置构建出的 bundle 都不一样。 二：bundle 性能有优化空间：用打包 App 的方式构建类库不太合适，性能上有提升余地 三：不利于实验性优化尝试：无法对散文件模块应用打包、压缩等优化手段 React 16 调整了 bundle 形式： 一：不再提供 CJS 散文件，从 npm 拿到的就是构建好的，统一优化过的 bundle。 二：提供 UMD 单文件与 CJS 单文件，分别用于 Web 环境与 Node 环境（SSR）。 以不可再分的类库姿态，把优化环节都收进来，摆脱 bundle 形式带来的限制。 Rollup之前的构建系统是基于 Gulp/Grunt+Browserify 手搓的一套工具，后来在扩展方面受限于工具，例如： Node 环境下性能不好：频繁的 process.env.NODE_ENV 访问拖慢了 SSR 性能，但又没办法从类库角度解决，因为 Uglify 依靠这个去除无用代码，所以 React SSR 性能最佳实践一般都有一条“重新打包 React，在构建时去掉 process.env.NODE_ENV”（当然，React 16 不需要再这样做了，原因见上面提到的bundle形式变化） 丢弃了过于复杂（overly-complicated）的自定义构建工具，改用更合适的 Rollup： It solves one problem well: how to combine multiple modules into a flat file with minimal junk code in between. 无论 Haste -&gt; ES Module 还是 Gulp/Grunt+Browserify -&gt; Rollup 的切换都是从非标准的定制化方案切换到标准的开放的方案，应该在“手搓”方面吸取教训，为什么业界规范的东西在我们的场景不适用，非要自己造吗？ mock module构建时可能面临动态依赖的场景：不同的 bundle 依赖功能相似但实现存在差异的 module，例如 ReactNative 的错误提醒机制是显示个红框，而 Web 环境就是输出到 Console。 一般解法有2种： 第一种：运行时动态依赖（注入）：把两份都放进bundle，运行时根据配置或环境选择。 第二种：构建时处理依赖：多构建几份，不同的bundle含有各自需要的依赖模块。 显然构建时处理更干净一些，即 mock module，开发中不用关心这种差异，构建时根据环境自动选择具体依赖，通过手写简单的 Rollup 插件来实现：动态依赖配置 + 构建时依赖替换。 Closure Compilergoogle/closure-compiler是个非常强大的 minifier，有3种优化模式（compilation_level）： 第一种：WHITESPACE_ONLY：去除注释，多余的标点符号和空白字符，逻辑功能上与源码完全等价。 第二种：SIMPLE_OPTIMIZATIONS：默认模式，在 WHITESPACE_ONLY 的基础上进一步缩短变量名（局部变量和函数形参），逻辑功能基本等价，特殊情况（如 eval(‘localVar’)按名访问局部变量和解析 fn.toString() ）除外 第三种：ADVANCED_OPTIMIZATIONS：在 SIMPLE_OPTIMIZATIONS 的基础上进行更强力的重命名（全局变量名，函数名和属性），去除无用代码（走不到的，用不着的），内联方法调用和常量（划算的话，把函数调用换成函数体内容，常量换成其值） 关于compilation_level的详细信息见Closure Compiler Compilation Levels ADVANCED 模式过于强大：12345678// 输入function hello(name) &#123; alert('Hello, ' + name);&#125;hello('New user');// 输出alert("Hello, New user"); 也可以在Closure Compiler Service在线试玩。 迁移切换有一定风险，因此 React 用的还是 SIMPLE 模式，但后续可能有计划开启 ADVANCED 模式，充分利用 Closure Compiler 优化 bundle size。 Error Code System In order to make debugging in production easier, we’re introducing an Error Code System in 15.2.0. We developed a gulp script that collects all of our invariant error messages and folds them to a JSON file, and at build-time Babel uses the JSON to rewrite our invariant calls in production to reference the corresponding error IDs. 简言之，在 prod bundle 中把详细的报错信息替换成对应错误码，生产环境捕获到运行时错误就把错误码与上下文信息抛出来，再丢给错误码转换服务还原出完整错误信息。这样既保证了 prod bundle 尽量干净，还保留了与开发环境一样的详细报错能力。 例如生产环境下的非法 React Element 报错： Minified React error #109; visit https://reactjs.org/docs/error-decoder.html?invariant=109&amp;args[]=Foo for the full message or use the non-minified dev environment for full errors and additional helpful warnings. 很有意思的技巧，确实在提升开发体验上花了不少心思。 envification所谓 envification 就是分环境 build，例如：123456// ref: react-16.2.0/build/packages/react/index.jsif (process.env.NODE_ENV === 'production') &#123; module.exports = require('./cjs/react.production.min.js');&#125; else &#123; module.exports = require('./cjs/react.development.js');&#125; 常用手段，构建时把 process.env.NODE_ENV 替换成目标环境对应的字符串常量，在后续构建过程中（打包工具/压缩工具）会把多余代码剔除掉。 除了 package 入口文件外，还在里面做了同样的判断作为双保险：123456// ref: react-16.2.0/build/packages/react/cjs/react.development.jsif (process.env.NODE_ENV !== "production") &#123; (function() &#123; module.exports = react; &#125;)();&#125; 此外，还担心开发者误用 dev bundle 上线，所以在 React DevTools 也加了一点提醒： This page is using the development build of React. DCE checkDCE(dead code eliminated) check 是指检查无用代码是否被正常去除。 考虑了一种特殊情况：process.env.NODE_ENV 如果是在运行时设置的话也不合理（可能存在另一环境的多余代码），所以还通过 React DevTools 做了 bundle 环境检查： 123456789101112131415161718192021222324252627282930313233// ref: react-16.2.0/packages/react-dom/npm/index.jsfunction checkDCE() &#123; if (process.env.NODE_ENV !== 'production') &#123; throw new Error('^_^'); &#125; try &#123; __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE); &#125; catch (err) &#123; console.error(err); &#125;&#125;if (process.env.NODE_ENV === 'production') &#123; checkDCE();&#125;// DevTools 即__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE声明checkDCE: function(fn) &#123; try &#123; var toString = Function.prototype.toString; var code = toString.call(fn); if (code.indexOf('^_^') &gt; -1) &#123; hasDetectedBadDCE = true; setTimeout(function() &#123; throw new Error( 'React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://fb.me/react-perf-use-the-production-build' ); &#125;); &#125; &#125; catch (err) &#123; &#125;&#125; 原理类似于 Redux 的 minified 检测，先声明一个含有 dev 环境判断的方法，在判断中包含一个标识字符串，然后运行时（通过 DevTools ）检查 fn.toString() 源码，如果含有该标识字符串就说明 DCE 失败（无用代码没在 build 过程中去除），异步 throw 出来。 关于 DCE check 的详细信息，可以参考Detecting Misconfigured Dead Code Elimination 测试工具JestJest 是由 Facebook 发布的开源的、基于Jasmine的 JavaScript 单元测试框架。 为什么选择Jest？ 第一点：Jest 可以利用其特有的快照测试功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。 第二点：安装配置简单，非常容易上手，几乎是零配置的，通过 npm 命令安装就可以直接运行了。 第三点：Jest 内置了测试覆盖率工具 istanbul，可以通过命令开启或者在 package.json 文件进行更详细的配置。运行 istanbul 除了会再终端展示测试覆盖率情况，还会在项目下生产一个 coverage 目录，内附一个测试覆盖率的报告，让我们可以清晰看到分支的代码的测试情况。 第四点：集成了断言库，不需要再引入第三方的断言库，并且非常完美的支持 React 组件化测试。 Snapshot Testing 与 UI 自动化测试的一般做法类似，对正确结果截屏作为基准（这个基准需要持续更新，所以快照文件一般随源码提交上去），后续每次改动后与之前的截图做像素级对比，存在差异则说明有问题。 另外，提到 React App 测试，还有一个更狠的：Enzyme，可以采用Jest + Enzyme对React组件进行深度测试，更多信息请查看Unit Testing React Components: Jest or Enzyme? 关于前端UI自动化测试的一般方法，可参考如何进行前端自动化测试？ – 张云龙的回答 – 知乎，当然也可以在repl.it – try-jest by @amasad在线试玩。 preventing Infinite Loops即死循环检查，Facebook 团队不希望测试过程被死循环阻塞（React 16 递归改循环之后有很多while (true)，他们不太放心）。处理方式与死递归检查类似：限制最大深度（TTL）。通过 Babel 插件来做，在测试环境构建时注入检查： 12345678910111213141516// ref: https://github.com/facebook/react/blob/master/scripts/jest/preprocessor.js#L38require.resolve('../babel/transform-prevent-infinite-loops'),// ref: https://github.com/facebook/react/blob/master/scripts/babel/transform-prevent-infinite-loops.js#L37'WhileStatement|ForStatement|DoWhileStatement': (path, file) =&gt; &#123; const guard = buildGuard(&#123; ITERATOR: iterator, MAX_ITERATIONS: t.numericLiteral(MAX_ITERATIONS), &#125;); if (!path.get('body').isBlockStatement()) &#123; const statement = path.get('body').node; path.get('body').replaceWith(t.blockStatement([guard, statement])); &#125; else &#123; path.get('body').unshiftContainer('body', guard); &#125;&#125; 用来防护的 buildGuard 如下： 12345678910const buildGuard = template(` if (ITERATOR++ &gt; MAX_ITERATIONS) &#123; global.infiniteLoopError = new RangeError( 'Potential infinite loop: exceeded ' + MAX_ITERATIONS + ' iterations.' ); throw global.infiniteLoopError; &#125;`); 注意这里使用了一个全局错误变量 global.infiniteLoopError，用来中断后续测试流程：12345678// ref: https://github.com/facebook/react/blob/master/scripts/jest/setupTests.js#L56 env.afterEach(() =&gt; &#123; const error = global.infiniteLoopError; global.infiniteLoopError = null; if (error) &#123; throw error; &#125;&#125;); 在每个 case 结束都看一眼是否发生死循环，防止 guard 中 throw 的错误被外层 catch 住后，测试流程仍然正常进行。 发布工具npm publish为了规范/简化发布流程，Facebook 团队做了以下几件事情： 1.采用 master + feature flag 的分支策略2.统一的工具化发布流程 之前采用 stable 分支策略，发版时需要手动cherry-pick，发个版要花很长时间。后来调整为直接从 master 发布，对于不想要的 breaking change，通过 feature flag 在构建时去掉，免去了手动 cherry-pick 的繁琐。 统一了工具发布流程，自动的按顺序自动执行，人工的就提示保存退出，人工处理完成后恢复之前的进度继续向下执行，大致经过以下流程： 1234567891011121314# 自动$ npm run test$ npm run build# 人工changelog # 更新日志smoke test # 冒烟测试# 自动$ git commit # 提交更新日志$ npm publish # 发布新包# 人工GitHub release # Github 发布update site version # 更新版本test new release # 测试新版notify involved team # 发布通知 这样通过工具化可以减少很多人为失误，保证统一的发布流程。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由 let 和 for 引起的血案]]></title>
    <url>%2F2018%2F08%2F16%2Flet-for-together-used.html</url>
    <content type="text"><![CDATA[这是一道出自 HTTP 203 的 JS 题目。HTTP 203 是 Youtube 上的一个栏目，主要讲一些有趣的知识。 原题目是这样的： 123456789for( let i = (setTimeout(()=&gt;console.log(i), 2333), 0); i &lt; 2; i++) &#123; &#125;// 问 2333 毫秒之后打印出什么 答案是 2333 毫秒后打印出 0。 为什么呢？ 在开始分析题目之前，我们先来回顾几个知识点： for 语法123for (语句 1; 语句 2; 语句 3) &#123; 被执行的代码块&#125; 语句 1（代码块）开始前执行；语句 2 定义运行循环（代码块）的条件；语句 3 在循环（代码块）已被执行之后执行； 执行的顺序为：1.第一次循环，即初始化循环。首先执行语句1（一般为初始化语句），再执行语句2（一般为条件判断语句），判断语句1是否符合语句2的条件，如果符合，则执行代码块，否则，停止执行，最后执行语句3。2.其他循环：首先判断前一次语句3的执行结果是否符合执行语句2的条件，如果符合，继续执行代码块，否则停止执行，最后执行语句3。如此往复，直到前一次语句3的执行结果不满足符合执行语句2的条件。 总的来说，执行顺序是一致的，先执行条件判断（语句2），再执行代码块，最后执行语句3。如此往复，区别在于条件判断的对象，在第一次判断时，是执行语句1，初始化的对象，后续的判断对象是执行语句3的结果。 逗号表达式逗号表达式，因为原题目中就有使用逗号表达式let i = (setTimeout(()=&gt;console.log(i), 2333), 0);。 逗号表达式的一般形式是：表达式1,表达式2,表达式3……表达式n。逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值。 看下面几个例子： 1234567x=8*2, x*4 // 整个表达式的值为64，x的值为16(x=8*2, x*4), x*2 // 整个表达式的值为32，x的值为16x=(z=5, 5*2) // 整个表达式为赋值表达式，它的值为10，z的值为5，x的值为10x=z=5, 5*2 // 整个表达式为逗号表达式，它的值为10，x和z的值都为5 逗号表达式用的地方不太多，一般情况是在给循环变量赋初值时才用得到。所以程序中并不是所有的逗号都要看成逗号运算符，尤其是在函数调用时，各个参数是用逗号隔开的，这时逗号就不是逗号运算符。 基础知识回顾完毕，我们通过几个简单示例一步一步地逼近原题目： 示例一：基础知识 for 循环12345for (var i = 0; i &lt; 2; i++) &#123; console.log(i);&#125;// 打印什么 这个无需多说，答案输出 0 1。 示例二：我们稍微改造下，将 log 放入 setTimeout 中12345for (var i = 0; i &lt; 2; i++) &#123; setTimeout(() =&gt; console.log(i));&#125;// 打印什么 答案输出 2 2。分析下：上述代码中，变量 i 是 var 命令声明的，在全局范围内都有效，所以全局只有一个变量 i。每一次循环，变量 i 的值都会发生改变，而循环内被赋给 setTimeout 内部的 console.log(i)，里面的 i 指向的就是全局的 i。也就是说，这里面所有的 i 指向的都是同一个 i，导致运行时输出的是最后一轮的 i 的值，也就是 2。 示例三：我再稍微改造下，将上述 var 改为 let。12345for (let i = 0; i &lt; 2; i++) &#123; setTimeout(() =&gt; console.log(i));&#125;// 打印什么 答案输出 0 1。分析下：上述代码中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是0 1。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 原题目123456789for( let i = (setTimeout(()=&gt;console.log(i), 2333), 0); // 语句1 i &lt; 2; // 语句2 i++ // 语句3) &#123; &#125;// 问 2333 毫秒之后打印出什么 答案是 2333 毫秒后打印出 0。分析下：上述题目中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，后面的表达式是逗号表达式，取最后一个值，即 i = 0，settimeout 在语句1，由于语句1只在第一次循环执行，因此 settimeout 的作用域是第一次迭代的作用域，且只执行一次。第一次迭代时 i = 0，所以答案是 2333 毫秒后打印出 0。]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 表达式后应不应该加分号？]]></title>
    <url>%2F2018%2F08%2F14%2Fjavascript-expression-semicolon.html</url>
    <content type="text"><![CDATA[我们在看源代码时，我们经常会发现有的源代码 Javascript 表达式后面加了分号，有的却没有加，难免心中产生疑惑：Javascript 表达式后面到底该不该加分号呢？ 其实 Javascript 表达式没有应不应该加分号明确规定，全凭个人习惯，也就是说你加也可以不加也不会出错。Javascript 语法长得有点像 C-like， 但不代表它本质上和 C 是一类语言，不过《JavaScript高级程序设计》一书提到：虽然语句结尾的分号不是必须的，但我们建议任何时候都不要省略它。因为加上这个分号可以避免很多错误（例如不完整的输入），开发人员也可以放心地通过删除多余的空格来压缩 ECMAScript 代码（代码行结尾处没有分号会导致压缩错误）。另外，加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必要再花时间推测应该在哪里插入分号。后来新设计的语言里可选分号的多得去了，光是 “可以加分号但是大家都不加” 的语言就有：Go, Scala, Ruby, Python, Swift, Groovy… 至于说“什么时候该加什么时候该不加”，其实真的很简单。真正会导致上下行解析出问题的 token 有 5 个：括号，方括号，正则开头的斜杠，加号，减号。实际代码中用正则、加号、减号作为行首的情况极少，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。其实即使是这两种情况，在实际代码中也颇为少见。 eslint –fix 已经支持自动添加删除分号，另外 prettier 1.0 现在也支持无分号选项，在不同 style 之间迁移的成本已经接近 0 了。 上面提到加上分号会在某些情况下会增进代码的性能。那么问题来了：加或不加分号是否影响JS执行性能？ 我们都清楚无论是解释执行还是编译执行，代码先要被 parse 成 AST（抽象语法树），在 AST 中是没有分号这个东西的，也就是说单纯执行本身，是不可能因为有无分号而造成性能差异的，所以唯一会有差异的是在 parsing 代码的阶段。而 parsing 本身是一次性的，因此通常不可能是性能问题的重点，何况 ASI（自动分号插入）只是整个 parsing 的很小一点。有人实际测试过相同代码在依赖 ASI 或不依赖 ASI 下的性能差异，据说较早版本的 V8 下，依赖 ASI（即不加分号）略慢，但较新版本则反之。也有人认为性能测试结果在统计上没有差异。无论如何，实测结果都表明即使有差异，也小到完全可忽略。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown表格中转义 " | "符号]]></title>
    <url>%2F2018%2F08%2F13%2Fmarkdown-table-transfer.html</url>
    <content type="text"><![CDATA[今天用 markdown 语法写文档时，用到了 table 标签。文档中有一项用到|符号，发现|无法使用反斜杠转义。google一番找到了一个方法：使用ASCII 字符集。举个简单的例子： 姓名 爱好 Weich1 篮球 &#124; 游泳 Weich2 足球 &#124; 音乐 Weich3 爬山 注：「篮球 &amp;#124; 游泳&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;足球 &amp;#124; 音乐」]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 源码全方位剖析]]></title>
    <url>%2F2018%2F08%2F12%2Fvue-source-analysis.html</url>
    <content type="text"><![CDATA[版本：v2.5.17-beta.0 前言随着这几年前端的快速发展，页面中需要实现的功能越来越复杂，DOM操作频繁，使用传统的jQuery库去频繁操作DOM时不仅消耗性能，而且各种DOM绑定后期维护时简直是一场噩梦，在开发大型项目时，模块间的依赖问题也变得十分复杂，在这个大背景下，以数据驱动和组件化思想开发的 Vue、React等JavaScript MVVM库应运而生。相比于其他库，Vue.js 提供了更加简洁、更易于理解的 API，使得我们能够快速上手，一经推出，便迅速走红。现在 Vue.js 更是火得一塌糊涂，github star 数更是超越 React。既然 Vue 如此火，我们是不是很有必要了解一下 Vue.js 背后的实现原理。 目前社区有很多 Vue.js 的源码剖析文章，当下质量比较好的有Vue技术内幕–逐行级别的 Vue 源码分析、Vue.js 技术揭秘，更是得到 Vue 作者本人的推荐。通过通读这两本电子书，我相信大家都能全方位了解 Vue.js 的实现原理。有人可能会有疑问，比如：既然人家写得这么好你为什么还写，直接看人家的不就好了吗，谁会看你的等等？我要说的是源码分析并不是为了彰显个人技术，更多的是为了学习，不管当下想法是否足够成熟，只要我们坚持，我们都会有收获。在开始之前我们先做以下几点约定： 第一：目前分析的版本是 Vue.js 的最新版本 Vue.js 2.5.17-beta.0；第二：Vue web应用是最常见的，也是最易于理解的，所以该源码均围绕 Vue web应用剖析；第三：我尽可能站在我自己的角度去剖析，当然我会借鉴社区比较优秀的文章，面对大家的拍砖，我无条件接受，也很乐意与大家一起交换意见，努力写好该 Vue 源码系列；第四：如果有幸您读到该 Vue 源码系列，感觉写得还行，还望收藏、分享或打赏。 前置知识我们从这一章开始即将分析 Vue 的源码，在分析源码之前我们很有必要介绍一些前置知识如flow、Rollup等。除此之外，我们最好已经用过 Vue 做过实际项目，对 Vue 的思想有了一定的了解，对绝大部分的 API 都已经有使用，同时，我们应该有一定的HTML、CSS、JavaScript、ES6+、node &amp; npm等功底，并对代码调试有一定的了解。 如果具备了以上条件，并且对 Vue 的实现原理很感兴趣，那么就可以开始 Vue 的底层学习了，对它的实现细节一探究竟。 Flow - JavaScript静态类型检查工具Flow 是 facebook 出品的 JavaScript 静态类型检查工具，它与 Typescript 不同的是，它可以部分引入，不需要完全重构整个项目，所以对于一个已有一定规模的项目来说，迁移成本更小，也更加可行。除此之外，Flow 可以提供实时增量的反馈，通过运行 Flow server 不需要在每次更改项目的时候完全从头运行类型检查，提高运行效率。可以简单总结为：对于新项目，可以考虑使用 TypeScript 或者 Flow，对于已有一定规模的项目则建议使用 Flow 进行较小成本的逐步迁移来引入类型检查。Vue 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。 为什么用静态类型检查工具 FlowJavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用就是很容易就写出非常隐蔽的隐患代码，在编译期甚至运行时看上去都不会报错，但是可能会发生各种各样奇怪的和难以解决的bug。 类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。 项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。Vue.js 在做2.0重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，最根本原因作者在知乎提及过，还是在于工程上成本和收益的考量。 大致体现在以下几点： 第一点：使用 Flow 可以一个一个文件地迁移，如果使用 TypeScript，则需要全部替换，成本极高，短期内并不现实；第二点：Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力；第三点：更贴近 ES 规范。除了 Flow 的类型声明之外，其他都是标准的 ES。万一哪天不想用 Flow 了，用babel-plugin-transform-flow-strip-types转一下，就得到符合规范的 ES；第四点：在需要的地方保留 ES 的灵活性，并且对于生成的代码尺寸有更好的控制力 (rollup / 自定义 babel 插件）。 如何用静态类型检查工具 Flow在这里我们就简单说一说 Flow 的用法，其他用法可以参考Flow官网（可能需要 VPN，非常不稳定），有时间我会详细写一篇 Flow 使用指南。 Flow 仅仅是一个用于检查的工具，安装使用都很方便，使用时注意以下3点即可： 1.将 Flow 安装到我们的项目中。2.确保编译之后的代码移除了 Flow 相关的语法。3.在需要检查的地方增加了 Flow 相关的类型注解。 第一点：将Flow增加到我们的项目中 安装最新版本的 Flow：1$ npm install --save-dev flow-bin 安装完成之后在 package.json 文件中增加执行脚本： 12345678&#123; // ... "scripts": &#123; "your-script-name": "flow", // ... &#125;, // ...&#125; 然后初始化 Flow： 1$ npm run flow init 执行完成后，Flow 会在终端输出以下内容： 12&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot; 然后在根目录下生成一个名为 .flowconfig 的文件，打开之后是这样的： 1234567891011[ignore][include][libs][lints][options][strict] 基本上，配置文件没有什么特殊需求是不用去配置的，Flow 默认涵盖了当前目录之后的所有文件。[include] 用于引入项目之外的文件。例如： 12345[include]../otherProject/a.js[libs] 它会将和当前项目平级的 otherProject/a.js 文件纳入进来。详细配置文件请看官网。 第二点：编译之后的代码移除 Flow 相关的语法 Flow 在 JavaScript 语法的基础上使用了一些注解（annotation）进行了扩展。因此浏览器无法正确的解读这些 Flow 相关的语法，我们必须在编译之后的代码中（最终发布的代码）将增加的 Flow 注解移除掉。具体方法需要看我们使用了什么样的编译工具。下面将说明一些 Vue 开发常用的编译工具： 方式一：Babel 如果使用 Babel 我们需要安装一个 Babel 对于 Flow 的 preset：1$ npm install --save-dev babel-preset-flow 然后，我们需要在项目根目录Babel 的配置文件 .babelrc中添加一个 Flow 相关的 preset： 123456&#123; "presets": [ "flow", //other config ]&#125; 方式二：flow-remove-types 如果我们既没有使用 Babel 作为语法糖编译器，那么可以使用 flow-remove-types 这个工具在发布之前移除 Flow 代码。 第三点：在需要检查的地方增加 Flow 相关的类型注解 如果我们了解 C++/C# 的元编程或者 Java 的 Annotation，那么理解 Flow 的 Annotation 就会非常轻松。大概就是在文件、方法、代码块之前增加一个注解（Annotation）用来告知 Flow 的执行行为。 首先，Flow 只检查包含// @flow注解的文件，所以如果需要检查，我们需要这样编写我们的文件，首先我们写一个正确的示例： 1234567/* @flow */function add(x: number, y: number): number &#123; return x + y&#125;add(22, 11) 运行 Flow 终端会打印出以下内容： 1234&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot;Found 0 errors 承接上面代码，我们把代码修改成带有检查错误的例子： 1234567/* @flow */function add(x: number, y: number): number &#123; return x + y&#125;add("Hello", 11) 运行 Flow 终端会打印出以下内容： 12345678910111213141516171819&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot;Error ------------------------------------------------------------------------------------- src/platforms/web/mnr.js:8:5Cannot call `add` with `&quot;Hello&quot;` bound to `x` because string [1] is incompatible with number [2]. src/platforms/web/mnr.js:8:5 8| add(&quot;Hello&quot;, 11) ^^^^^^^ [1]References: src/platforms/web/mnr.js:4:17 4| function add(x: number, y: number): number &#123; ^^^^^^ [2]Found 1 error 到这里，Flow 已经算是安装成功了，接下来的事是要增加各种注解以加强类型限定或者参数检测。之后的内容将简要介绍 flow 的类型检查方式。 Flow 的类型检查方式现在我们就说说 Flow 常用的2种类型检查方式：类型推断：通过变量的执行上下文来推断出变量类型，然后根据这些推断来检查类型。类型注释：事先注释好我们期望的类型，Flow 会基于这些注释来检查。 第一种方式：类型推断 此方式不需要编写任何代码即可进行类型检查，最小化开发者的工作量，它也不会强制我们改变开发习惯，因为它会自动推断出变量的类型，这就是所谓的类型推断，Flow 最重要的特性之一。 通过一个简单例子说明一下：1234567/*@flow*/function split(str) &#123; return str.split(' ')&#125;split(11) Flow 检查上述代码后会报错，因为函数 split 期待的参数是字符串，而我们输入的是数字。 第二种方式：类型注释 如上所述，类型推断是 Flow 最有用的特性之一，不需要编写任何代码就能进行类型检查。但在某些特定的场景下，使用类型注释可以提供更好更明确的检查依据。 看看以下代码：1234567/*@flow*/function add(x, y)&#123; return x + y&#125;add('Hello', 11) Flow 根据类型推断检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 add() 的参数必须为数字。在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以冒号 : 开头，可以在函数参数，返回值，变量声明中使用。如果我们在上段代码中使用类型注释，就会变成如下：1234567/*@flow*/function add(x: number, y: number): number &#123; return x + y&#125;add('Hello', 11) 现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。上面的例子是针对函数的类型注释。接下来我们来看看 Flow 能支持的一些常见的类型注释: 第一种：数组12345/*@flow*/var arr: Array&lt;number&gt; = [1, 2, 3]arr.push('Hello') 数组类型注释的格式是 Array，T 表示数组中每项的数据类型。在上述代码中，arr 是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow 能检查出错误。 第二种：类和对象 12345678910111213141516171819202122/*@flow*/class Bar &#123; x: string; // x 是字符串 y: string | number; // y 可以是字符串或者数字 z: boolean; constructor(x: string, y: string | number) &#123; this.x = x this.y = y this.z = false &#125;&#125;var bar: Bar = new Bar('hello', 4)var obj: &#123; a: string, b: number, c: Array&lt;string&gt;, d: Bar &#125; = &#123; a: 'hello', b: 11, c: ['hello', 'world'], d: new Bar('hello', 3)&#125; 类的类型注释格式如上，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。这里需要注意的是：属性 y 的类型中间用 | 做间隔，表示 y 的类型即可以是字符串也可以是数字。 对象的注释类型类似于类，需要指定对象属性的类型。 第三种：Null/undefined Flow 会检查所有的 JavaScript 基础类型—— Boolean、String、Number、null、undefined（在Flow中用void代替）。除此之外还提供了一些操作符号，例如 text : ?string，它表示参数存在“没有值”的情况，除了传递 string 类型之外，还可以是 null 或 undefined。需要特别注意的是，这里的没有值和 JavaScript 的表达式的“非”是两个概念，Flow 的“没有值”只有 null、void（undefined），而 JavaScript 表达式的“非”包含：null、undefined、0、false。 如果想任意类型 T 可以为 null 或者 undefined，只需写成如下 ?T 的格式即可： 123/*@flow*/var foo: ?string = null 此时，foo 可以为字符串，也可以为 null。 Flow 在 Vue.js 源码中的应用有时候我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。 在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。 这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下：12345678flow├── compiler.js # 编译相关├── component.js # 组件数据结构├── global-api.js # Global API 结构├── modules.js # 第三方库定义├── options.js # 选项相关├── ssr.js # 服务端渲染相关├── vnode.js # 虚拟 node 相关 可以看到，Vue.js 有很多自定义类型的定义，在阅读源码的时候，如果遇到某个类型并想了解它完整的数据结构的时候，可以回来翻阅这些数据结构的定义。 小结通过对 Flow 的认识，有助于我们阅读 Vue 的源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。此外，通过 Vue 重构，我们发现项目重构要么依赖规范，要么就得自己有绝对控制权，同时还要考量开发成本、项目收益以及整个团队的技术水平，并不是一味的什么火就用什么。 Rollup - 另一个前端模块化的打包工具Rollup 是前端模块化的一个打包工具，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。简单地说，它可以从一个入口文件开始，将所有使用的模块根据命令或者根据 Rollup 配置文件打包成一个目标文件，并且 Rollup 会自动过滤掉那些没有被使用过的函数或变量，从而使代码最小化，如果想使用直接导入这一个目标文件即可，因此 Rollup 极其适合构建一个工具库。 这里提到 Rollup 的两个特别重要的特性，第一个就是它使用了 ES2015 的模板标准，这意味着我们可以直接使用 import 和 export 而不需要引入 babel。另一个重要特性叫做 tree-shaking，这个特性可以帮助我们将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。举个简单的例子，我们在 foo.js 文件定义了 f1 和 f2 两个方法，然后在入口文件 index.js 只引入了 foo.js 文件中的 f1 方法，那么在最后打包 index.js 文件时，Rollup 就不会将 f2 方法打包到最终文件中（这个特性是基于 ES6 模块的静态分析的，也就是说，只有 export 而没有 import 的变量是不会被打包到最终代码中的）。 为什么用前端模块化的打包工具 Rollup之前 Vue 用 webpack 打包，还是会自带一个小型的动态 module 加载机制，并且每个文件是包在一个模块函数里的。Rollup 打包通过重命名 import binding 直接把所有文件的函数都放在同一个函数体里面… 所以最终出来的文件会小一些，并且初始化快个十几毫秒的样子。 如何用前端模块化的打包工具 Rollup关于如何使用前端模块化的打包工具 Rollup，这里就不做过多介绍了，可参考我之前写的一篇文章：Rollup使用指南，更详细的使用文档可参考：官网。 Webpack 和 Rollup 有什么不同Vue 从 1.0.10 开始就改用 Rollup 来打包。作者尤雨溪在知乎上也曾说过 使用 Rollup 只是用于 Vue 发布文件的构建，对用户使用没有直接影响。在这之前用 webpack 打包，还是会自带一个小型的动态 module 加载机制，并且每个文件是包在一个模块函数里的。Rollup 打包通过重命名 import binding 直接把所有文件的函数都放在同一个函数体里面… 所以最终出来的文件会小一些，并且初始化快个十几毫秒的样子。 Webpack 是目前使用最为火热的打包工具，没有之一，每月有数百万的下载量，为成千上万的网站和应用提供支持。相比之下，Rollup 并不起眼。但 Vue 并不孤单 – React，Ember，Preact，D3，Three.js，Moment 以及其他许多知名的库也使用 Rollup 。世界到底怎么了？为什么我们不能只有一个大众认可的 JavaScript 模块化打包工具？ Webpack 始于2012年，由 Tobias Koppers 发起，用于解决当时现有工具未解决的的一个难题：构建复杂的单页应用程序(SPA)。特别是 webpack 的两个特性改变了一切： 第一个特性：代码拆分(Code Splitting) 代码拆分也就是说我们可以将应用程序分解成可管理的代码块，可以按需加载，这意味着用户可以快速获取网站内容，而不必等到整个应用程序下载和解析完成。 第二个特性：各式各样的加载器（loader） 不管是图像，css，还是 html ，在 Webpack 看来一切都可作为模块，然后通过不同的加载器 loader 来加载它们。 ES6 发布之后，其中引入的模块机制使得静态分析成为了可能，于是 Rollup 发布了：其中 Rollup 有两个特别重要的特性，第一个就是它利用 ES2015 巧妙的模块设计，尽可能高效的构建出能够直接被其他 Javascript 库的。另一个重要特性叫做 tree-shaking，这个特性可以帮助我们将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。 紧接着 Webpack2 发布，仿照 Rollup 增加了 tree-shaking。 在之后， Webpack3 发布，仿照 Rollup 又增加了 Scope Hoisting。在在之后， Parcel 发布了一个快速、零配置的打包工具。于是，Webpack4 仿照 Parcel 发布了。 说了这么多，工作中我们到底该用哪个工具？ 对于应用使用 webpack，对于类库使用 Rollup。如果我们需要代码拆分(Code Splitting)，或者我们有很多静态资源需要处理，再或者我们构建的项目需要引入很多 CommonJS 模块的依赖，那么 webpack 是个很不错的选择。如果您的代码库是基于 ES2015 模块的，而且希望我们写的代码能够被其他人直接使用，我们需要的打包工具可能是 Rollup。 小结通过对 Rollup 的认识，有助于我们了解 Vue 的构建以及源码目录结构。 项目介绍上一章我们简单介绍了下 flow、Rollup 等前置知识，有兴趣的可以有针对性的学习它们。这一章我们真正的开始分析 Vue 源码，激动不激动？该章主要包括三小节：项目目录、源码构建、源码入口。 项目目录Vue.js 的源码都在 src 目录下，其详细目录结构如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344├── dist ---------------------------------------- 构建后的输出目录├── examples ------------------------------------ Vue 开发的应用案例├── flow ---------------------------------------- Flow 类型声明├── packages ------------------------------------ 独立发布包的目录├── scripts ------------------------------------- 构建相关的文件│ ├── git-hooks ------------------------------- git钩子的目录│ ├── alias.js -------------------------------- 别名配置文件│ ├── build.js -------------------------------- Rollup 构建文件│ ├── config.js ------------------------------- Rollup 构建配置的文件│ ├── gen-release-note.js --------------------- 生成发布通知│ ├── get-weex-version.js --------------------- 获取 weex 版本│ ├── release-weex.sh ------------------------- 自动发布新版本weex脚本│ ├── ci.sh ----------------------------------- 持续集成运行的脚本│ ├── release.sh ------------------------------ 自动发布新版本脚本├── src ----------------------------------------- 源码目录，我们主要剖析目录│ ├── compiler -------------------------------- 编译相关，主要将 template 编译为 render 函数 │ ├── core ------------------------------------ 核心代码，与平台无关的代码│ │ ├── components -------------------------- 抽象出来的通用组件│ │ ├── instance ---------------------------- Vue 构造函数设计相关的代码│ │ ├── global-api -------------------------- Vue 构造函数挂载全局方法(静态方法)或属性的代码│ │ ├── observer ---------------------------- 响应系统，包含数据观测的核心代码│ │ ├── vdom -------------------------------- 虚拟DOM创建(creation)和打补丁(patching)的代码├── ├── platforms ------------------------------- 平台特有的相关代码，不同平台的构建入口文件│ │ ├── web --------------------------------- web平台│ │ │ ├── entry-runtime.js ---------------- 不带编译器构建的入口│ │ │ ├── entry-runtime-with-compiler.js -- 自带编译器构建的入口│ │ │ ├── entry-compiler.js --------------- vue-template-compiler 包的入口文件│ │ │ ├── entry-server-renderer.js -------- vue-server-renderer 包的入口文件│ │ │ ├── entry-server-basic-renderer.js -- 输出 packages/vue-server-renderer/basic.js│ │ ├── weex -------------------------------- 混合应用├── ├── server ---------------------------------- 服务端渲染│ ├── sfc ------------------------------------- .vue 文件解析│ ├── shared ---------------------------------- 整个项目通用代码├── test ---------------------------------------- 测试文件├── .babelrc ------------------------------------ babel 配置文件├── .editorconfig ------------------------------- 编辑器语法规范配置├── .eslintignore ------------------------------- eslint 忽略配置├── .eslintrc ----------------------------------- eslint 配置文件├── .flowconfig --------------------------------- flow 的配置文件├── .gitignore ---------------------------------- git 忽略配置├── package-lock.json --------------------------- npm 加锁文件├── package.json -------------------------------- 项目管理文件├── README.md ----------------------------------- 项目文档├── yarn.lock ----------------------------------- yarn 加锁文件 上述目录很是熟悉，根目录下 src 存放源码，test 存放单元测试，examples 作为应用案例等等，后续 Vue 团队会不会也采用 monorepo 项目组织方式这个目前不好说，但有可能。接下来我们对重点剖析的源码目录做一个简要分析： compilercompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 Runtime Only 版本的还是 Runtime + Compiler 版本。下面我们来对比这两个版本： Runtime Only 版本：我们在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。 Runtime + Compiler 版本：我们如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板，如下所示：1234567891011// 需要编译器的版本new Vue(&#123; template: '&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;'&#125;)// 这种情况不需要new Vue(&#123; render (h) &#123; return h('div', this.hi) &#125;&#125;) 因为在 Vue.js 2.0 中，最终渲染都是通过 render 函数，如果写 template 属性，则需要编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。很显然，这个编译过程对性能会有一定损耗，所以通常我们更推荐使用 Runtime-Only 的 Vue.js。 corecore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。 platformplatform 目录是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和配合 weex 运行在 native 客户端上的 Vue.js。 serverserver 目录主要用于服务端渲染。这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。Vue.js 从 2.0 开始支持了服务端渲染，服务端渲染的主要工作是把组件渲染为服务器端的 HTML 字符串，然后将它们直接发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。 sfcsfc 目录主要用于把 .vue 文件内容解析成一个 JavaScript 对象，实际开发中我们一般用 webpack 完成该工作。 sharedshared 目录主要定义了一些共享的工具方法，这些工具方法不但适用于浏览器端的 Vue.js，同时也适用于服务端的 Vue.js。 小结从 Vue.js 的目录设计可以看到，作者把功能模块拆分的非常清楚，相关的逻辑放在一个独立的目录下维护，并且把复用的代码也抽成一个独立目录。 源码构建Vue 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。 构建命令通常一个基于 NPM 托管的项目都会有一个 package.json 文件，实际上它是对项目的描述文件，它的内容是一个标准的 JSON 对象。我们通常会配置 script 字段作为 NPM 的构建命令，Vue 源码构建的脚本如下：1234567891011121314151617181920212223242526272829303132&#123; // ... "main": "dist/vue.runtime.common.js", "module": "dist/vue.runtime.esm.js", "unpkg": "dist/vue.js", "jsdelivr": "dist/vue.js", "typings": "types/index.d.ts", "files": [ "src", "dist/*.js", "types/*.d.ts" ], "sideEffects": false, "scripts": &#123; // 构建完整版 umd 模块的 Vue "dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev", // 构建运行时 cjs 模块的 Vue "dev:cjs": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs", // 构建运行时 es 模块的 Vue "dev:esm": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-esm", // 构建 web-server-renderer 包 "dev:ssr": "rollup -w -c scripts/config.js --environment TARGET:web-server-renderer", // 构建 Compiler 包 "dev:compiler": "rollup -w -c scripts/config.js --environment TARGET:web-compiler ", // ... "build": "node scripts/build.js", "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer", "build:weex": "npm run build -- weex", // ... &#125;, // ...&#125; 这里总共有 3 条命令，作用都是构建 Vue，后面 2 条是在第一条命令的基础上，添加一些环境参数。当在命令行运行npm run build的时候，实际上会执行node scripts/build.js，接下来我们就来看看它实际上是如何构建的。 构建过程我们首先打开构建命令对应的构建 JS 脚本，在scripts/build.js中：12345678910111213141516171819// ...let builds = require('./config').getAllBuilds()// filter builds via command line argif (process.argv[2]) &#123; const filters = process.argv[2].split(',') builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf('weex') === -1 &#125;)&#125;build(builds)// ... 这段代码逻辑非常简单，先从配置文件读取配置，再通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。稍后我们再来看构建函数 build，我们先来看看配置文件，在scripts/config.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const builds = &#123; // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify 'web-runtime-cjs': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.common.js'), format: 'cjs', banner &#125;, // Runtime+compiler CommonJS build (CommonJS) 'web-full-cjs': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.common.js'), format: 'cjs', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // Runtime only (ES Modules). Used by bundlers that support ES Modules, // e.g. Rollup &amp; Webpack 2 'web-runtime-esm': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.esm.js'), format: 'es', banner &#125;, // Runtime+compiler CommonJS build (ES Modules) 'web-full-esm': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.esm.js'), format: 'es', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // runtime-only build (Browser) 'web-runtime-dev': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.js'), format: 'umd', env: 'development', banner &#125;, // runtime-only production build (Browser) 'web-runtime-prod': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.min.js'), format: 'umd', env: 'production', banner &#125;, // Runtime+compiler development build (Browser) 'web-full-dev': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.js'), format: 'umd', env: 'development', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // Runtime+compiler production build (Browser) 'web-full-prod': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.min.js'), format: 'umd', env: 'production', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // ...&#125; 这里简单列举了一些 Vue 构建的配置，其他已省略，可以看出实际上这是一个用于 Rollup 构建配置的对象。接下来我们再看一下构建函数 build，在scripts/build.js中：12345678910111213141516171819202122232425262728293031323334353637383940// ...build(builds)function build (builds) &#123; let built = 0 const total = builds.length const next = () =&gt; &#123; buildEntry(builds[built]).then(() =&gt; &#123; built++ if (built &lt; total) &#123; next() &#125; &#125;).catch(logError) &#125; next()&#125;function buildEntry (config) &#123; const output = config.output const &#123; file, banner &#125; = output const isProd = /min\.js$/.test(file) return rollup.rollup(config) .then(bundle =&gt; bundle.generate(output)) .then((&#123; code &#125;) =&gt; &#123; if (isProd) &#123; var minified = (banner ? banner + '\n' : '') + uglify.minify(code, &#123; output: &#123; ascii_only: true &#125;, compress: &#123; pure_funcs: ['makeMap'] &#125; &#125;).code return write(file, minified, true) &#125; else &#123; return write(file, code) &#125; &#125;)&#125; 上述关键的代码是return rollup.rollup(config)，可以看出这是通过 rollup 打包的，对于单个配置，它是遵循 Rollup 的构建规则的。其中 entry 属性表示构建的入口 JS 文件地址，dest 属性表示构建后的输出的 JS 文件地址，format 属性表示构建的格式，cjs 表示构建出来的文件遵循CommonJS 规范，es 表示构建出来的文件遵循ES Module 规范，umd 表示构建出来的文件遵循UMD 规范。 下面我们以配置文件的web-runtime-cjs配置为例： 构建的入口 JS 文件地址： 12345678910const builds = &#123; // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify 'web-runtime-cjs': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.common.js'), format: 'cjs', banner &#125;, // ...&#125; 沿着resolve函数我们来看一下它的定义，在scripts/config.js中： 123456789const aliases = require('./alias')const resolve = p =&gt; &#123; const base = p.split('/')[0] if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1)) &#125; else &#123; return path.resolve(__dirname, '../', p) &#125;&#125; 上述resolve函数实现非常简单：它把传入的参数p通过/分割成数组并取数组第一个元素赋值给base。在我们这个例子中，参数p的值是web/entry-runtime.js，那么base的值则为web。这里的base并不是实际的路径，它的实际路径是借助别名获取的，接下来我们来看一下别名配置的代码，在scripts/alias中：123456789101112131415const path = require('path')const resolve = p =&gt; path.resolve(__dirname, '../', p)module.exports = &#123; vue: resolve('src/platforms/web/entry-runtime-with-compiler'), compiler: resolve('src/compiler'), core: resolve('src/core'), shared: resolve('src/shared'), web: resolve('src/platforms/web'), weex: resolve('src/platforms/weex'), server: resolve('src/server'), entries: resolve('src/entries'), sfc: resolve('src/sfc')&#125; 很显然，这里web对应的真实的路径是path.resolve(__dirname, &#39;../&#39;, &#39;src/platforms/web&#39;)，这个路径就是src/platforms/web，然后resolve函数通过path.resolve(aliases[base], p.slice(base.length + 1))就得到了Vue源码的最终路径，它就是src/platforms/web/entry-runtime.js，因此，web-runtime-cjs配置对应的入口文件就是src/platforms/web/entry-runtime.js。 构建后的输出的 JS 文件地址： 12345678910111213141516171819202122232425262728293031323334353637const aliases = require('./alias')const resolve = p =&gt; &#123; const base = p.split('/')[0] if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1)) &#125; else &#123; return path.resolve(__dirname, '../', p) &#125;&#125;const builds = &#123; // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify 'web-runtime-cjs': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.common.js'), format: 'cjs', banner &#125;, // ...&#125;// alias.jsconst path = require('path')const resolve = p =&gt; path.resolve(__dirname, '../', p)module.exports = &#123; vue: resolve('src/platforms/web/entry-runtime-with-compiler'), compiler: resolve('src/compiler'), core: resolve('src/core'), shared: resolve('src/shared'), web: resolve('src/platforms/web'), weex: resolve('src/platforms/weex'), server: resolve('src/server'), entries: resolve('src/entries'), sfc: resolve('src/sfc')&#125; 由于别名配置里并没有dist别名配置，因此dest直接返回path.resolve(__dirname,&#39;../&#39;,dist/vue.runtime.common.js);，因此构建后的输出的 JS 文件地址是dist/vue.runtime.common.js。 小结通过这一节的分析，我们可以了解到 Vue.js 的打包过程，也知道了不同作用和功能的 Vue.js 它们对应的入口以及最终编译生成的 JS 文件。尽管在实际开发过程中我们会用Runtime Only版本开发比较多，但为了分析 Vue 的编译过程，我们重点分析的源码是Runtime + Compiler 的 Vue.js。 源码入口Vue 的定义我们在源码构建一节讲到，在web应用下，我们来分析Runtime + Compiler构建出来的 Vue.js，它的入口是src/platforms/web/entry-runtime-with-compiler.js： 12345678910111213141516171819202122232425262728293031/* @flow */import config from 'core/config'import &#123; warn, cached &#125; from 'core/util/index'import &#123; mark, measure &#125; from 'core/util/perf'import Vue from './runtime/index'import &#123; query &#125; from './util/index'import &#123; compileToFunctions &#125; from './compiler/index'import &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref &#125; from './util/compat'const idToTemplate = cached(id =&gt; &#123; const el = query(id) return el &amp;&amp; el.innerHTML&#125;)const mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; // ... return mount.call(this, el, hydrating)&#125;// ...Vue.compile = compileToFunctionsexport default Vue 由此可以看出，当我们在代码执行import Vue from &#39;vue&#39;时，就是从这个入口来初始化 Vue 的。在这个入口 JS 的上方我们可以找到 Vue 的来源：import Vue from &#39;./runtime/index&#39;，接下来我们来看一下这块儿的实现，在src/platforms/web/runtime/index.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* @flow */import Vue from 'core/index'import config from 'core/config'import &#123; extend, noop &#125; from 'shared/util'import &#123; mountComponent &#125; from 'core/instance/lifecycle'import &#123; devtools, inBrowser, isChrome &#125; from 'core/util/index'import &#123; query, mustUseProp, isReservedTag, isReservedAttr, getTagNamespace, isUnknownElement&#125; from 'web/util/index'import &#123; patch &#125; from './patch'import platformDirectives from './directives/index'import platformComponents from './components/index'// install platform specific utilsVue.config.mustUseProp = mustUsePropVue.config.isReservedTag = isReservedTagVue.config.isReservedAttr = isReservedAttrVue.config.getTagNamespace = getTagNamespaceVue.config.isUnknownElement = isUnknownElement// install platform runtime directives &amp; componentsextend(Vue.options.directives, platformDirectives)extend(Vue.options.components, platformComponents)// install platform patch functionVue.prototype.__patch__ = inBrowser ? patch : noop// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125;// ...export default Vue 在这个 JS 的上方我们可以找到 Vue 的来源：import Vue from &#39;core/index&#39;，剩下的都是对 Vue 这个对象的扩展，我们暂且不去分析，我们先来看一下关键代码实现的文件，在src/core/index.js中：1234567891011121314151617181920212223242526import Vue from './instance/index'import &#123; initGlobalAPI &#125; from './global-api/index'import &#123; isServerRendering &#125; from 'core/util/env'import &#123; FunctionalRenderContext &#125; from 'core/vdom/create-functional-component'initGlobalAPI(Vue)Object.defineProperty(Vue.prototype, '$isServer', &#123; get: isServerRendering&#125;)Object.defineProperty(Vue.prototype, '$ssrContext', &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, 'FunctionalRenderContext', &#123; value: FunctionalRenderContext&#125;)Vue.version = '__VERSION__'export default Vue 阿西吧，还没到！在这个 JS 的上方我们可以找到 Vue 的来源是import Vue from &#39;./instance/index&#39;，在src/core/instance/index.js中，不过这里有一点需要特别说明下：initGlobalAPI(Vue)用于初始化全局 Vue API（我们稍后介绍）： 1234567891011121314151617181920212223import &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 至此，我们终于看到了 Vue 的定义，可以看出它实际上就是一个用 Function 实现的类，我们只能通过 new Vue 去实例化它。接下来我们来分析一下上面遗留下来的问题。 initGlobalAPIVue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在src/core/global-api/index.js中： 12345678910111213141516171819202122232425262728293031323334353637383940414243export function initGlobalAPI (Vue: GlobalAPI) &#123; // config const configDef = &#123;&#125; configDef.get = () =&gt; config if (process.env.NODE_ENV !== 'production') &#123; configDef.set = () =&gt; &#123; warn( 'Do not replace the Vue.config object, set individual fields instead.' ) &#125; &#125; Object.defineProperty(Vue, 'config', configDef) // exposed util methods. // NOTE: these are not considered part of the public API - avoid relying on // them unless you are aware of the risk. Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125; Vue.set = set Vue.delete = del Vue.nextTick = nextTick Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + 's'] = Object.create(null) &#125;) // this is used to identify the "base" constructor to extend all plain-object // components with in Weex's multi-instance scenarios. Vue.options._base = Vue extend(Vue.options.components, builtInComponents) initUse(Vue) initMixin(Vue) initExtend(Vue) initAssetRegisters(Vue)&#125; 这里是对 Vue 扩展的一些全局方法，有一点要注意的是，Vue.util 暴露的方法最好不要依赖，因为它可能经常会发生变化且不稳定的。 小结那么至此，我们应该对 Vue 是什么有一个直观的认识，它本质上就是一个用 Function 实现的 Class，然后在它的原型 prototype 以及它本身都扩展了一系列的方法和属性，至于 Vue 能做什么，它是怎么做的，我们会在后面的章节一一剖析它们。 本文不断更新中]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码全方位剖析]]></title>
    <url>%2F2018%2F08%2F12%2Freact-source-analysis.html</url>
    <content type="text"><![CDATA[版本：v16.5.2 前言当时在各种前端框架或库充斥市场的情况下，出现了大量优秀的框架，比如 Backbone、Angular、Knockout、Ember 这些框架大都采用了 MV* 的理念，把数据与视图分离。而就在这样纷繁复杂的时期，React 诞生于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。所谓知其然还要知其所以然，加上 React 真是一天一改，如果现在不看，以后也真的很难看懂了。目前社区有很多 React 的源码剖析文章，趁着最近工作不忙，我打算分享一下 React 源码，并自形成一个系列，欢迎一起交流。在开始之前我们先做以下几点约定： 第一：目前分析的版本是 React 的最新版本 16.5.2；第二：React web应用是最常见的，也是最易于理解的，所以该源码均围绕 React web应用剖析；第三：我尽可能站在我自己的角度去剖析，当然我会借鉴社区比较优秀的文章，同时面对大家的拍砖，我无条件接受，也很乐意与大家一起交换意见，努力写好该 React 源码系列；第四：如果有幸您读到该 React 源码系列，感觉写得还行，还望收藏、分享或打赏。 前置知识我们从这一章开始即将分析 React 的源码，在分析源码之前我们很有必要介绍一些前置知识如flow、Rollup等。除此之外，我们最好已经用过 React 做过实际项目，对 React 的思想有了一定的了解，对绝大部分的 API 都已经有使用，同时，我们应该有一定的HTML、CSS、JavaScript、ES6+、node &amp; npm等功底，并对代码调试有一定的了解。 如果具备了以上条件，并且对 React 的实现原理很感兴趣，那么就可以开始 React 的底层学习了，对它的实现细节一探究竟。 Flow - JavaScript静态类型检查工具Flow 是 facebook 出品的 JavaScript 静态类型检查工具，它与 Typescript 不同的是，它可以部分引入，不需要完全重构整个项目，所以对于一个已有一定规模的项目来说，迁移成本更小，也更加可行。除此之外，Flow 可以提供实时增量的反馈，通过运行 Flow server 不需要在每次更改项目的时候完全从头运行类型检查，提高运行效率。可以简单总结为：对于新项目，可以考虑使用 TypeScript 或者 Flow，对于已有一定规模的项目则建议使用 Flow 进行较小成本的逐步迁移来引入类型检查。React 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。 为什么用静态类型检查工具 FlowJavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用就是很容易就写出非常隐蔽的隐患代码，在编译期甚至运行时看上去都不会报错，但是可能会发生各种各样奇怪的和难以解决的bug。 类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。 项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。React 源码在 ES2015 的基础上，除了用 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，最根本原因应该和 Vue 一样，还是在于工程上成本和收益的考量。 大致体现在以下几点： 第一点：使用 Flow 可以一个一个文件地迁移，如果使用 TypeScript，则需要全部替换，成本极高，短期内并不现实；第二点：Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力；第三点：更贴近 ES 规范。除了 Flow 的类型声明之外，其他都是标准的 ES。万一哪天不想用 Flow 了，用babel-plugin-transform-flow-strip-types转一下，就得到符合规范的 ES；第四点：在需要的地方保留 ES 的灵活性，并且对于生成的代码尺寸有更好的控制力 (rollup / 自定义 babel 插件）。 如何用静态类型检查工具 Flow在这里我们就简单说一说 Flow 的用法，其他用法可以参考Flow官网（可能需要 VPN，非常不稳定），有时间我会详细写一篇 Flow 使用指南。 Flow 仅仅是一个用于检查的工具，安装使用都很方便，使用时注意以下3点即可： 1.将 Flow 安装到我们的项目中。2.确保编译之后的代码移除了 Flow 相关的语法。3.在需要检查的地方增加了 Flow 相关的类型注解。 第一点：将Flow增加到我们的项目中 安装最新版本的 Flow：1$ npm install --save-dev flow-bin 安装完成之后在 package.json 文件中增加执行脚本： 12345678&#123; // ... "scripts": &#123; "your-script-name": "flow", // ... &#125;, // ...&#125; 然后初始化 Flow： 1$ npm run flow init 执行完成后，Flow 会在终端输出以下内容： 12&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot; 然后在根目录下生成一个名为 .flowconfig 的文件，打开之后是这样的： 1234567891011[ignore][include][libs][lints][options][strict] 基本上，配置文件没有什么特殊需求是不用去配置的，Flow 默认涵盖了当前目录之后的所有文件。[include] 用于引入项目之外的文件。例如： 12345[include]../otherProject/a.js[libs] 它会将和当前项目平级的 otherProject/a.js 文件纳入进来。详细配置文件请看官网。 第二点：编译之后的代码移除 Flow 相关的语法 Flow 在 JavaScript 语法的基础上使用了一些注解（annotation）进行了扩展。因此浏览器无法正确的解读这些 Flow 相关的语法，我们必须在编译之后的代码中（最终发布的代码）将增加的 Flow 注解移除掉。具体方法需要看我们使用了什么样的编译工具。下面将说明一些 React 开发常用的编译工具： 方式一：create-react-app 如果我们的项目是使用create-react-app直接创建的，那么移除 Flow 语法的事项就不用操心了，create-react-app 已经帮我们搞定了这个事。 方式二：Babel 如果使用 Babel 我们需要安装一个 Babel 对于 Flow 的 preset：1$ npm install --save-dev babel-preset-flow 然后，我们需要在项目根目录Babel 的配置文件 .babelrc中添加一个 Flow 相关的 preset： 123456&#123; "presets": [ "flow", //other config ]&#125; 方式三：flow-remove-types 如果我们既没有使用 create-react-app 也没使用 Babel 作为语法糖编译器，那么可以使用 flow-remove-types 这个工具在发布之前移除 Flow 代码。 第三点：在需要检查的地方增加 Flow 相关的类型注解 如果我们了解 C++/C# 的元编程或者 Java 的 Annotation，那么理解 Flow 的 Annotation 就会非常轻松。大概就是在文件、方法、代码块之前增加一个注解（Annotation）用来告知 Flow 的执行行为。 首先，Flow 只检查包含// @flow注解的文件，所以如果需要检查，我们需要这样编写我们的文件，首先我们写一个正确的示例： 1234567/* @flow */function add(x: number, y: number): number &#123; return x + y&#125;add(22, 11) 运行 Flow 终端会打印出以下内容： 1234&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot;Found 0 errors 承接上面代码，我们把代码修改成带有检查错误的例子： 1234567/* @flow */function add(x: number, y: number): number &#123; return x + y&#125;add("Hello", 11) 运行 Flow 终端会打印出以下内容： 12345678910111213141516171819&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot;Error ------------------------------------------------------------------------------------- src/platforms/web/mnr.js:8:5Cannot call `add` with `&quot;Hello&quot;` bound to `x` because string [1] is incompatible with number [2]. src/platforms/web/mnr.js:8:5 8| add(&quot;Hello&quot;, 11) ^^^^^^^ [1]References: src/platforms/web/mnr.js:4:17 4| function add(x: number, y: number): number &#123; ^^^^^^ [2]Found 1 error 到这里，Flow 已经算是安装成功了，接下来的事是要增加各种注解以加强类型限定或者参数检测。之后的内容将简要介绍 flow 的类型检查方式。 Flow 的类型检查方式现在我们就说说 Flow 常用的2种类型检查方式：类型推断：通过变量的执行上下文来推断出变量类型，然后根据这些推断来检查类型。类型注释：事先注释好我们期望的类型，Flow 会基于这些注释来检查。 第一种方式：类型推断 此方式不需要编写任何代码即可进行类型检查，最小化开发者的工作量，它也不会强制我们改变开发习惯，因为它会自动推断出变量的类型，这就是所谓的类型推断，Flow 最重要的特性之一。 通过一个简单例子说明一下：1234567/*@flow*/function split(str) &#123; return str.split(' ')&#125;split(11) Flow 检查上述代码后会报错，因为函数 split 期待的参数是字符串，而我们输入的是数字。 第二种方式：类型注释 如上所述，类型推断是 Flow 最有用的特性之一，不需要编写任何代码就能进行类型检查。但在某些特定的场景下，使用类型注释可以提供更好更明确的检查依据。 看看以下代码：1234567/*@flow*/function add(x, y)&#123; return x + y&#125;add('Hello', 11) Flow 根据类型推断检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 add() 的参数必须为数字。在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以冒号 : 开头，可以在函数参数，返回值，变量声明中使用。如果我们在上段代码中使用类型注释，就会变成如下：1234567/*@flow*/function add(x: number, y: number): number &#123; return x + y&#125;add('Hello', 11) 现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。上面的例子是针对函数的类型注释。接下来我们来看看 Flow 能支持的一些常见的类型注释: 第一种：数组12345/*@flow*/var arr: Array&lt;number&gt; = [1, 2, 3]arr.push('Hello') 数组类型注释的格式是 Array，T 表示数组中每项的数据类型。在上述代码中，arr 是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow 能检查出错误。 第二种：类和对象 12345678910111213141516171819202122/*@flow*/class Bar &#123; x: string; // x 是字符串 y: string | number; // y 可以是字符串或者数字 z: boolean; constructor(x: string, y: string | number) &#123; this.x = x this.y = y this.z = false &#125;&#125;var bar: Bar = new Bar('hello', 4)var obj: &#123; a: string, b: number, c: Array&lt;string&gt;, d: Bar &#125; = &#123; a: 'hello', b: 11, c: ['hello', 'world'], d: new Bar('hello', 3)&#125; 类的类型注释格式如上，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。这里需要注意的是：属性 y 的类型中间用 | 做间隔，表示 y 的类型即可以是字符串也可以是数字。 对象的注释类型类似于类，需要指定对象属性的类型。 第三种：Null/undefined Flow 会检查所有的 JavaScript 基础类型—— Boolean、String、Number、null、undefined（在Flow中用void代替）。除此之外还提供了一些操作符号，例如 text : ?string，它表示参数存在“没有值”的情况，除了传递 string 类型之外，还可以是 null 或 undefined。需要特别注意的是，这里的没有值和 JavaScript 的表达式的“非”是两个概念，Flow 的“没有值”只有 null、void（undefined），而 JavaScript 表达式的“非”包含：null、undefined、0、false。 如果想任意类型 T 可以为 null 或者 undefined，只需写成如下 ?T 的格式即可： 123/*@flow*/var foo: ?string = null 此时，foo 可以为字符串，也可以为 null。 Flow 在 React 源码中的应用Flow 是 Facebook 开源的静态代码检查工具，它的作用就是在运行代码之前对 React 组件以及 Jsx 语法进行静态代码的检查以发现一些可能存在的问题。在 React v16 Fiber中的部分 TypeScript 代码只是类型声明文件和测试代码，也就是为了方便利用 TypeScript 写应用的开发者使用 React，给了接口定义和测试样例而已。 小结React 重构告诉我们，项目重构要么依赖规范，要么就得自己有绝对控制权，同时还要考量开发成本、项目收益以及整个团队的技术水平，并不是一味的什么火就用什么。这一节主要对 Flow 的认识，有助于我们后续阅读 React 的源码，这种静态类型检查的方式非常有利于大型项目源码的开发和维护。 Rollup - 另一个前端模块化的打包工具Rollup 是前端模块化的一个打包工具，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。简单地说，它可以从一个入口文件开始，将所有使用的模块根据命令或者根据 Rollup 配置文件打包成一个目标文件，并且 Rollup 会自动过滤掉那些没有被使用过的函数或变量，从而使代码最小化，如果想使用直接导入这一个目标文件即可，因此 Rollup 极其适合构建一个工具库。 这里提到 Rollup 的两个特别重要的特性，第一个就是它使用了 ES2015 的模板标准，这意味着我们可以直接使用 import 和 export 而不需要引入 babel。另一个重要特性叫做 tree-shaking，这个特性可以帮助我们将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。举个简单的例子，我们在 foo.js 文件定义了 f1 和 f2 两个方法，然后在入口文件 index.js 只引入了 foo.js 文件中的 f1 方法，那么在最后打包 index.js 文件时，Rollup 就不会将 f2 方法打包到最终文件中（这个特性是基于 ES6 模块的静态分析的，也就是说，只有 export 而没有 import 的变量是不会被打包到最终代码中的）。 为什么用前端模块化的打包工具 Rollup之前的构建系统是基于 Gulp/Grunt+Browserify 手搓的一套工具，后来在扩展方面受限于工具，例如： Node 环境下性能不好：频繁的process.env.NODE_ENV访问拖慢了SSR 性能，但又没办法从类库角度解决，因为Uglify依靠这个去除无用代码，所以React SSR性能最佳实践一般都有一条“重新打包 React，在构建时去掉 process.env.NODE_ENV”. 丢弃了过于复杂（overly-complicated）的自定义构建工具，改用更合适的 Rollup： It solves one problem well: how to combine multiple modules into a flat file with minimal junk code in between. 无论 Haste -&gt; ES Module 还是 Gulp/Grunt+Browserify -&gt; Rollup 的切换都是从非标准的定制化方案切换到标准的开放的方案，应该在“手搓”方面吸取教训，为什么业界规范的东西在我们的场景不适用，非要自己造吗？ 如何用前端模块化的打包工具 Rollup关于如何使用前端模块化的打包工具 Rollup，这里就不做过多介绍了，可参考我之前写的一篇文章：Rollup使用指南，更详细的使用文档可参考：官网。 Webpack 和 Rollup 有什么不同2017年4月初，Facebook 将一个巨大的 pull 请求合并到了 React 主分支(master)中，将其现有的构建流程替换为基于 Rollup，这一举动促使一些人产生很大的疑惑“React 为什么选择 Rollup 而抛弃 webpack”，难道webpack要跌下神坛了？ Webpack 是目前使用最为火热的打包工具，没有之一，每月有数百万的下载量，为成千上万的网站和应用提供支持。相比之下，Rollup 并不起眼。但 React 并不孤单 – Vue，Ember，Preact，D3，Three.js，Moment 以及其他许多知名的库也使用 Rollup 。世界到底怎么了？为什么我们不能只有一个大众认可的 JavaScript 模块化打包工具？ Webpack 始于2012年，由 Tobias Koppers 发起，用于解决当时现有工具未解决的的一个难题：构建复杂的单页应用程序(SPA)。特别是 webpack 的两个特性改变了一切： 第一个特性：代码拆分(Code Splitting) 代码拆分也就是说我们可以将应用程序分解成可管理的代码块，可以按需加载，这意味着用户可以快速获取网站内容，而不必等到整个应用程序下载和解析完成。 第二个特性：各式各样的加载器（loader） 不管是图像，css，还是 html ，在 Webpack 看来一切都可作为模块，然后通过不同的加载器 loader 来加载它们。 ES6 发布之后，其中引入的模块机制使得静态分析成为了可能，于是 Rollup 发布了：其中 Rollup 有两个特别重要的特性，第一个就是它利用 ES2015 巧妙的模块设计，尽可能高效的构建出能够直接被其他 Javascript 库的。另一个重要特性叫做 tree-shaking，这个特性可以帮助我们将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。 紧接着 Webpack2 发布，仿照 Rollup 增加了 tree-shaking。 在之后， Webpack3 发布，仿照 Rollup 又增加了 Scope Hoisting。在在之后， Parcel 发布了一个快速、零配置的打包工具。于是，Webpack4 仿照 Parcel 发布了。 说了这么多，工作中我们到底该用哪个工具？ 对于应用使用 webpack，对于类库使用 Rollup。如果我们需要代码拆分(Code Splitting)，或者我们有很多静态资源需要处理，再或者我们构建的项目需要引入很多 CommonJS 模块的依赖，那么 webpack 是个很不错的选择。如果您的代码库是基于 ES2015 模块的，而且希望我们写的代码能够被其他人直接使用，我们需要的打包工具可能是 Rollup。 小结无论 Haste -&gt; ES Module 还是 Gulp/Grunt+Browserify -&gt; Rollup 的切换都是从非标准的定制化方案切换到标准的开放的方案，可以看出 React 团队也在积极拥抱标准方案并非一味造轮子。其实 Vue.js 1.0.10 就已经使用 Rollup 了，而 React v16.0 改用 Rollup 肯定也有借鉴之意，因此，好技术都是在借鉴的大背景下诞生的（Vue 就是一个典型的例子）。在这里通过对 Rollup 的认识，有助于我们了解 React 的构建以及源码目录结构。 项目介绍上一章我们简单介绍了下flow、Rollup等前置知识，有兴趣的可以有针对性的学习它们。这一章我们真正的开始分析 React 源码，激动不激动？该章主要包括三小节：项目目录、源码构建、源码入口。 项目目录目录结构我们主要剖析的 React 源码目录在 packages 下，在这里我们看看详细目录结构，混个眼熟： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748├── build --------------------------------------- 构建后的输出目录├── fixtures ------------------------------------ React 开发的测试用例├── packages ------------------------------------ 源码目录，我们主要剖析目录│ ├── create-subscription --------------------- 在组件里订阅额外数据的工具│ ├── events ---------------------------------- 事件处理 │ ├── interaction-tracking -------------------- 跟踪交互事件│ ├── react ----------------------------------- 核心代码│ ├── react-art ------------------------------- 矢量图形库│ ├── react-dom ------------------------------- DOM 渲染相关│ ├── react-is -------------------------------- React 元素类型相关│ ├── react-native-renderer ------------------- react-native 渲染相关 │ ├── react-noop-renderer --------------------- Fiber 测试相关 │ ├── react-reconciler ------------------------ React 调制器│ ├── react-scheduler ------------------------- 规划 React 初始化，更新等等│ ├── react-test-renderer --------------------- 实验性的 React 渲染器│ ├── shared ---------------------------------- 通用代码│ ├── simple-cache-provider ------------------- 为 React 应用提供缓存│ ├── server ---------------------------------- 服务端渲染│ ├── sfc ------------------------------------- .vue 文件解析│ ├── shared ---------------------------------- 整个项目通用代码├── scripts ------------------------------------- 公共的lint，build，test和release等相关的文件│ ├── eslint ---------------------------------- 语法规则和代码风格│ ├── flow ------------------------------------ Flow 类型声明│ ├── git ------------------------------------- git钩子的目录│ ├── jest ------------------------------------ JavaScript 测试目录│ ├── release --------------------------------- 自动发布新版本脚本│ ├── rollup ---------------------------------- rollup 构建目录├── .babelrc ------------------------------------ babel 配置文件├── .editorconfig ------------------------------- 编辑器语法规范配置├── .eslintignore ------------------------------- eslint 忽略配置 ├── .eslintrc ----------------------------------- eslint 配置文件├── .gitattributes ------------------------------ 给 attributes 路径名的简单文本文件├── .gitignore ---------------------------------- git 忽略配置├── .mailmap ------------------------------------ 邮件列表档案 ├── .nvmrc -------------------------------------- nvm 配置文件├── .prettierrc.js ------------------------------ prettierrc 配置文件├── .watchmanconfig ----------------------------- watchman 配置文件├── appveyor.yml -------------------------------- GitHub 托管项目的自动化集成├── AUTHORS ------------------------------------- 开发者列表档案├── CHANGELOG.md -------------------------------- 更新日志├── CODE_OF_CONDUCT.md -------------------------- Code of Conduct├── CONTRIBUTING.md ----------------------------- Contributing to React├── dangerfile.js ------------------------------- 提高 Code Review 体验├── netlify.toml -------------------------------- 持续集成静态网站├── package-lock.json --------------------------- npm 加锁文件├── package.json -------------------------------- 项目管理文件├── README.md ----------------------------------- 项目文档├── yarn.lock ----------------------------------- yarn 加锁文件 一眼望去，上面的目录结构是不是感觉很是奇怪？根目录下没有 src 之类的源码目录，也没有 test 这类的存放单元测试的目录，只有一个 packages 目录。这个 repository 其实是一个用 Lerna 管理的 monorepo。实际上，我们往npm上发布的几个package都来自于同一个codebase，包括react、react-dom、react-is…… monorepo通常，当我们的项目不断的迭代更新的时候，我们会根据业务或者是功能又或者是方便复用某些代码模块，把一个大的 codebase 拆成一些独立的 package 或 module，再将这些功能独立的 package 分别放入单独的 repository 中进行维护，此方式可以简单地称为multiple repositories。而 monorepo 则是一种相反的做法，它提倡将所有的相关 package 都放入一个 repository 来管理。 monorepo VS multirepo（集中管理 vs 多元化）首先这两者都是管理组织代码的方式，顾名思义 monorepo 就是把所有的相关项目都放在一个仓库中（比如 React, Angular, Babel, Google…），multirepo 则是按模块分为多个仓库。 multirepo：这种管理方式可以让每个子团队拥有自己的 repo，我们可以用自己擅长的工具、workflow 等等。多元化能促使各个团队尽可能的提升自己的效率。但代价也在于会增加很多沟通成本，如果我们项目用到的库中发现了一个 bug，就必须到目标库里修复它、打包、发版本，然后再回到我们的库继续工作。在不同的仓库间，我们不仅需要处理不同的代码、工具，甚至是不同的工作流程。甚至我们只能去问维护这个仓库的人，能不能为我们做出改变，然后等着他们去解决。 monorepo：这种管理方式可以让不同的团队走自己的路，并不见得能提高生产力。虽然有些团队可能会找到自己最佳的工作方式，但我们的收益也会被其他团队不那么好的工作方式所抵消。相反，严格统一的管理更能提升效率，团队中的任何人都可以（并且应该也被鼓励）修改任何东西（因为修改造成的结果马上就能展现出来，）。虽然把所有的鸡蛋都放进了一个篮子里，但我们也可以更小心的照顾这个篮子。 如果我们团队选择 monorepo，那主要的挑战自然是随着项目的发展，其会变得非常庞大（因为没有根据模块或功能拆分成不同 repo）。因此会需要很多的工具来应对这样的挑战。虽然我们可能认为这是一个很糟糕的做法，但是现在这样做的开源项目和公司并不算少。 谁在使用 monorepoBabel 是一个 Javascript 编译器，它可以将浏览器环境尚未支持的 Javascript 变为向下兼容的版本。因此，我们可以毫无顾虑地使用较新的 Javascript 语法和特性来提升编程的体验和效率。 其中 Babel 官方维护了众多独立的 plugin、polyfill、preset，但并未按照传统，将这些独立的模块分别放入不同的 repo。而是遵循了 monorepo 的方式，将它们放入一个相同的 repo 中。因为 Babel 认为，有效的组织一个多模块，多 repo 的项目，就像是尝试教一个刚出生的婴儿骑自行车一样。 Juggling a multimodule project over multiple repos is like trying to teach a newborn baby how to ride a bike. 所以，Babel 采用了 lerna 来管理自己的 monorepo。 无独有偶，Cycle.js（一个函数式和响应式 Javascript 框架）的作者 André Staltz 也摒弃了一个 package 一个 repo 的做法，将 Cycle.js 的众多 package 迁移到了一个 monorepo 中。他也认为，管理多个 repo 并不是件有意思的事情。多个 repo 意味着有多个地方需要处理 issue，保持多个 repo 的 issue 标签统一，管理很多 PR 和 git 钩子等等。 Managing multiple repos isn’t that fun. Multiple repos means multiple places to manage issues, manage issue labels (and making them consistent across repos), manage PRs, git hooks for conventions, etc. André Staltz 并没有使用 lerna 之类的工具来实现自己的 monorepo，他自己通过 Bash sh 实现了类似于 Lerna 管理的 monorepo。 除了 Babel 和 Cycle.js 以外，React、Angular、Meteor、Ember，还包括国内饿了么的 mint-ui 等等开源项目，以及一些公司如 Google、Facebook、BBC 等也都采用了 monorepo。它到底有什么优点，这么多公司，这么多库纷纷加入。 优点一：单个的 lint，build，test 和 release 流程；二：统一的地方处理issue；三：不用到处去找自己项目的repo；四：方便管理版本和dependencies；五：跨项目的操作和修改变得容易；六：方便生成总的changelog。 缺点一：repo 的体积变得很大；二：安全问题，如何管理权限。 关于 monorepo 我们暂且就说这么多，有时间我会单独写一篇 monorepo 文章。 小结从 React 的目录设计可以看出，React 团队在项目管理比较倾向 monorepo 方式，看来这种严格统一的管理方式真的提升效率。无论 monorepo 方式，还是 multirepo 方式都是为了团队效率，因此建议还是根据团队的情况选定一种方式，尽可能的扬长避短。 源码构建React v16.0 之前源码是基于Gulp/Grunt+Browserify构建的，而 React v16.0 是基于Rollup构建的，它的构建相关配置都在scripts/rollup目录下。 构建命令通常基于 NPM 托管的项目都会有一个 package.json 文件，实际上它是项目的描述文件，它的内容是一个标准的 JSON 对象。我们通常会配置 script 字段作为 NPM 的构建命令，React 源码构建配置如下： 123456789&#123; // ... "scripts": &#123; "build": "npm run version-check &amp;&amp; node ./scripts/rollup/build.js", // ... "version-check": "node ./scripts/tasks/version-check.js" &#125; // ...&#125; 这里build命令，实际上先执行version-check命令，然后执行node ./scripts/rollup/build.js进行打包，其中version-check命令实际上是执行node ./scripts/tasks/version-check.js，用于检查即将构建的bundle版本是否完全匹配，接下来我们就来看看它实际上是如何构建的。 构建过程我们首先打开build命令对应的第一个 JS 文件，在scripts/tasks/version-check.js中： 12345678910111213141516171819202122232425262728const reactVersion = require('../../package.json').version;const versions = &#123; 'packages/react/package.json': require('../../packages/react/package.json') .version, 'packages/react-dom/package.json': require('../../packages/react-dom/package.json') .version, 'packages/react-test-renderer/package.json': require('../../packages/react-test-renderer/package.json') .version, 'packages/shared/ReactVersion.js': require('../../packages/shared/ReactVersion'),&#125;;let allVersionsMatch = true;Object.keys(versions).forEach(function(name) &#123; const version = versions[name]; if (version !== reactVersion) &#123; allVersionsMatch = false; console.log( '%s version does not match package.json. Expected %s, saw %s.', name, reactVersion, version ); &#125;&#125;);if (!allVersionsMatch) &#123; process.exit(1);&#125; 这段代码逻辑非常简单，先获取即将发布的以及源码核心bundle的管理文件，再比对即将发布的和源码核心bundle的版本，如果不相同，给出对应的提示并结束构建，这样就保证了构建出来的 bundle 版本统一。 接下来我们打开build命令对应的第二个 JS 文件，在scripts/rollup/build.js中：12345678910111213141516async function buildEverything() &#123; await asyncRimRaf('build'); // Run them serially for better console output // and to avoid any potential race conditions. // eslint-disable-next-line no-for-of-loops/no-for-of-loops for (const bundle of Bundles.bundles) &#123; await createBundle(bundle, UMD_DEV); await createBundle(bundle, UMD_PROD); // ... &#125; // ... // ...&#125;buildEverything(); 这里通过调用buildEverything函数开启构建过程，asyncRimRaf用于删除上一次打包生成的包文件，然后循环包配置文件的配置构建出不同用途的 React 包，稍后我们再来看构建函数createBundle，我们先来看看包配置文件，在scripts/rollup/bundles.js中：123456789101112131415161718192021222324252627282930313233343536373839404142const bundles = [ /******* Isomorphic *******/ &#123; label: 'core', bundleTypes: [ UMD_DEV, UMD_PROD, NODE_DEV, NODE_PROD, FB_WWW_DEV, FB_WWW_PROD, ], moduleType: ISOMORPHIC, entry: 'react', global: 'React', externals: [], &#125;, /******* React DOM *******/ &#123; label: 'dom-client', bundleTypes: [ UMD_DEV, UMD_PROD, NODE_DEV, NODE_PROD, NODE_PROFILING, FB_WWW_DEV, FB_WWW_PROD, FB_WWW_PROFILING, ], moduleType: RENDERER, entry: 'react-dom', global: 'ReactDOM', externals: ['react'], &#125;, // ... // ...];module.exports = &#123; bundles,&#125;; 这里简单列举了一些 React 包构建的配置，其他已省略，可以看出实际上这是一个用于 Rollup 构建配置的对象数组，通过循环该对象数组构建出不同用途的 React 包。接下来我们再看一下构建函数createBundle，在scripts/rollup/build.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495async function createBundle(bundle, bundleType) &#123; if (shouldSkipBundle(bundle, bundleType)) &#123; return; &#125; const filename = getFilename(bundle.entry, bundle.global, bundleType); const logKey = chalk.white.bold(filename) + chalk.dim(` ($&#123;bundleType.toLowerCase()&#125;)`); const format = getFormat(bundleType); const packageName = Packaging.getPackageName(bundle.entry); let resolvedEntry = require.resolve(bundle.entry); if ( bundleType === FB_WWW_DEV || bundleType === FB_WWW_PROD || bundleType === FB_WWW_PROFILING ) &#123; const resolvedFBEntry = resolvedEntry.replace('.js', '.fb.js'); if (fs.existsSync(resolvedFBEntry)) &#123; resolvedEntry = resolvedFBEntry; &#125; &#125; const shouldBundleDependencies = bundleType === UMD_DEV || bundleType === UMD_PROD; const peerGlobals = Modules.getPeerGlobals(bundle.externals, bundleType); let externals = Object.keys(peerGlobals); if (!shouldBundleDependencies) &#123; const deps = Modules.getDependencies(bundleType, bundle.entry); externals = externals.concat(deps); &#125; const importSideEffects = Modules.getImportSideEffects(); const pureExternalModules = Object.keys(importSideEffects).filter( module =&gt; !importSideEffects[module] ); const rollupConfig = &#123; input: resolvedEntry, treeshake: &#123; pureExternalModules, &#125;, external(id) &#123; const containsThisModule = pkg =&gt; id === pkg || id.startsWith(pkg + '/'); const isProvidedByDependency = externals.some(containsThisModule); if (!shouldBundleDependencies &amp;&amp; isProvidedByDependency) &#123; return true; &#125; return !!peerGlobals[id]; &#125;, onwarn: handleRollupWarning, plugins: getPlugins( bundle.entry, externals, bundle.babel, filename, packageName, bundleType, bundle.global, bundle.moduleType, bundle.modulesToStub ), // We can't use getters in www. legacy: bundleType === FB_WWW_DEV || bundleType === FB_WWW_PROD || bundleType === FB_WWW_PROFILING, &#125;; const [mainOutputPath, ...otherOutputPaths] = Packaging.getBundleOutputPaths( bundleType, filename, packageName ); const rollupOutputOptions = getRollupOutputOptions( mainOutputPath, format, peerGlobals, bundle.global, bundleType ); console.log(`$&#123;chalk.bgYellow.black(' BUILDING ')&#125; $&#123;logKey&#125;`); try &#123; const result = await rollup(rollupConfig); await result.write(rollupOutputOptions); &#125; catch (error) &#123; console.log(`$&#123;chalk.bgRed.black(' OH NOES! ')&#125; $&#123;logKey&#125;\n`); handleRollupError(error); throw error; &#125; for (let i = 0; i &lt; otherOutputPaths.length; i++) &#123; await asyncCopyTo(mainOutputPath, otherOutputPaths[i]); &#125; console.log(`$&#123;chalk.bgGreen.black(' COMPLETE ')&#125; $&#123;logKey&#125;\n`);&#125; 上述关键的代码是const result = await rollup(rollupConfig);，可以看出这是通过 rollup 打包的，对于单个配置，它是遵循 Rollup 的构建规则的。其中 input 属性表示构建的入口 JS 文件地址，output.file 属性表示构建后的输出的 JS 文件地址，format 属性表示构建的格式，cjs 表示构建出来的文件遵循CommonJS 规范，es 表示构建出来的文件遵循ES Module 规范，umd 表示构建出来的文件遵循UMD 规范。 下面我们以配置文件的第一个react配置为例： 构建的入口 JS 文件地址： 1let resolvedEntry = require.resolve(bundle.entry); 沿着bundle.entry我们发现它的值为react（在scripts/rollup/bundles.js中），require.resolve用于查询文件的完整绝对路径，也就说react对应的真实入口路径是/**/**/react/packages/react/index.js，由此不难看出所有源码都在packages中： 构建后的输出的 JS 文件地址：12345const [mainOutputPath, ...otherOutputPaths] = Packaging.getBundleOutputPaths( bundleType, filename, packageName); 接下来我们看看Packaging.getBundleOutputPaths，在scripts/rollup/packaging.js中：1234567891011121314151617function getBundleOutputPaths(bundleType, filename, packageName) &#123; switch (bundleType) &#123; case NODE_DEV: case NODE_PROD: case NODE_PROFILING: return [`build/node_modules/$&#123;packageName&#125;/cjs/$&#123;filename&#125;`]; case UMD_DEV: case UMD_PROD: return [ `build/node_modules/$&#123;packageName&#125;/umd/$&#123;filename&#125;`, `build/dist/$&#123;filename&#125;`, ]; // ... default: throw new Error('Unknown bundle type.'); &#125;&#125; 从上面不难看出所有打包后的输出文件都在build，这就是为什么打包前先删除build文件了。 小结通过这一节的分析，我们可以了解到 React 的打包过程，也知道了不同作用和功能的 React 对应的入口以及最终编译生成的 JS 文件。 源码入口React 对象实际项目中，可以看到首先需要使用如下代码：1import React from 'react'; 这句代码做的就是引入了React核心源码模块。而我们在源码构建一节讲到 React 的核心入口文件是packages/react/index.js:1234567'use strict';const React = require('./src/React');// TODO: decide on the top-level export form.// This is hacky but makes it work with both Rollup and Jest.module.exports = React.default || React; 上述代码中执行import React from &#39;react&#39;时，其实引入的就是这里提供的对象。 这里需要说明一点：这里为什么会导出 React.default || React？（以下提到的插件都可以在源码中找到） React.default 用于 Jest 测试babel解析器将 es6 的 export、import等模块关键字转换成 commonjs 的规范，babel 转换 es6 的模块输出逻辑非常简单，即将所有输出都赋值给 exports。其中packages/react/src/React.js使用export default导出 React 对象，这里 babel 会将其转化exports.default = React，因此导入的结果其实是一个含 default 属性的对象，因此需要使用 React.default 来获取实际的 React 对象。 React 用于 Rolluprollup-plugin-node-resolve 插件可以解决 ES6 模块的查找导入，如果npm中的包以CommonJS模块的形式出现的，我们可以使用rollup-plugin-commonjs 将CommonJS模块转换为ES6来为Rollup获得兼容（即令(ES6)import === (CommonJS)require），导入的结果其实是不含 default 属性的对象，因此直接使用 React 来获取实际的 React 对象。 在这个入口 JS 的上方我们可以找到 React 的来源：const React = require(&#39;./src/React&#39;);，我们来看一下这块儿的实现，它定义在packages/react/src/React.js 中， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import ReactVersion from 'shared/ReactVersion';import &#123; REACT_ASYNC_MODE_TYPE, REACT_FRAGMENT_TYPE, REACT_PROFILER_TYPE, REACT_STRICT_MODE_TYPE, REACT_PLACEHOLDER_TYPE,&#125; from 'shared/ReactSymbols';import &#123;enableSuspense&#125; from 'shared/ReactFeatureFlags';import &#123;Component, PureComponent&#125; from './ReactBaseClasses';import &#123;createRef&#125; from './ReactCreateRef';import &#123;forEach, map, count, toArray, only&#125; from './ReactChildren';import &#123; createElement, createFactory, cloneElement, isValidElement,&#125; from './ReactElement';import &#123;createContext&#125; from './ReactContext';import &#123;lazy&#125; from './ReactLazy';import forwardRef from './forwardRef';import &#123; createElementWithValidation, createFactoryWithValidation, cloneElementWithValidation,&#125; from './ReactElementValidator';import ReactSharedInternals from './ReactSharedInternals';const React = &#123; Children: &#123; map, forEach, count, toArray, only, &#125;, createRef, Component, PureComponent, createContext, forwardRef, Fragment: REACT_FRAGMENT_TYPE, StrictMode: REACT_STRICT_MODE_TYPE, unstable_AsyncMode: REACT_ASYNC_MODE_TYPE, unstable_Profiler: REACT_PROFILER_TYPE, createElement: __DEV__ ? createElementWithValidation : createElement, cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement, createFactory: __DEV__ ? createFactoryWithValidation : createFactory, isValidElement: isValidElement, version: ReactVersion, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,&#125;;if (enableSuspense) &#123; React.Placeholder = REACT_PLACEHOLDER_TYPE; React.lazy = lazy;&#125;export default React; 上述就是我们 React 的庐山真面目，实际上它的内容是一个标准的 JSON 对象，这里 React 对象里面包含什么一目了然，比如我们常用的Component、PureComponent等，由此可以看出React核心内容只包括定义组件相关的内容和API。 渲染React 的定位是一个构建用户界面的JavaScript类库，它使用JavaScript语言开发UI组件，可以使用多种方式渲染这些组件，输出用户界面，很大程度上达到了跨平台的能力： We don’t make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code. 现在的 React 在以下几个方面都发挥着很不错的效果： React Web应用用户界面开发； React Native App用户界面开发； Node.js 服务端渲染； 在这些不同场景，渲染的主体很明显是不一样的，有诸如web应用的DOM渲染，React Native的原生View渲染，服务端字符串渲染等，要做到兼容适应多种不同渲染环境，很显然，React不能局限固定渲染UI的方式。 上一节我们讲到React核心内容只涉及如何定义组件，并不涉及具体的组件渲染（即输出用户界面），这需要引入额外渲染模块，下面以渲染React定义的组件为例： React DOM渲染模块：React DOM渲染模块：将React组件渲染为DOM，然后可以被浏览器处理呈现给用户，这就是通常在web应用中引入的react-dom模块：12345import React from 'react';import ReactDOM from 'react-dom';import App from './App';ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 上述代码中，App是使用React核心模块定义的组件，然后使用react-dom渲染模块提供的render方法将其渲染为DOM输出至页面。 React Native 渲染：：将React组件渲染为移动端原生View，在React Native应用中引入react-native模块，它提供相应渲染方法可以渲染React组件：1234import &#123; AppRegistry &#125; from 'react-native';import App from './src/app.js';AppRegistry.registerComponent('fuc', () =&gt; App); 上述代码中，App是React根组件，使用react-native渲染器的AppRegistry.registerComponent方法将其渲染为原生View。 React测试渲染：将React组件渲染为JSON树，用来完成Jest的快照测试，内容在react-test-renderer模块：12345678import ReactTestRenderer from 'react-test-renderer'; const renderer = ReactTestRenderer.create( &lt;Link page="https://www.facebook.com/"&gt;Facebook&lt;/Link&gt;); console.log(renderer.toJSON()); // &#123; type: 'a',// props: &#123; href: 'https://www.facebook.com/' &#125;,// children: [ 'Facebook' ] &#125; 小结那么至此，我们应该对 React 是什么有一个直观的认识，它本质上是含有诸多属性的JavaScript对象，它核心内容只涉及如何定义组件，具体的组件渲染（即输出用户界面），需要引入额外的渲染模块，渲染组件方式由环境决定，定义组件，组件状态管理，生命周期方法管理，组件更新等应该跨平台一致处理，不受渲染环境影响，这部分内容统一由调和器（Reconciler）处理，不同渲染器都会使用该模块。调和器主要作用就是在组件状态变更时，调用组件树各组件的render方法，渲染，卸载组件。至于 React 能做什么，它是怎么做的，我们会在后面的章节一一剖析它们。 主要概念首次渲染渲染入口在 Web 项目中，如果我们要将应用渲染至页面，通常会用如下代码： 12345import React from 'react';import ReactDOM from 'react-dom';import App from './App'; // 应用根组件ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); // 应用挂载容器DOM 这里react-dom是浏览器端渲染React应用的模块，通过ReactDOM.render(component, mountNode)可以对自定义组件/原生DOM/字符串进行挂载。在React16中，虽然还是通过JSX编译得到一个虚拟DOM对象，但对这些虚拟DOM对象的再加工则是发生了翻天覆地的变化。我们需要追根溯底，看它是怎么一步步转换的。我们首先找到ReactDOM.render，源码在packages/react-dom/src/client/ReactDOM.js中，有三个类似的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const ReactDOM: Object = &#123; // 新API，未来代替render hydrate(element: React$Node, container: DOMContainer, callback: ?Function) &#123; // TODO: throw or warn if we couldn't hydrate? return legacyRenderSubtreeIntoContainer( null, element, container, true, callback, ); &#125;, // React15的重要API，逐渐退出舞台 render( element: React$Element&lt;any&gt;, // react组件对象，通常是项目根组件 container: DOMContainer, // id为root的那个dom callback: ?Function, // 回调函数 ) &#123; return legacyRenderSubtreeIntoContainer( null, element, container, false, callback, ); &#125;, // 将组件挂载到传入的 DOM 节点上（不稳定api） unstable_renderSubtreeIntoContainer( parentComponent: React$Component&lt;any, any&gt;, element: React$Element&lt;any&gt;, containerNode: DOMContainer, callback: ?Function, ) &#123; invariant( parentComponent != null &amp;&amp; ReactInstanceMap.has(parentComponent), 'parentComponent must be a valid React Component', ); return legacyRenderSubtreeIntoContainer( parentComponent, element, containerNode, false, callback, ); &#125;,&#125;; 这里ReactDOM.render/hydrate/unstable_renderSubtreeIntoContainer/unmountComponentAtNode都是legacyRenderSubtreeIntoContainer方法的加壳方法。因此ReactDOM.render实际调用了legacyRenderSubtreeIntoContainer，这是一个内部API。 渲染虚拟dom树legacyRenderSubtreeIntoContainer从字面可以看出它大致意思就是把虚拟的dom树渲染到真实的dom容器中，我们找到legacyRenderSubtreeIntoContainer方法，源码在packages/react-dom/src/client/ReactDOM.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 渲染组件的子组件树至父容器function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component&lt;any, any&gt;, // 父组件 这里为 null children: ReactNodeList, // element 虚拟dom树 container: DOMContainer, // html中的dom根对象 forceHydrate: boolean, // 服务器端渲染标识 这里为false callback: ?Function, // 回调函数 这里没有) &#123; // 对 container 进行校验 invariant( isValidContainer(container), 'Target container is not a DOM element.', ); if (__DEV__) &#123; // 开发模式render时进行检查并提供许多有用的警告和错误提示信息 topLevelUpdateWarnings(container); &#125; // 获取 root 对象 let root: Root = (container._reactRootContainer: any); if (!root) &#123; // 初次渲染时初始化 // 创建一个 FiberRoot对象 并将它缓存到DOM容器的_reactRootContainer属性 root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 forceHydrate, // 服务器端渲染标识 这里为false ); if (typeof callback === 'function') &#123; const originalCallback = callback; callback = function() &#123; const instance = DOMRenderer.getPublicRootInstance(root._internalRoot); originalCallback.call(instance); &#125;; &#125; // 初始化容器相关 // Initial mount should not be batched. DOMRenderer.unbatchedUpdates(() =&gt; &#123; if (parentComponent != null) &#123; // 向真实dom中挂载虚拟dom root.legacy_renderSubtreeIntoContainer( parentComponent, // 父组件 children, // 虚拟dom树 callback, // 回调函数 ); &#125; else &#123; root.render( children, // 虚拟dom树 callback // 回调函数 ); &#125; &#125;); &#125; else &#123; if (typeof callback === 'function') &#123; const originalCallback = callback; callback = function() &#123; const instance = DOMRenderer.getPublicRootInstance(root._internalRoot); originalCallback.call(instance); &#125;; &#125; if (parentComponent != null) &#123; root.legacy_renderSubtreeIntoContainer( parentComponent, // 父组件 children, // 虚拟dom树 callback, // 回调函数 ); &#125; else &#123; root.render( children, // 虚拟dom树 callback // 回调函数 ); &#125; &#125; // 返回根容器fiber树的根fiber实例 return DOMRenderer.getPublicRootInstance(root._internalRoot);&#125;// 源码在 packages/react-reconciler/src/ReactFiberReconciler.js 中export function getPublicRootInstance( container: OpaqueRoot,): React$Component&lt;any, any&gt; | PublicInstance | null &#123; // 获取fiber实例 const containerFiber = container.current; if (!containerFiber.child) &#123; return null; &#125; switch (containerFiber.child.tag) &#123; case HostComponent: return getPublicInstance(containerFiber.child.stateNode); default: return containerFiber.child.stateNode; &#125;&#125; 由此可见，legacyRenderSubtreeIntoContainer主要执行了以下几个操作：root：由legacyCreateRootFromDOMContainer生成，该函数会生成一个FiberRoot对象挂载到真实的dom根节点上，有了这个对象，执行该对象上的一些方法可以将虚拟dom变成dom树挂载到根节点上。DOMRenderer.unbatchedUpdates：DOMRenderer.unbatchedUpdates的回调执行root.legacy_renderSubtreeIntoContainer或root.render。root.legacy_renderSubtreeIntoContainer 和 root.render：如果有parentComponent，就执行root.render否则执行root.legacy_renderSubtreeIntoContainer。 root我们知道root是由legacyCreateRootFromDOMContainer生成的，我们找到legacyCreateRootFromDOMContainer函数，源码在packages/react-dom/src/client/ReactDOM.js中:1234567891011121314151617181920212223242526272829function legacyCreateRootFromDOMContainer( container: DOMContainer, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 forceHydrate: boolean, // 服务器端渲染标识 这里为false): Root &#123; const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // 是否需要服务器端渲染 if (!shouldHydrate) &#123; let warned = false; let rootSibling; while ((rootSibling = container.lastChild)) &#123; if (__DEV__) &#123; // ... &#125; // 将dom根节点清空 container.removeChild(rootSibling); &#125; &#125; if (__DEV__) &#123; // ... &#125; // Legacy roots are not async by default. const isAsync = false; return new ReactRoot( container, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync, // 是否异步模式，默认false shouldHydrate // 服务器端渲染标识 这里为false );&#125; 我们发现该函数实际上返回的是由构造函数ReactRoot创建的对象。其中如果在非ssr的情况下，将dom根节点清空。我们找到构造函数ReactRoot，源码在packages\react-dom\src\client\ReactDOM.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 构造函数function ReactRoot( container: Container, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync: boolean, // 是否异步模式，默认false hydrate: boolean // 服务器端渲染标识 这里为false) &#123; // FiberRoot 对象 const root = DOMRenderer.createContainer( container, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync, // 是否异步模式，默认false hydrate // 服务器端渲染标识 这里为false ); this._internalRoot = root;&#125;// 以下几个是原型方法// 渲染ReactRoot.prototype.render = function( children: ReactNodeList, // 虚拟dom树 callback: ?() =&gt; mixed, // 回调函数): Work &#123; const root = this._internalRoot; const work = new ReactWork(); callback = callback === undefined ? null : callback; if (__DEV__) &#123; warnOnInvalidCallback(callback, 'render'); &#125; if (callback !== null) &#123; work.then(callback); &#125; DOMRenderer.updateContainer( children, // 虚拟dom树 root, // FiberRoot 对象 null, // 父组件 这里为 null work._onCommit ); return work;&#125;;// 销毁组件ReactRoot.prototype.unmount = function(callback: ?() =&gt; mixed): Work &#123; // ...&#125;;ReactRoot.prototype.legacy_renderSubtreeIntoContainer = function( parentComponent: ?React$Component&lt;any, any&gt;, children: ReactNodeList, callback: ?() =&gt; mixed,): Work &#123; const root = this._internalRoot; const work = new ReactWork(); callback = callback === undefined ? null : callback; if (__DEV__) &#123; warnOnInvalidCallback(callback, 'render'); &#125; if (callback !== null) &#123; work.then(callback); &#125; DOMRenderer.updateContainer( children, // 虚拟dom树 root, // FiberRoot 对象 parentComponent, // 父组件 work._onCommit ); return work;&#125;;ReactRoot.prototype.createBatch = function(): Batch &#123; // ...&#125;; 可以看出构造函数ReactRoot有render、unmount、legacy_renderSubtreeIntoContainer等原型方法外，同时还声明了一个和fiber相关的_internalRoot属性。其中render和legacy_renderSubtreeIntoContainer原型方法都会去执行DOMRenderer.updateContainer方法更新容器内容，唯一差别就是第三个参数一个传null，一个传parentComponent。_internalRoot是由DOMRenderer.createContainer生成的。我们找到DOMRenderer.createContainer，源码在packages\react-reconciler\src\ReactFiberReconciler.js中：1234567891011export function createContainer( containerInfo: Container, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync: boolean, // 是否异步模式，默认false hydrate: boolean, // 服务器端渲染标识 这里为false): OpaqueRoot &#123; return createFiberRoot( containerInfo, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync, // 是否异步模式，默认false hydrate // 服务器端渲染标识 这里为false );&#125; 接下来我们看看createFiberRoot是怎么将一个真实DOM变成一个Fiber对象，我们找到createFiberRoot，源码在 packages\react-reconciler\src\ReactFiberReconciler.js 中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159export function createFiberRoot( containerInfo: any, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync: boolean, // 是否异步模式，默认false hydrate: boolean, // 服务器端渲染标识 这里为false): FiberRoot &#123; // 创建初始根组件对应的fiber实例 const uninitializedFiber = createHostRootFiber(isAsync); let root; if (enableSchedulerTracing) &#123; root = (&#123; current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, interactionThreadID: unstable_getThreadID(), memoizedInteractions: new Set(), pendingInteractionMap: new Map(), &#125;: FiberRoot); &#125; else &#123; root = (&#123; current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, &#125;: BaseFiberRootProperties); &#125; uninitializedFiber.stateNode = root; return ((root: any): FiberRoot);&#125;// 源码在 packages\react-reconciler\src\ReactFiber.js 中// 返回一个初始根组件对应的fiber实例export function createHostRootFiber(isAsync: boolean): Fiber &#123; let mode = isAsync ? AsyncMode | StrictMode : NoContext; if (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123; // Always collect profile timings when DevTools are present. // This enables DevTools to start capturing timing at any point– // Without some nodes in the tree having empty base times. mode |= ProfileMode; &#125; // 创建 Fiber 实例 return createFiber( HostRoot, // 组件树根组件，可以嵌套 null, null, mode );&#125;// 源码在 packages\react-reconciler\src\ReactFiber.js 中// 创建 Fiber 实例const createFiber = function( tag: WorkTag, // 标记 fiber 类型 pendingProps: mixed, // 当前处理过程中的组件props对象 key: null | string, // 调和阶段，标识fiber，以检测是否可重用该fiber实例 mode: TypeOfMode,): Fiber &#123; // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors return new FiberNode(tag, pendingProps, key, mode);&#125;;// 源码在 packages\react-reconciler\src\ReactFiber.js 中function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode,) &#123; // Instance this.tag = tag; this.key = key; this.type = null; this.stateNode = null; // Fiber this.return = null; this.child = null; this.sibling = null; this.index = 0; this.ref = null; this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.firstContextDependency = null; this.mode = mode; // Effects this.effectTag = NoEffect; this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; this.expirationTime = NoWork; this.childExpirationTime = NoWork; this.alternate = null; if (enableProfilerTimer) &#123; this.actualDuration = 0; this.actualStartTime = -1; this.selfBaseDuration = 0; this.treeBaseDuration = 0; &#125; if (__DEV__) &#123; this._debugID = debugCounter++; this._debugSource = null; this._debugOwner = null; this._debugIsCurrentlyTiming = false; if (!hasBadMapPolyfill &amp;&amp; typeof Object.preventExtensions === 'function') &#123; Object.preventExtensions(this); &#125; &#125;&#125; 由此可知，react-dom渲染模块调用createContainer创建容器、根fiber实例、FiberRoot对象等。所有Fiber对象都是FiberNode的实例，它有许多种类型，通过tag来标识，其中内部有很多方法来生成Fiber对象： createFiberFromElement：type为类，无状态函数，元素标签名 createFiberFromFragment：type为React.Fragment createFiberFromText：在JSX中表现为字符串，数字 createFiberFromPortal：用于 createPortal createFiberRoot：用于ReactDOM.render的根节点 这里createFiberRoot就是创建了一个普通对象，里面current属性引用fiber对象，containerInfo属性引用ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点，然后fiber对象的stateNode引用普通对象root。在React15中，stateNode应该是一个组件实例或真实DOM，最后返回普通对象stateNode。现在我们回顾下调用reactDOM.render传入的container，在执行过程中附加了哪些有用的东西：1234567container = &#123; // 就是我们传入的那个真实dom _reactRootContainer: &#123; // legacyCreateRootFromDOMContainer _internalRoot: &#123; // DOMRenderer.createContainer current:&#123;&#125; // new FiberNode &#125; &#125;&#125; unbatchedUpdates我们找到DOMRenderer.unbatchedUpdates，源码在packages\react-reconciler\src\ReactFiberScheduler.js中：123456789101112131415161718192021// 正在批量更新标识let isBatchingUpdates: boolean = false;// 未批量更新标识let isUnbatchingUpdates: boolean = false;// 非批量更新操作function unbatchedUpdates&lt;A, R&gt;(fn: (a: A) =&gt; R, a: A): R &#123; // 如果正在批量更新 if (isBatchingUpdates &amp;&amp; !isUnbatchingUpdates) &#123; // 未批量更新设为true isUnbatchingUpdates = true; try &#123; // 运行入参函数且返回执行结果 return fn(a); &#125; finally &#123; // 仍旧将未批量更新设为false isUnbatchingUpdates = false; &#125; &#125; // 不管是否在批量更新流程中，都执行入参函数 return fn(a);&#125; 由此可知unbatchedUpdates无论如何都会执行入参函数，其中isBatchingUpdates和isUnbatchingUpdates初始值都是false。DOMRenderer.unbatchedUpdates的回调执行root.legacy_renderSubtreeIntoContainer或root.render。 更新容器内容从legacyRenderSubtreeIntoContainer函数里可以看出，无论怎样判断，最终都会到root.legacy_renderSubtreeIntoContainer和root.render两个方法，而这两个方法的核心就是DOMRenderer.updateContainer，无非就是传不传父组件这点区别。我们找到DOMRenderer.updateContainer，源码在packages\react-reconciler\src\ReactFiberReconciler.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125export function updateContainer( element: ReactNodeList, // ReactDOM.render函数的第一个参数，泛指各种虚拟DOM container: OpaqueRoot, // ReactDOM.render函数的第二个参数，也就是一个元素节点 parentComponent: ?React$Component&lt;any, any&gt;, // parentComponent为之前的根组件，现在它为null callback: ?Function, // 回调函数): ExpirationTime &#123; // createFiberRoot中创建的fiber对象 const current = container.current; const currentTime = requestCurrentTime(); // 获取任务到期时间 const expirationTime = computeExpirationForFiber(currentTime, current); return updateContainerAtExpirationTime( element, // ReactDOM.render函数的第一个参数，泛指各种虚拟DOM container, // ReactDOM.render函数的第二个参数，也就是一个元素节点 parentComponent, // 父组件 expirationTime, // 任务到期时间 callback, // 回调函数 );&#125;// 源码在 packages\react-reconciler\src\ReactFiberScheduler.js 中// 计算fiber的到期时间function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) &#123; let expirationTime; if (expirationContext !== NoWork) &#123; // 显示设置过期上下文 expirationTime = expirationContext; &#125; else if (isWorking) &#123; if (isCommitting) &#123; // 在提交阶段的更新任务 // 需要明确设置同步优先级（Sync Priority） expirationTime = Sync; &#125; else &#123; // 在渲染阶段发生的更新任务 // 需要设置为下一次渲染时间的到期时间优先级 expirationTime = nextRenderExpirationTime; &#125; &#125; else &#123; // 不在任务执行阶段，需要计算新的过期时间 if (fiber.mode &amp; AsyncMode) &#123; if (isBatchingInteractiveUpdates) &#123; // This is an interactive update expirationTime = computeInteractiveExpiration(currentTime); &#125; else &#123; // 异步更新 expirationTime = computeAsyncExpiration(currentTime); &#125; // 如果我们正处于渲染树的中间, 请不要在已经呈现的相同过期时间内更新。 if (nextRoot !== null &amp;&amp; expirationTime === nextRenderExpirationTime) &#123; expirationTime += 1; &#125; &#125; else &#123; // 同步更新 expirationTime = Sync; &#125; &#125; if (isBatchingInteractiveUpdates) &#123; // This is an interactive update. Keep track of the lowest pending // interactive expiration time. This allows us to synchronously flush // all interactive updates when needed. if (expirationTime &gt; lowestPriorityPendingInteractiveExpirationTime) &#123; lowestPriorityPendingInteractiveExpirationTime = expirationTime; &#125; &#125; return expirationTime;&#125;// 根据渲染优先级更新domexport function updateContainerAtExpirationTime( element: ReactNodeList, // ReactDOM.render函数的第一个参数，泛指各种虚拟DOM container: OpaqueRoot, // ReactDOM.render函数的第二个参数，也就是一个元素节点 parentComponent: ?React$Component&lt;any, any&gt;, // parentComponent为之前的根组件，现在它为null expirationTime: ExpirationTime, // 期望的任务到期时间 callback: ?Function, // 回调函数) &#123; // TODO: If this is a nested container, this won't be the root. // 引用fiber对象 const current = container.current; if (__DEV__) &#123; // ... &#125; // 获得上下文对象 const context = getContextForSubtree(parentComponent); if (container.context === null) &#123; container.context = context; &#125; else &#123; container.pendingContext = context; &#125; // 下一步：schedule:安排, Root: 根, Update:更新 return scheduleRootUpdate( current, // fiber对象 element, // ReactDOM.render函数的第一个参数，泛指各种虚拟DOM expirationTime, // 期望的任务到期时间 callback // 回调函数 );&#125;// 源码在 packages\react-reconciler\src\ReactFiberReconciler.js 中// 获得上下文对象function getContextForSubtree( parentComponent: ?React$Component&lt;any, any&gt;,): Object &#123; if (!parentComponent) &#123; return emptyContextObject; &#125; const fiber = ReactInstanceMap.get(parentComponent); const parentContext = findCurrentUnmaskedContext(fiber); if (fiber.tag === ClassComponent) &#123; const Component = fiber.type; if (isLegacyContextProvider(Component)) &#123; return processChildContext(fiber, Component, parentContext); &#125; &#125; else if (fiber.tag === ClassComponentLazy) &#123; const Component = getResultFromResolvedThenable(fiber.type); if (isLegacyContextProvider(Component)) &#123; return processChildContext(fiber, Component, parentContext); &#125; &#125; return parentContext;&#125; updateContainer的源码很简单，通过computeExpirationForFiber获得计算优先级，然后丢给updateContainerAtExpirationTime，这里updateContainerAtExpirationTime其实相当于什么都没做，通过getContextForSubtree（这里getContextForSubtree因为一开始parentComponent是不存在的，于是返回一个空对象。注意，这个空对象可以重复使用，不用每次返回一个新的空对象，这是一个很好的优化）获得上下文对象，然后分配给container.context或container.pendingContext，最后一起丢给scheduleRootUpdate。 开始更新我们找到scheduleRootUpdate，源码在packages/react-reconciler/src/ReactFiberReconciler.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 进行根节点更新function scheduleRootUpdate( current: Fiber, // 引用fiber对象 element: ReactNodeList, // 虚拟dom树 expirationTime: ExpirationTime, // 任务到期时间 callback: ?Function, // 回调函数) &#123; if (__DEV__) &#123; // ... &#125; // 返回一个包含以上属性的update对象 const update = createUpdate(expirationTime); // Caution: React DevTools currently depends on this property // being called "element". // 将虚拟dom树放入payload update.payload = &#123;element&#125;; callback = callback === undefined ? null : callback; if (callback !== null) &#123; warningWithoutStack( typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback, ); update.callback = callback; &#125; // 开始队列更新 enqueueUpdate(current, update); // 调用调度器API：scheduleWork(...)来调度fiber任务 scheduleWork( current, // fiber实例 expirationTime // 任务到期时间 ); return expirationTime;&#125;// 创建一个包含以上属性的update对象export function createUpdate(expirationTime: ExpirationTime): Update&lt;*&gt; &#123; return &#123; expirationTime: expirationTime, tag: UpdateState, payload: null, callback: null, next: null, nextEffect: null, &#125;;&#125; scheduleRootUpdate是将用户的传参封装成一个update对象, 其中update对象有payload对象，它就是相当于React15中 的setState的第一个state传参，但现在payload中把children也放进去了。然后添加更新任务至fiber：enqueueUpdate(...)，现在我们找到enqueueUpdate，源码在packages/react-reconciler/src/ReactUpdateQueue.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125export function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) &#123; // alternate 主要用来保存更新过程中各版本更新队列，方便崩溃或冲突时回退 const alternate = fiber.alternate; // 创建两个独立的更新队列 let queue1; let queue2; if (alternate === null) &#123; // 只存在一个 fiber queue1 = fiber.updateQueue; queue2 = null; if (queue1 === null) &#123; // 如果不存在，则创建一个更新队列 queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState); &#125; &#125; else &#123; // 两个所有者 queue1 = fiber.updateQueue; queue2 = alternate.updateQueue; if (queue1 === null) &#123; if (queue2 === null) &#123; // 如果两个都不存在，则创建两个新的 queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState); queue2 = alternate.updateQueue = createUpdateQueue( alternate.memoizedState, ); &#125; else &#123; // queue1 不存在，queue2 存在，queue1 根据 queue2 创建 queue1 = fiber.updateQueue = cloneUpdateQueue(queue2); &#125; &#125; else &#123; if (queue2 === null) &#123; // queue2 不存在，queue1 存在，queue2 根据 queue1 创建 queue2 = alternate.updateQueue = cloneUpdateQueue(queue1); &#125; else &#123; // 全都有 &#125; &#125; &#125; if (queue2 === null || queue1 === queue2) &#123; // 只存在一个更新队列 appendUpdateToQueue(queue1, update); &#125; else &#123; // 如果任意更新队列为空，则需要将更新添加至两个更新队列 if (queue1.lastUpdate === null || queue2.lastUpdate === null) &#123; appendUpdateToQueue(queue1, update); appendUpdateToQueue(queue2, update); &#125; else &#123; // 如果2个更新队列均非空，则添加更新至第一个队列，并更新另一个队列的尾部更新项 appendUpdateToQueue(queue1, update); queue2.lastUpdate = update; &#125; &#125; if (__DEV__) &#123; if ( (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) &amp;&amp; (currentlyProcessingQueue === queue1 || (queue2 !== null &amp;&amp; currentlyProcessingQueue === queue2)) &amp;&amp; !didWarnUpdateInsideUpdate ) &#123; warningWithoutStack( false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.', ); didWarnUpdateInsideUpdate = true; &#125; &#125;&#125;// 创建一个更新队列export function createUpdateQueue&lt;State&gt;(baseState: State): UpdateQueue&lt;State&gt; &#123; const queue: UpdateQueue&lt;State&gt; = &#123; baseState, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null, &#125;; return queue;&#125;// clone 一个更新队列function cloneUpdateQueue&lt;State&gt;( currentQueue: UpdateQueue&lt;State&gt;,): UpdateQueue&lt;State&gt; &#123; const queue: UpdateQueue&lt;State&gt; = &#123; baseState: currentQueue.baseState, firstUpdate: currentQueue.firstUpdate, lastUpdate: currentQueue.lastUpdate, // TODO: With resuming, if we bail out and resuse the child tree, we should // keep these effects. firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null, &#125;; return queue;&#125;// 更新队列function appendUpdateToQueue&lt;State&gt;( queue: UpdateQueue&lt;State&gt;, update: Update&lt;State&gt;,) &#123; // Append the update to the end of the list. if (queue.lastUpdate === null) &#123; // Queue is empty queue.firstUpdate = queue.lastUpdate = update; &#125; else &#123; queue.lastUpdate.next = update; queue.lastUpdate = update; &#125;&#125; 这里enqueueUpdate是一个链表，然后根据fiber的状态创建一个或两个列队对象，再接下来调用调度器API：scheduleWork(...)来调度fiber任务，现在我们看一下如何处理更新的。 处理更新我们找到scheduleWork，源码在packages/react-reconciler/src/ReactFiberScheduler.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) &#123; // 记录调度器的执行状态 recordScheduleUpdate(); if (__DEV__) &#123; if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) &#123; const instance = fiber.stateNode; warnAboutInvalidUpdates(instance); &#125; &#125; const root = scheduleWorkToRoot(fiber, expirationTime); if (root === null) &#123; if ( __DEV__ &amp;&amp; (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) ) &#123; warnAboutUpdateOnUnmounted(fiber); &#125; return; &#125; if (enableSchedulerTracing) &#123; const interactions = __interactionsRef.current; if (interactions.size &gt; 0) &#123; const pendingInteractionMap = root.pendingInteractionMap; const pendingInteractions = pendingInteractionMap.get(expirationTime); if (pendingInteractions != null) &#123; interactions.forEach(interaction =&gt; &#123; if (!pendingInteractions.has(interaction)) &#123; // Update the pending async work count for previously unscheduled interaction. interaction.__count++; &#125; pendingInteractions.add(interaction); &#125;); &#125; else &#123; pendingInteractionMap.set(expirationTime, new Set(interactions)); // Update the pending async work count for the current interactions. interactions.forEach(interaction =&gt; &#123; interaction.__count++; &#125;); &#125; const subscriber = __subscriberRef.current; if (subscriber !== null) &#123; const threadID = computeThreadID( expirationTime, root.interactionThreadID, ); subscriber.onWorkScheduled(interactions, threadID); &#125; &#125; &#125; if ( !isWorking &amp;&amp; nextRenderExpirationTime !== NoWork &amp;&amp; expirationTime &lt; nextRenderExpirationTime ) &#123; // This is an interruption. (Used for performance tracking.) interruptedBy = fiber; resetStack(); &#125; markPendingPriorityLevel(root, expirationTime); if ( // If we're in the render phase, we don't need to schedule this root // for an update, because we'll do it before we exit... !isWorking || isCommitting || // ...unless this is a different root than the one we're rendering. nextRoot !== root ) &#123; const rootExpirationTime = root.expirationTime; requestWork(root, rootExpirationTime); &#125; if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) &#123; // Reset this back to zero so subsequent updates don't throw. nestedUpdateCount = 0; invariant( false, 'Maximum update depth exceeded. This can happen when a ' + 'component repeatedly calls setState inside ' + 'componentWillUpdate or componentDidUpdate. React limits ' + 'the number of nested updates to prevent infinite loops.', ); &#125;&#125;function scheduleWorkToRoot(fiber: Fiber, expirationTime): FiberRoot | null &#123; // 更新 fiber实例的过期时间 if ( fiber.expirationTime === NoWork || fiber.expirationTime &gt; expirationTime ) &#123; // 若fiber实例到期时间大于期望的任务到期时间，则更新fiber到期时间 fiber.expirationTime = expirationTime; &#125; let alternate = fiber.alternate; // 同时更新alternate fiber的到期时间 if ( alternate !== null &amp;&amp; (alternate.expirationTime === NoWork || alternate.expirationTime &gt; expirationTime) ) &#123; // 若alternate fiber到期时间大于期望的任务到期时间，则更新fiber到期时间 alternate.expirationTime = expirationTime; &#125; let node = fiber.return; // fiber.return 为空，说明到达组件树顶部 if (node === null &amp;&amp; fiber.tag === HostRoot) &#123; // 确保是组件树根组件并获取FiberRoot实例 return fiber.stateNode; &#125; while (node !== null) &#123; alternate = node.alternate; if ( node.childExpirationTime === NoWork || node.childExpirationTime &gt; expirationTime ) &#123; node.childExpirationTime = expirationTime; if ( alternate !== null &amp;&amp; (alternate.childExpirationTime === NoWork || alternate.childExpirationTime &gt; expirationTime) ) &#123; alternate.childExpirationTime = expirationTime; &#125; &#125; else if ( alternate !== null &amp;&amp; (alternate.childExpirationTime === NoWork || alternate.childExpirationTime &gt; expirationTime) ) &#123; alternate.childExpirationTime = expirationTime; &#125; if (node.return === null &amp;&amp; node.tag === HostRoot) &#123; return node.stateNode; &#125; node = node.return; &#125; return null;&#125; 这里scheduleWork主要进行虚拟DOM（fiber树）的更新。scheduleWork的最开头有一个recordScheduleUpdate方法，我们找到recordScheduleUpdate，源码在packages\react-reconciler\src\ReactDebugFiberPerf.js中：123456789101112131415export function recordScheduleUpdate(): void &#123; if (enableUserTimingAPI) &#123; // 全局变量，默认为true if (isCommitting) &#123; // 全局变量，默认为false, 没有进入分支 hasScheduledUpdateInCurrentCommit = true; &#125; // 全局变量，默认为null，没有没有进入分支 if ( currentPhase !== null &amp;&amp; currentPhase !== 'componentWillMount' &amp;&amp; currentPhase !== 'componentWillReceiveProps' ) &#123; hasScheduledUpdateInCurrentPhase = true; &#125; &#125;&#125; recordScheduleUpdate主要用来记录调度器的执行状态，如注释所示，它现在相当于什么都没有做。 requestWork123456789101112131415161718192021222324252627function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123; addRootToSchedule(root, expirationTime); if (isRendering) &#123; // Prevent reentrancy. Remaining work will be scheduled at the end of // the currently rendering batch. return; &#125; if (isBatchingUpdates) &#123; // Flush work at the end of the batch. if (isUnbatchingUpdates) &#123; // ...unless we're inside unbatchedUpdates, in which case we should // flush it now. nextFlushedRoot = root; nextFlushedExpirationTime = Sync; performWorkOnRoot(root, Sync, true); &#125; return; &#125; // TODO: Get rid of Sync and use current time? if (expirationTime === Sync) &#123; performSyncWork(); &#125; else &#123; scheduleCallbackWithExpirationTime(root, expirationTime); &#125;&#125; performWork12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function performWork(minExpirationTime: ExpirationTime, dl: Deadline | null) &#123; deadline = dl; // Keep working on roots until there's no more work, or until we reach // the deadline. findHighestPriorityRoot(); if (deadline !== null) &#123; recomputeCurrentRendererTime(); currentSchedulerTime = currentRendererTime; if (enableUserTimingAPI) &#123; const didExpire = nextFlushedExpirationTime &lt; currentRendererTime; const timeout = expirationTimeToMs(nextFlushedExpirationTime); stopRequestCallbackTimer(didExpire, timeout); &#125; while ( nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime) &amp;&amp; (!deadlineDidExpire || currentRendererTime &gt;= nextFlushedExpirationTime) ) &#123; performWorkOnRoot( nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime &gt;= nextFlushedExpirationTime, ); findHighestPriorityRoot(); recomputeCurrentRendererTime(); currentSchedulerTime = currentRendererTime; &#125; &#125; else &#123; while ( nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime) ) &#123; performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true); findHighestPriorityRoot(); &#125; &#125; // We're done flushing work. Either we ran out of time in this callback, // or there's no more work left with sufficient priority. // If we're inside a callback, set this to false since we just completed it. if (deadline !== null) &#123; callbackExpirationTime = NoWork; callbackID = null; &#125; // If there's work left over, schedule a new callback. if (nextFlushedExpirationTime !== NoWork) &#123; scheduleCallbackWithExpirationTime( ((nextFlushedRoot: any): FiberRoot), nextFlushedExpirationTime, ); &#125; // Clean-up. deadline = null; deadlineDidExpire = false; finishRendering();&#125; performWorkOnRoot123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function performWorkOnRoot( root: FiberRoot, expirationTime: ExpirationTime, isExpired: boolean,) &#123; invariant( !isRendering, 'performWorkOnRoot was called recursively. This error is likely caused ' + 'by a bug in React. Please file an issue.', ); isRendering = true; // Check if this is async work or sync/expired work. if (deadline === null || isExpired) &#123; // Flush work without yielding. // TODO: Non-yieldy work does not necessarily imply expired work. A renderer // may want to perform some work without yielding, but also without // requiring the root to complete (by triggering placeholders). let finishedWork = root.finishedWork; if (finishedWork !== null) &#123; // This root is already complete. We can commit it. completeRoot(root, finishedWork, expirationTime); &#125; else &#123; root.finishedWork = null; // If this root previously suspended, clear its existing timeout, since // we're about to try rendering again. const timeoutHandle = root.timeoutHandle; if (enableSuspense &amp;&amp; timeoutHandle !== noTimeout) &#123; root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above cancelTimeout(timeoutHandle); &#125; const isYieldy = false; renderRoot(root, isYieldy, isExpired); finishedWork = root.finishedWork; if (finishedWork !== null) &#123; // We've completed the root. Commit it. completeRoot(root, finishedWork, expirationTime); &#125; &#125; &#125; else &#123; // Flush async work. let finishedWork = root.finishedWork; if (finishedWork !== null) &#123; // This root is already complete. We can commit it. completeRoot(root, finishedWork, expirationTime); &#125; else &#123; root.finishedWork = null; // If this root previously suspended, clear its existing timeout, since // we're about to try rendering again. const timeoutHandle = root.timeoutHandle; if (enableSuspense &amp;&amp; timeoutHandle !== noTimeout) &#123; root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above cancelTimeout(timeoutHandle); &#125; const isYieldy = true; renderRoot(root, isYieldy, isExpired); finishedWork = root.finishedWork; if (finishedWork !== null) &#123; // We've completed the root. Check the deadline one more time // before committing. if (!shouldYield()) &#123; // Still time left. Commit the root. completeRoot(root, finishedWork, expirationTime); &#125; else &#123; // There's no time left. Mark this root as complete. We'll come // back and commit it later. root.finishedWork = finishedWork; &#125; &#125; &#125; &#125; isRendering = false;&#125; renderRoot123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291function renderRoot( root: FiberRoot, isYieldy: boolean, isExpired: boolean,): void &#123; invariant( !isWorking, 'renderRoot was called recursively. This error is likely caused ' + 'by a bug in React. Please file an issue.', ); isWorking = true; ReactCurrentOwner.currentDispatcher = Dispatcher; const expirationTime = root.nextExpirationTimeToWorkOn; // Check if we're starting from a fresh stack, or if we're resuming from // previously yielded work. if ( expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null ) &#123; // Reset the stack and start working from the root. resetStack(); nextRoot = root; nextRenderExpirationTime = expirationTime; nextUnitOfWork = createWorkInProgress( nextRoot.current, null, nextRenderExpirationTime, ); root.pendingCommitExpirationTime = NoWork; if (enableSchedulerTracing) &#123; // Reset this flag once we start rendering a new root or at a new priority. // This might indicate that suspended work has completed. // If not, the flag will be reset. nextRenderIncludesTimedOutPlaceholder = false; // Determine which interactions this batch of work currently includes, // So that we can accurately attribute time spent working on it, // And so that cascading work triggered during the render phase will be associated with it. const interactions: Set&lt;Interaction&gt; = new Set(); root.pendingInteractionMap.forEach( (scheduledInteractions, scheduledExpirationTime) =&gt; &#123; if (scheduledExpirationTime &lt;= expirationTime) &#123; scheduledInteractions.forEach(interaction =&gt; interactions.add(interaction), ); &#125; &#125;, ); // Store the current set of interactions on the FiberRoot for a few reasons: // We can re-use it in hot functions like renderRoot() without having to recalculate it. // We will also use it in commitWork() to pass to any Profiler onRender() hooks. // This also provides DevTools with a way to access it when the onCommitRoot() hook is called. root.memoizedInteractions = interactions; if (interactions.size &gt; 0) &#123; const subscriber = __subscriberRef.current; if (subscriber !== null) &#123; const threadID = computeThreadID( expirationTime, root.interactionThreadID, ); try &#123; subscriber.onWorkStarted(interactions, threadID); &#125; catch (error) &#123; // Work thrown by an interaction tracing subscriber should be rethrown, // But only once it's safe (to avoid leaveing the scheduler in an invalid state). // Store the error for now and we'll re-throw in finishRendering(). if (!hasUnhandledError) &#123; hasUnhandledError = true; unhandledError = error; &#125; &#125; &#125; &#125; &#125; &#125; let prevInteractions: Set&lt;Interaction&gt; = (null: any); if (enableSchedulerTracing) &#123; // We're about to start new traced work. // Restore pending interactions so cascading work triggered during the render phase will be accounted for. prevInteractions = __interactionsRef.current; __interactionsRef.current = root.memoizedInteractions; &#125; let didFatal = false; startWorkLoopTimer(nextUnitOfWork); do &#123; try &#123; workLoop(isYieldy); &#125; catch (thrownValue) &#123; if (nextUnitOfWork === null) &#123; // This is a fatal error. didFatal = true; onUncaughtError(thrownValue); &#125; else &#123; if (__DEV__) &#123; // Reset global debug state // We assume this is defined in DEV (resetCurrentlyProcessingQueue: any)(); &#125; const failedUnitOfWork: Fiber = nextUnitOfWork; if (__DEV__ &amp;&amp; replayFailedUnitOfWorkWithInvokeGuardedCallback) &#123; replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy); &#125; // TODO: we already know this isn't true in some cases. // At least this shows a nicer error message until we figure out the cause. // https://github.com/facebook/react/issues/12449#issuecomment-386727431 invariant( nextUnitOfWork !== null, 'Failed to replay rendering after an error. This ' + 'is likely caused by a bug in React. Please file an issue ' + 'with a reproducing case to help us find it.', ); const sourceFiber: Fiber = nextUnitOfWork; let returnFiber = sourceFiber.return; if (returnFiber === null) &#123; // This is the root. The root could capture its own errors. However, // we don't know if it errors before or after we pushed the host // context. This information is needed to avoid a stack mismatch. // Because we're not sure, treat this as a fatal error. We could track // which phase it fails in, but doesn't seem worth it. At least // for now. didFatal = true; onUncaughtError(thrownValue); &#125; else &#123; throwException( root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime, ); nextUnitOfWork = completeUnitOfWork(sourceFiber); continue; &#125; &#125; &#125; break; &#125; while (true); if (enableSchedulerTracing) &#123; // Traced work is done for now; restore the previous interactions. __interactionsRef.current = prevInteractions; &#125; // We're done performing work. Time to clean up. isWorking = false; ReactCurrentOwner.currentDispatcher = null; resetContextDependences(); // Yield back to main thread. if (didFatal) &#123; const didCompleteRoot = false; stopWorkLoopTimer(interruptedBy, didCompleteRoot); interruptedBy = null; // There was a fatal error. if (__DEV__) &#123; resetStackAfterFatalErrorInDev(); &#125; // `nextRoot` points to the in-progress root. A non-null value indicates // that we're in the middle of an async render. Set it to null to indicate // there's no more work to be done in the current batch. nextRoot = null; onFatal(root); return; &#125; if (nextUnitOfWork !== null) &#123; // There's still remaining async work in this tree, but we ran out of time // in the current frame. Yield back to the renderer. Unless we're // interrupted by a higher priority update, we'll continue later from where // we left off. const didCompleteRoot = false; stopWorkLoopTimer(interruptedBy, didCompleteRoot); interruptedBy = null; onYield(root); return; &#125; // We completed the whole tree. const didCompleteRoot = true; stopWorkLoopTimer(interruptedBy, didCompleteRoot); const rootWorkInProgress = root.current.alternate; invariant( rootWorkInProgress !== null, 'Finished root should have a work-in-progress. This error is likely ' + 'caused by a bug in React. Please file an issue.', ); // `nextRoot` points to the in-progress root. A non-null value indicates // that we're in the middle of an async render. Set it to null to indicate // there's no more work to be done in the current batch. nextRoot = null; interruptedBy = null; if (nextRenderDidError) &#123; // There was an error if (hasLowerPriorityWork(root, expirationTime)) &#123; // There's lower priority work. If so, it may have the effect of fixing // the exception that was just thrown. Exit without committing. This is // similar to a suspend, but without a timeout because we're not waiting // for a promise to resolve. React will restart at the lower // priority level. markSuspendedPriorityLevel(root, expirationTime); const suspendedExpirationTime = expirationTime; const rootExpirationTime = root.expirationTime; onSuspend( root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1, // Indicates no timeout ); return; &#125; else if ( // There's no lower priority work, but we're rendering asynchronously. // Synchronsouly attempt to render the same level one more time. This is // similar to a suspend, but without a timeout because we're not waiting // for a promise to resolve. !root.didError &amp;&amp; !isExpired ) &#123; root.didError = true; const suspendedExpirationTime = (root.nextExpirationTimeToWorkOn = expirationTime); const rootExpirationTime = (root.expirationTime = Sync); onSuspend( root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1, // Indicates no timeout ); return; &#125; &#125; if (enableSuspense &amp;&amp; !isExpired &amp;&amp; nextLatestAbsoluteTimeoutMs !== -1) &#123; // The tree was suspended. if (enableSchedulerTracing) &#123; nextRenderIncludesTimedOutPlaceholder = true; &#125; const suspendedExpirationTime = expirationTime; markSuspendedPriorityLevel(root, suspendedExpirationTime); // Find the earliest uncommitted expiration time in the tree, including // work that is suspended. The timeout threshold cannot be longer than // the overall expiration. const earliestExpirationTime = findEarliestOutstandingPriorityLevel( root, expirationTime, ); const earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime); if (earliestExpirationTimeMs &lt; nextLatestAbsoluteTimeoutMs) &#123; nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs; &#125; // Subtract the current time from the absolute timeout to get the number // of milliseconds until the timeout. In other words, convert an absolute // timestamp to a relative time. This is the value that is passed // to `setTimeout`. const currentTimeMs = expirationTimeToMs(requestCurrentTime()); let msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs; msUntilTimeout = msUntilTimeout &lt; 0 ? 0 : msUntilTimeout; // TODO: Account for the Just Noticeable Difference const rootExpirationTime = root.expirationTime; onSuspend( root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, msUntilTimeout, ); return; &#125; // Ready to commit. onComplete(root, rootWorkInProgress, expirationTime);&#125; completeRoot1234567891011121314151617181920212223242526272829303132333435363738function completeRoot( root: FiberRoot, finishedWork: Fiber, expirationTime: ExpirationTime,): void &#123; // Check if there's a batch that matches this expiration time. const firstBatch = root.firstBatch; if (firstBatch !== null &amp;&amp; firstBatch._expirationTime &lt;= expirationTime) &#123; if (completedBatches === null) &#123; completedBatches = [firstBatch]; &#125; else &#123; completedBatches.push(firstBatch); &#125; if (firstBatch._defer) &#123; // This root is blocked from committing by a batch. Unschedule it until // we receive another update. root.finishedWork = finishedWork; root.expirationTime = NoWork; return; &#125; &#125; // Commit the root. root.finishedWork = null; // Check if this is a nested update (a sync update scheduled during the // commit phase). if (root === lastCommittedRootDuringThisBatch) &#123; // If the next root is the same as the previous root, this is a nested // update. To prevent an infinite loop, increment the nested update count. nestedUpdateCount++; &#125; else &#123; // Reset whenever we switch roots. lastCommittedRootDuringThisBatch = root; nestedUpdateCount = 0; &#125; commitRoot(root, finishedWork);&#125; 提交更新处理完更新后需要确认提交更新至渲染模块，然后渲染模块才能将更新渲染至DOM。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342function commitRoot(root: FiberRoot, finishedWork: Fiber): void &#123; isWorking = true; isCommitting = true; startCommitTimer(); invariant( root.current !== finishedWork, 'Cannot commit the same tree as before. This is probably a bug ' + 'related to the return field. This error is likely caused by a bug ' + 'in React. Please file an issue.', ); const committedExpirationTime = root.pendingCommitExpirationTime; invariant( committedExpirationTime !== NoWork, 'Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.', ); root.pendingCommitExpirationTime = NoWork; // Update the pending priority levels to account for the work that we are // about to commit. This needs to happen before calling the lifecycles, since // they may schedule additional updates. const updateExpirationTimeBeforeCommit = finishedWork.expirationTime; const childExpirationTimeBeforeCommit = finishedWork.childExpirationTime; const earliestRemainingTimeBeforeCommit = updateExpirationTimeBeforeCommit === NoWork || (childExpirationTimeBeforeCommit !== NoWork &amp;&amp; childExpirationTimeBeforeCommit &lt; updateExpirationTimeBeforeCommit) ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit; markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit); let prevInteractions: Set&lt;Interaction&gt; = (null: any); if (enableSchedulerTracing) &#123; // Restore any pending interactions at this point, // So that cascading work triggered during the render phase will be accounted for. prevInteractions = __interactionsRef.current; __interactionsRef.current = root.memoizedInteractions; &#125; // Reset this to null before calling lifecycles ReactCurrentOwner.current = null; let firstEffect; if (finishedWork.effectTag &gt; PerformedWork) &#123; // A fiber's effect list consists only of its children, not itself. So if // the root has an effect, we need to add it to the end of the list. The // resulting list is the set that would belong to the root's parent, if // it had one; that is, all the effects in the tree including the root. if (finishedWork.lastEffect !== null) &#123; finishedWork.lastEffect.nextEffect = finishedWork; firstEffect = finishedWork.firstEffect; &#125; else &#123; firstEffect = finishedWork; &#125; &#125; else &#123; // There is no effect on the root. firstEffect = finishedWork.firstEffect; &#125; prepareForCommit(root.containerInfo); // Invoke instances of getSnapshotBeforeUpdate before mutation. nextEffect = firstEffect; startCommitSnapshotEffectsTimer(); while (nextEffect !== null) &#123; let didError = false; let error; if (__DEV__) &#123; invokeGuardedCallback(null, commitBeforeMutationLifecycles, null); if (hasCaughtError()) &#123; didError = true; error = clearCaughtError(); &#125; &#125; else &#123; try &#123; commitBeforeMutationLifecycles(); &#125; catch (e) &#123; didError = true; error = e; &#125; &#125; if (didError) &#123; invariant( nextEffect !== null, 'Should have next effect. This error is likely caused by a bug ' + 'in React. Please file an issue.', ); captureCommitPhaseError(nextEffect, error); // Clean-up if (nextEffect !== null) &#123; nextEffect = nextEffect.nextEffect; &#125; &#125; &#125; stopCommitSnapshotEffectsTimer(); if (enableProfilerTimer) &#123; // Mark the current commit time to be shared by all Profilers in this batch. // This enables them to be grouped later. recordCommitTime(); &#125; // Commit all the side-effects within a tree. We'll do this in two passes. // The first pass performs all the host insertions, updates, deletions and // ref unmounts. nextEffect = firstEffect; startCommitHostEffectsTimer(); while (nextEffect !== null) &#123; let didError = false; let error; if (__DEV__) &#123; invokeGuardedCallback(null, commitAllHostEffects, null); if (hasCaughtError()) &#123; didError = true; error = clearCaughtError(); &#125; &#125; else &#123; try &#123; commitAllHostEffects(); &#125; catch (e) &#123; didError = true; error = e; &#125; &#125; if (didError) &#123; invariant( nextEffect !== null, 'Should have next effect. This error is likely caused by a bug ' + 'in React. Please file an issue.', ); captureCommitPhaseError(nextEffect, error); // Clean-up if (nextEffect !== null) &#123; nextEffect = nextEffect.nextEffect; &#125; &#125; &#125; stopCommitHostEffectsTimer(); resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after // the first pass of the commit phase, so that the previous tree is still // current during componentWillUnmount, but before the second pass, so that // the finished work is current during componentDidMount/Update. root.current = finishedWork; // In the second pass we'll perform all life-cycles and ref callbacks. // Life-cycles happen as a separate pass so that all placements, updates, // and deletions in the entire tree have already been invoked. // This pass also triggers any renderer-specific initial effects. nextEffect = firstEffect; startCommitLifeCyclesTimer(); while (nextEffect !== null) &#123; let didError = false; let error; if (__DEV__) &#123; invokeGuardedCallback( null, commitAllLifeCycles, null, root, committedExpirationTime, ); if (hasCaughtError()) &#123; didError = true; error = clearCaughtError(); &#125; &#125; else &#123; try &#123; commitAllLifeCycles(root, committedExpirationTime); &#125; catch (e) &#123; didError = true; error = e; &#125; &#125; if (didError) &#123; invariant( nextEffect !== null, 'Should have next effect. This error is likely caused by a bug ' + 'in React. Please file an issue.', ); captureCommitPhaseError(nextEffect, error); if (nextEffect !== null) &#123; nextEffect = nextEffect.nextEffect; &#125; &#125; &#125; isCommitting = false; isWorking = false; stopCommitLifeCyclesTimer(); stopCommitTimer(); onCommitRoot(finishedWork.stateNode); if (__DEV__ &amp;&amp; ReactFiberInstrumentation.debugTool) &#123; ReactFiberInstrumentation.debugTool.onCommitWork(finishedWork); &#125; const updateExpirationTimeAfterCommit = finishedWork.expirationTime; const childExpirationTimeAfterCommit = finishedWork.childExpirationTime; const earliestRemainingTimeAfterCommit = updateExpirationTimeAfterCommit === NoWork || (childExpirationTimeAfterCommit !== NoWork &amp;&amp; childExpirationTimeAfterCommit &lt; updateExpirationTimeAfterCommit) ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit; if (earliestRemainingTimeAfterCommit === NoWork) &#123; // If there's no remaining work, we can clear the set of already failed // error boundaries. legacyErrorBoundariesThatAlreadyFailed = null; &#125; onCommit(root, earliestRemainingTimeAfterCommit); if (enableSchedulerTracing) &#123; __interactionsRef.current = prevInteractions; let subscriber; try &#123; subscriber = __subscriberRef.current; if (subscriber !== null &amp;&amp; root.memoizedInteractions.size &gt; 0) &#123; const threadID = computeThreadID( committedExpirationTime, root.interactionThreadID, ); subscriber.onWorkStopped(root.memoizedInteractions, threadID); &#125; &#125; catch (error) &#123; // It's not safe for commitRoot() to throw. // Store the error for now and we'll re-throw in finishRendering(). if (!hasUnhandledError) &#123; hasUnhandledError = true; unhandledError = error; &#125; &#125; finally &#123; if (!nextRenderIncludesTimedOutPlaceholder) &#123; // Clear completed interactions from the pending Map. // Unless the render was suspended or cascading work was scheduled, // In which case– leave pending interactions until the subsequent render. const pendingInteractionMap = root.pendingInteractionMap; pendingInteractionMap.forEach( (scheduledInteractions, scheduledExpirationTime) =&gt; &#123; // Only decrement the pending interaction count if we're done. // If there's still work at the current priority, // That indicates that we are waiting for suspense data. if ( earliestRemainingTimeAfterCommit === NoWork || scheduledExpirationTime &lt; earliestRemainingTimeAfterCommit ) &#123; pendingInteractionMap.delete(scheduledExpirationTime); scheduledInteractions.forEach(interaction =&gt; &#123; interaction.__count--; if (subscriber !== null &amp;&amp; interaction.__count === 0) &#123; try &#123; subscriber.onInteractionScheduledWorkCompleted(interaction); &#125; catch (error) &#123; // It's not safe for commitRoot() to throw. // Store the error for now and we'll re-throw in finishRendering(). if (!hasUnhandledError) &#123; hasUnhandledError = true; unhandledError = error; &#125; &#125; &#125; &#125;); &#125; &#125;, ); &#125; &#125; &#125;&#125;// 循环执行提交更新function commitAllHostEffects() &#123; while (nextEffect !== null) &#123; if (__DEV__) &#123; ReactCurrentFiber.setCurrentFiber(nextEffect); &#125; recordEffect(); const effectTag = nextEffect.effectTag; if (effectTag &amp; ContentReset) &#123; commitResetTextContent(nextEffect); &#125; if (effectTag &amp; Ref) &#123; const current = nextEffect.alternate; if (current !== null) &#123; commitDetachRef(current); &#125; &#125; // The following switch statement is only concerned about placement, // updates, and deletions. To avoid needing to add a case for every // possible bitmap value, we remove the secondary effects from the // effect tag and switch on that value. let primaryEffectTag = effectTag &amp; (Placement | Update | Deletion); switch (primaryEffectTag) &#123; case Placement: &#123; commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is inserted, before // any life-cycles like componentDidMount gets called. // TODO: findDOMNode doesn't rely on this any more but isMounted // does and isMounted is deprecated anyway so we should be able // to kill this. nextEffect.effectTag &amp;= ~Placement; break; &#125; case PlacementAndUpdate: &#123; // Placement commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is inserted, before // any life-cycles like componentDidMount gets called. nextEffect.effectTag &amp;= ~Placement; // Update const current = nextEffect.alternate; commitWork(current, nextEffect); break; &#125; case Update: &#123; const current = nextEffect.alternate; commitWork(current, nextEffect); break; &#125; case Deletion: &#123; commitDeletion(nextEffect); break; &#125; &#125; nextEffect = nextEffect.nextEffect; &#125; if (__DEV__) &#123; ReactCurrentFiber.resetCurrentFiber(); &#125;&#125; 提交更新是最后确认更新组件的阶段，现在我们看一下提交更新的主要逻辑：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function commitWork(current: Fiber | null, finishedWork: Fiber): void &#123; if (!supportsMutation) &#123; commitContainer(finishedWork); return; &#125; switch (finishedWork.tag) &#123; case ClassComponent: case ClassComponentLazy: &#123; return; &#125; case HostComponent: &#123; const instance: Instance = finishedWork.stateNode; if (instance != null) &#123; // Commit the work prepared earlier. const newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps // as the newProps. The updatePayload will contain the real change in // this case. const oldProps = current !== null ? current.memoizedProps : newProps; const type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components. const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any); finishedWork.updateQueue = null; if (updatePayload !== null) &#123; commitUpdate( instance, updatePayload, type, oldProps, newProps, finishedWork, ); &#125; &#125; return; &#125; case HostText: &#123; invariant( finishedWork.stateNode !== null, 'This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.', ); const textInstance: TextInstance = finishedWork.stateNode; const newText: string = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps // as the newProps. The updatePayload will contain the real change in // this case. const oldText: string = current !== null ? current.memoizedProps : newText; commitTextUpdate(textInstance, oldText, newText); return; &#125; case HostRoot: &#123; return; &#125; case Profiler: &#123; return; &#125; case PlaceholderComponent: &#123; return; &#125; default: &#123; invariant( false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.', ); &#125; &#125;&#125; 小结至此首次渲染的执行流程为：ReactDOM.render（渲染入口） =&gt; legacyRenderSubtreeIntoContainer（把虚拟的dom树渲染到真实的dom容器中） =&gt; DOMRenderer.updateContainer（更新容器内容） =&gt; scheduleRootUpdate（开始更新） =&gt; scheduleWork（处理更新） =&gt; commitWork（提交更新） 高级指南插槽(Portals)Portals 提供了一种很好的方法，将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。 React Fiber React Fiber 并不是所谓的纤程（微线程、协程），而是一种基于浏览器的单线程调度算法。 我们都知道浏览器渲染引擎是单线程的，在 React15.x 及之前版本，从 setState 开始到渲染完成整个过程是不受控制且连续不中断完成的，由于该过程将会占用整个线程，则其他任务都会被阻塞，如样式计算、界面布局以及许多情况下的绘制等。如果需要渲染的是一个很大、层级很深的组件，这可能就会使用户感觉明显卡顿，比如更新一个组件需要1毫秒，如果有200个组件要更新，那就需要200毫秒，在这200毫秒的更新过程中，浏览器唯一的主线程在专心运行更新操作，无暇去做其他任何事情。想象一下，在这200毫秒内，用户往一个input元素中输入点什么，敲击键盘也不会立即获得响应，虽然渲染输入按键结果是浏览器主线程的工作，但是浏览器主线程被React占用，抽不出空，最后的结果就是用户敲了按键看不到反应，等React更新过程结束之后，咔咔咔那些按键一下子出现在input元素里了，这个版本的调和器可以称为栈调和器（Stack Reconciler）。Stack Reconcilier 的主要缺陷就是不能暂停渲染任务，也不能切分任务，更无法有效平衡组件更新渲染与动画相关任务间的执行顺序（即不能划分任务优先级），这样就很有可能导致重要任务卡顿，动画掉帧等问题。 为了解决这个问题，React 团队经过两年多的努力，提出了一个更先进的调和器，它允许渲染过程分段完成，而不必一次性完成，在渲染期间可返回到主线程控制执行其他任务。这是通过计算部分组件树的变更，并暂停渲染更新，询问主线程是否有更高需求的绘制或者更新任务需要执行，这些高需求的任务完成后再重新渲染。这一切的实现是在代码层引入了一个新的数据结构：Fiber对象，每一个组件实例对应有一个fiber实例，此fiber实例负责管理组件实例的更新，渲染任务及与其他fiber实例的通信，这个先进的调和器叫做纤维调和器（Fiber Reconciler），它提供的新功能主要有：一：把可中断的任务拆分成小任务；二：可重用各分阶段任务，对正在做的工作调整优先次序；三：可以在父子组件任务间前进后退切换任务，以支持React执行过程中的布局刷新；四：支持 render 方法返回多个元素；五：对异常边界处理提供了更好的支持； 调度任务（scheduleWork）前面提到 Fiber 可以异步实现不同优先级任务的协调执行，目前在 JavaScript 中也提供了这种方式，在新版主流浏览器有两个可用API：requestIdleCallback 和 requestAnimationFrame：requestIdleCallback：在线程空闲时调度执行低优先级函数。requestAnimationFrame：在下一个动画帧调度执行高优先级函数。 一般网页线程执行任务时会以帧的形式划分，大部分网页控制在30-60帧是不会影响用户体验的；在两个执行帧之间，主线程通常会有一小段空闲时间，requestIdleCallback可以在这个空闲期（Idle Period）调用空闲期回调（Idle Callback），执行一些任务。 而 Fiber 所做的就是需要分解渲染任务，根据优先级使用API调度，异步执行指定任务。低优先级任务由 requestIdleCallback 处理；高优先级任务，如动画相关的由 requestAnimationFrame 处理；requestIdleCallback 可以在多个空闲期调用空闲期回调，执行任务；requestIdleCallback 方法提供 deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞UI渲染而导致掉帧； 现在我们来看一下 React 调度任务实现的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442// TODO: 目前，只有一个优先级别，Deferred。未来将增加额外的优先级var DEFERRED_TIMEOUT = 5000;// 回调被储存为一个双向循环链表var firstCallbackNode = null;// 是否在执行工作var isPerformingWork = false;var isHostCallbackScheduled = false;var hasNativePerformanceNow = typeof performance === 'object' &amp;&amp; typeof performance.now === 'function';var timeRemaining;if (hasNativePerformanceNow) &#123; timeRemaining = function() &#123; // We assume that if we have a performance timer that the rAF callback // gets a performance timer value. Not sure if this is always true. var remaining = getFrameDeadline() - performance.now(); // 计算得到当前帧运行剩余时间 return remaining &gt; 0 ? remaining : 0; &#125;;&#125; else &#123; timeRemaining = function() &#123; // Fallback to Date.now() var remaining = getFrameDeadline() - Date.now(); // 计算得到当前帧运行剩余时间 return remaining &gt; 0 ? remaining : 0; &#125;;&#125;var deadlineObject = &#123; timeRemaining, didTimeout: false,&#125;;function ensureHostCallbackIsScheduled() &#123; // 正在执行工作 if (isPerformingWork) &#123; return; &#125; // 使用列表中最先超时的回调 var timesOutAt = firstCallbackNode.timesOutAt; if (!isHostCallbackScheduled) &#123; isHostCallbackScheduled = true; &#125; else &#123; // 取消回调 cancelCallback(); &#125; requestCallback(flushWork, timesOutAt);&#125;// 刷新第一次回调function flushFirstCallback(node) &#123; var flushedNode = firstCallbackNode; // 在调用回调之前从列表中移除该节点。这样，即使回调抛出, 列表也处于一致状态。 var next = firstCallbackNode.next; if (firstCallbackNode === next) &#123; // 这是列表中的最后一个回调。 firstCallbackNode = null; next = null; &#125; else &#123; var previous = firstCallbackNode.previous; firstCallbackNode = previous.next = next; next.previous = previous; &#125; flushedNode.next = flushedNode.previous = null; // 现在调用回调是安全的。 var callback = flushedNode.callback; callback(deadlineObject);&#125;function flushWork(didTimeout) &#123; isPerformingWork = true; deadlineObject.didTimeout = didTimeout; try &#123; if (didTimeout) &#123; // Flush all the timed out callbacks without yielding. while (firstCallbackNode !== null) &#123; // Read the current time. Flush all the callbacks that expire at or // earlier than that time. Then read the current time again and repeat. // This optimizes for as few performance.now calls as possible. var currentTime = getCurrentTime(); if (firstCallbackNode.timesOutAt &lt;= currentTime) &#123; do &#123; flushFirstCallback(); &#125; while ( firstCallbackNode !== null &amp;&amp; firstCallbackNode.timesOutAt &lt;= currentTime ); continue; &#125; break; &#125; &#125; else &#123; // Keep flushing callbacks until we run out of time in the frame. if (firstCallbackNode !== null) &#123; do &#123; flushFirstCallback(); &#125; while ( firstCallbackNode !== null &amp;&amp; getFrameDeadline() - getCurrentTime() &gt; 0 ); &#125; &#125; &#125; finally &#123; isPerformingWork = false; if (firstCallbackNode !== null) &#123; // There's still work remaining. Request another callback. ensureHostCallbackIsScheduled(firstCallbackNode); &#125; else &#123; isHostCallbackScheduled = false; &#125; &#125;&#125;// 调度任务，这是一个不稳定 apifunction unstable_scheduleWork(callback, options) &#123; var currentTime = getCurrentTime(); var timesOutAt; if ( options !== undefined &amp;&amp; options !== null &amp;&amp; options.timeout !== null &amp;&amp; options.timeout !== undefined ) &#123; // 根据传入的 timeout 计算超时 timesOutAt = currentTime + options.timeout; &#125; else &#123; // 使用默认常量计算超时 timesOutAt = currentTime + DEFERRED_TIMEOUT; &#125; var newNode = &#123; callback, timesOutAt, next: null, previous: null, &#125;; // 将新回调插入列表中, 并按其超时顺序排序 if (firstCallbackNode === null) &#123; // 这是列表中的第一个回调 firstCallbackNode = newNode.next = newNode.previous = newNode; ensureHostCallbackIsScheduled(firstCallbackNode); &#125; else &#123; var next = null; var node = firstCallbackNode; do &#123; if (node.timesOutAt &gt; timesOutAt) &#123; // 在此之前, 新的回调超时 next = node; break; &#125; node = node.next; &#125; while (node !== firstCallbackNode); if (next === null) &#123; // 找不到稍后超时的回调, 这意味着新的回调在列表中具有最新的超时。 next = firstCallbackNode; &#125; else if (next === firstCallbackNode) &#123; // 新回调在整个列表中具有最早的超时。 firstCallbackNode = newNode; ensureHostCallbackIsScheduled(firstCallbackNode); &#125; var previous = next.previous; previous.next = next.previous = newNode; newNode.next = next; newNode.previous = previous; &#125; return newNode;&#125;function unstable_cancelScheduledWork(callbackNode) &#123; var next = callbackNode.next; if (next === null) &#123; // Already cancelled. return; &#125; if (next === callbackNode) &#123; // This is the only scheduled callback. Clear the list. firstCallbackNode = null; &#125; else &#123; // Remove the callback from its position in the list. if (callbackNode === firstCallbackNode) &#123; firstCallbackNode = next; &#125; var previous = callbackNode.previous; previous.next = next; next.previous = previous; &#125; callbackNode.next = callbackNode.previous = null;&#125;// The remaining code is essentially a polyfill for requestIdleCallback. It// works by scheduling a requestAnimationFrame, storing the time for the start// of the frame, then scheduling a postMessage which gets scheduled after paint.// Within the postMessage handler do as much work as possible until time + frame// rate. By separating the idle call into a separate event tick we ensure that// layout, paint and other browser work is counted against the available time.// The frame rate is dynamically adjusted.// We capture a local reference to any global, in case it gets polyfilled after// this module is initially evaluated. We want to be using a// consistent implementation.var localDate = Date;// This initialization code may run even on server environments if a component// just imports ReactDOM (e.g. for findDOMNode). Some environments might not// have setTimeout or clearTimeout. However, we always expect them to be defined// on the client. https://github.com/facebook/react/pull/13088var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;// We don't expect either of these to necessarily be defined, but we will error// later if they are missing on the client.var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;var getCurrentTime;// requestAnimationFrame does not run when the tab is in the background. If// we're backgrounded we prefer for that work to happen so that the page// continues to load in the background. So we also schedule a 'setTimeout' as// a fallback.// TODO: Need a better heuristic for backgrounded work.var ANIMATION_FRAME_TIMEOUT = 100;var rAFID;var rAFTimeoutID;var requestAnimationFrameWithTimeout = function(callback) &#123; // schedule rAF and also a setTimeout rAFID = localRequestAnimationFrame(function(timestamp) &#123; // cancel the setTimeout localClearTimeout(rAFTimeoutID); callback(timestamp); &#125;); rAFTimeoutID = localSetTimeout(function() &#123; // cancel the requestAnimationFrame localCancelAnimationFrame(rAFID); callback(getCurrentTime()); &#125;, ANIMATION_FRAME_TIMEOUT);&#125;;if (hasNativePerformanceNow) &#123; var Performance = performance; getCurrentTime = function() &#123; return Performance.now(); &#125;;&#125; else &#123; getCurrentTime = function() &#123; return localDate.now(); &#125;;&#125;var requestCallback;var cancelCallback;var getFrameDeadline;if (typeof window === 'undefined') &#123; // 非浏览器环境 var timeoutID = -1; requestCallback = function(callback, absoluteTimeout) &#123; timeoutID = setTimeout(callback, 0, true); &#125;; cancelCallback = function() &#123; clearTimeout(timeoutID); &#125;; getFrameDeadline = function() &#123; return 0; &#125;;&#125; else if (window._schedMock) &#123; // 动态注入, 仅用于测试目的。 var impl = window._schedMock; requestCallback = impl[0]; cancelCallback = impl[1]; getFrameDeadline = impl[2];&#125; else &#123; if (typeof console !== 'undefined') &#123; if (typeof localRequestAnimationFrame !== 'function') &#123; console.error( "This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills', ); &#125; if (typeof localCancelAnimationFrame !== 'function') &#123; console.error( "This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills', ); &#125; &#125; var scheduledCallback = null; // 是否在执行空闲期回调 var isIdleScheduled = false; var timeoutTime = -1; var isAnimationFrameScheduled = false; var isPerformingIdleWork = false; var frameDeadline = 0; // 用启发式跟踪法，从30fps（即30帧）开始调整得到的更适于当前环境的一帧限制时间； var previousFrameTime = 33; var activeFrameTime = 33; getFrameDeadline = function() &#123; return frameDeadline; &#125;; // We use the postMessage trick to defer idle work until after the repaint. var messageKey = '__reactIdleCallback$' + Math.random() .toString(36) .slice(2); // 空闲期回调 var idleTick = function(event) &#123; if (event.source !== window || event.data !== messageKey) &#123; return; &#125; // 重置为false，表明可以调用空闲期回调 isIdleScheduled = false; var currentTime = getCurrentTime(); var didTimeout = false; if (frameDeadline - currentTime &lt;= 0) &#123; // 帧到期时间小于当前时间，说明已过期 if (timeoutTime !== -1 &amp;&amp; timeoutTime &lt;= currentTime) &#123; // 此帧已过期，且发生任务处理函数（执行具体任务，传入的回调）的超时 // 需要执行任务处理，下文将调用； didTimeout = true; &#125; else &#123; // 帧已过期，但没有发生任务处理函数的超时，暂时不调用任务处理函数 if (!isAnimationFrameScheduled) &#123; // 当前没有调度别的帧回调函数 // 调度下一帧 isAnimationFrameScheduled = true; requestAnimationFrameWithTimeout(animationTick); &#125; // Exit without invoking the callback. return; &#125; &#125; // 缓存的任务处理函数 timeoutTime = -1; var callback = scheduledCallback; scheduledCallback = null; if (callback !== null) &#123; isPerformingIdleWork = true; try &#123; // 执行回调 callback(didTimeout); &#125; finally &#123; isPerformingIdleWork = false; &#125; &#125; &#125;; // Assumes that we have addEventListener in this environment. Might need // something better for old IE. window.addEventListener('message', idleTick, false); // 帧回调 var animationTick = function(rafTime) &#123; isAnimationFrameScheduled = false; var nextFrameTime = rafTime - frameDeadline + activeFrameTime; if ( nextFrameTime &lt; activeFrameTime &amp;&amp; previousFrameTime &lt; activeFrameTime ) &#123; if (nextFrameTime &lt; 8) &#123; // Defensive coding. We don't support higher frame rates than 120hz. // If we get lower than that, it is probably a bug. nextFrameTime = 8; &#125; // If one frame goes long, then the next one can be short to catch up. // If two frames are short in a row, then that's an indication that we // actually have a higher frame rate than what we're currently optimizing. // We adjust our heuristic dynamically accordingly. For example, if we're // running on 120hz display or 90hz VR display. // Take the max of the two in case one of them was an anomaly due to // missed frame deadlines. activeFrameTime = nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime; &#125; else &#123; previousFrameTime = nextFrameTime; &#125; frameDeadline = rafTime + activeFrameTime; if (!isIdleScheduled) &#123; // 不在执行空闲期回调，表明可以调用空闲期回调 isIdleScheduled = true; window.postMessage(messageKey, '*'); &#125; &#125;; // 自定义 模拟requestIdleCallback requestCallback = function(callback, absoluteTimeout) &#123; // 回调函数 scheduledCallback = callback; timeoutTime = absoluteTimeout; if (isPerformingIdleWork) &#123; // 如果我们已经在执行空闲工作, 则必须抛出错误。 // 不要等待下一帧。在新事件中继续尽快工作 ASAP。 window.postMessage(messageKey, '*'); &#125; else if (!isAnimationFrameScheduled) &#123; // 如果当前没有调度帧回调函数，我们需要进行一个调度帧回调函数 // TODO: rAF 仍是 setTimeout isAnimationFrameScheduled = true; // 初始开始执行帧回调 requestAnimationFrameWithTimeout(animationTick); &#125; &#125;; cancelCallback = function() &#123; scheduledCallback = null; isIdleScheduled = false; timeoutTime = -1; &#125;;&#125;export &#123; unstable_scheduleWork, unstable_cancelScheduledWork, getCurrentTime as unstable_now,&#125;; Fiber与组件我们已经知道了Fiber的功能及其主要特点，那么其如何和组件联系，并且如何实现效果的呢，以下几点可以概括： React应用中的基础单元是组件，应用以组件树形式组织，渲染组件； Fiber调和器基础单元则是fiber（调和单元），应用以fiber树形式组织，应用Fiber算法； 组件树和fiber树结构对应，一个组件实例有一个对应的fiber实例； Fiber负责整个应用层面的调和，fiber实例负责对应组件的调和； 注意Fiber与fiber的区别，Fiber是指调和器算法，fiber则是调和器算法组成单元，和组件与应用关系类似，每一个组件实例会有对应的fiber实例负责该组件的调和。 Fiber数据结构截止目前，我们对Fiber应该有了初步的了解，在具体介绍Fiber的实现与架构之前，准备先简单介绍一下Fiber的数据结构，数据结构能一定程度反映其整体工作架构。其实，一个fiber就是一个JavaScript对象，以键值对形式存储了一个关联组件的信息，包括组件接收的props，维护的state，最后需要渲染出的内容等。接下来我们将介Fiber对象的主要属性。 FiberRoot 对象FiberRoot 对象主要用来管理组件树组件的更新进程，同时记录组件树挂载的DOM容器相关信息。123456789101112131415161718192021222324252627282930313233343536373839export type FiberRoot = &#123; // fiber节点的容器元素相关信息，通常会直接传入容器元素 containerInfo: any, // 仅用于持久更新 pendingChildren: any, // 当前fiber树中激活状态（正在处理）的fiber节点 current: Fiber, // 从提交中暂停的最早和最新的优先级级别 earliestSuspendedTime: ExpirationTime, latestSuspendedTime: ExpirationTime, // 不知道要暂停的最早和最新的优先级级别。 earliestPendingTime: ExpirationTime, latestPendingTime: ExpirationTime, // 由已解决的承诺 pinged 的最新优先级级别, 并可以重试 latestPingedTime: ExpirationTime, // 如果引发错误, 并且队列中没有其他更新, 我们尝试在处理前再一次从根中渲染错误。 didError: boolean, pendingCommitExpirationTime: ExpirationTime, // 已完成的工作正在进行的 HostRoot 已准备好提交 finishedWork: Fiber | null, // setTimeout 返回的超时句柄。如果它被一个新的取代了。用于取消挂起的超时, timeoutHandle: TimeoutHandle | NoTimeout, // 顶部上下文对象, 由 renderSubtreeIntoContainer 使用 context: Object | null, pendingContext: Object | null, // 确定我们是否应该尝试在初始加载使用 hydrate +hydrate: boolean, // 此节点剩余的任务到期时间 // TODO: Lift this into the renderer nextExpirationTimeToWorkOn: ExpirationTime, expirationTime: ExpirationTime, // 顶级批次的列表。此列表指示是否应推迟提交，也包含完成回调。 // TODO: Lift this into the renderer firstBatch: Batch | null, // 多组件树FirberRoot对象以单链表存储链接，指向下一个需要调度的FiberRoot nextScheduledRoot: FiberRoot | null,&#125;; 创建FiberRoot实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485export function createFiberRoot( containerInfo: any, isAsync: boolean, hydrate: boolean,): FiberRoot &#123; // 创建初始根组件对应的fiber实例 const uninitializedFiber = createHostRootFiber(isAsync); let root; if (enableSchedulerTracing) &#123; root = (&#123; // 根组件对应的fiber实例，一直用它 current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, interactionThreadID: unstable_getThreadID(), memoizedInteractions: new Set(), pendingInteractionMap: new Map(), &#125;: FiberRoot); &#125; else &#123; root = (&#123; current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, &#125;: BaseFiberRootProperties); &#125; // 组件树根组件fiber实例的stateNode指向FiberRoot对象 uninitializedFiber.stateNode = root; return ((root: any): FiberRoot);&#125;// 创建返回一个初始根组件对应的fiber实例export function createHostRootFiber(isAsync: boolean): Fiber &#123; let mode = isAsync ? AsyncMode | StrictMode : NoContext; if (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123; // Always collect profile timings when DevTools are present. // This enables DevTools to start capturing timing at any point– // Without some nodes in the tree having empty base times. mode |= ProfileMode; &#125; // 创建fiber return createFiber(HostRoot, null, null, mode);&#125; Fiber对象Fiber对象的定义在packages/react-reconciler/src/ReactFiber.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// 一个Fiber对象作用于一个组件export type Fiber = &#123;| // 标记fiber类型tag tag: TypeOfWork, // 唯一标识 key: null | string, // fiber对应的function/class/module类型组件名. type: any, // fiber所在组件树的根组件FiberRoot对象 stateNode: any, // 处理完当前fiber后返回的fiber， // 返回当前fiber所在fiber树的父级fiber实例 return: Fiber | null, // fiber树结构相关链接 child: Fiber | null, sibling: Fiber | null, index: number, // The ref last used to attach this node. // I'll avoid adding an owner field for prod and model that as functions. ref: null | (((handle: mixed) =&gt; void) &amp; &#123;_stringRef: ?string&#125;) | RefObject, // 当前处理过程中的组件props对象 pendingProps: any, // This type will be more specific once we overload the tag. // 缓存的之前组件props对象 memoizedProps: any, // The props used to create the output. // 组件状态更新及对应回调函数的存储队列 updateQueue: UpdateQueue&lt;any&gt; | null, // The state used to create the output memoizedState: any, // A linked-list of contexts that this fiber depends on firstContextDependency: ContextDependency&lt;mixed&gt; | null, // Bitfield that describes properties about the fiber and its subtree. E.g. // the AsyncMode flag indicates whether the subtree should be async-by- // default. When a fiber is created, it inherits the mode of its // parent. Additional flags can be set at creation time, but after that the // value should remain unchanged throughout the fiber's lifetime, particularly // before its child fibers are created. mode: TypeOfMode, // Effect effectTag: TypeOfSideEffect, // Singly linked list fast path to the next fiber with side-effects. nextEffect: Fiber | null, // The first and last fiber with side-effect within this subtree. This allows // us to reuse a slice of the linked list when we reuse the work done within // this fiber. firstEffect: Fiber | null, lastEffect: Fiber | null, // 更新任务的最晚执行时间 expirationTime: ExpirationTime, // This is used to quickly determine if a subtree has no pending changes. childExpirationTime: ExpirationTime, // fiber的版本池，即记录fiber更新过程，便于恢复 alternate: Fiber | null, // Conceptual aliases // workInProgress : Fiber -&gt; alternate The alternate used for reuse happens // to be the same as work in progress. // Time spent rendering this Fiber and its descendants for the current update. // This tells us how well the tree makes use of sCU for memoization. // It is reset to 0 each time we render and only updated when we don't bailout. // This field is only set when the enableProfilerTimer flag is enabled. actualDuration?: number, // If the Fiber is currently active in the "render" phase, // This marks the time at which the work began. // This field is only set when the enableProfilerTimer flag is enabled. actualStartTime?: number, // Duration of the most recent render time for this Fiber. // This value is not updated when we bailout for memoization purposes. // This field is only set when the enableProfilerTimer flag is enabled. selfBaseDuration?: number, // Sum of base times for all descedents of this Fiber. // This value bubbles up during the "complete" phase. // This field is only set when the enableProfilerTimer flag is enabled. treeBaseDuration?: number, // Conceptual aliases // workInProgress : Fiber -&gt; alternate The alternate used for reuse happens // to be the same as work in progress. // __DEV__ only _debugID?: number, _debugSource?: Source | null, _debugOwner?: Fiber | null, _debugIsCurrentlyTiming?: boolean,|&#125;; type &amp; key：同React元素的值； type：描述fiber对应的React组件； 对于组合组件：值为function或class组件本身； 对于原生组件（div等）：值为该元素类型字符串； key：调和阶段，标识fiber，以检测是否可重用该fiber实例； child &amp; sibling：组件树，对应生成fiber树，类比的关系； pendingProps &amp; memoizedProps：分别表示组件当前传入的及之前的props； return：返回当前fiber所在fiber树的父级fiber实例，即当前组件的父组件对应的fiber； alternate：fiber的版本池，即记录fiber更新过程，便于恢复重用； workInProgress：正在处理的fiber，概念上叫法，实际上没有此属性； alternate fiber可以理解为一个fiber版本池，用于交替记录组件更新（切分任务后变成多阶段更新）过程中fiber的更新，因为在组件更新的各阶段，更新前及更新过程中fiber状态并不一致，在需要恢复时（如，发生冲突），即可使用另一者直接回退至上一版本fiber。 使用alternate属性双向连接一个当前fiber和其work-in-progress，当前fiber实例的alternate属性指向其work-in-progress，work-in-progress的alternate属性指向当前稳定fiber； 当前fiber的替换版本是其work-in-progress，work-in-progress的交替版本是当前fiber； 当work-in-progress更新一次后，将同步至当前fiber，然后继续处理，同步直至任务完成； work-in-progress指向处理过程中的fiber，而当前fiber总是维护处理完成的最新版本的fiber。 创建Fiber实例创建fiber实例即返回一个带有上一小节描述的诸多属性的JavaScript对象，FiberNode即根据传入的参数构造返回一个初始化的对象：123456789const createFiber = function( tag: TypeOfWork, pendingProps: mixed, key: null | string, mode: TypeOfMode,): Fiber &#123; // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors return new FiberNode(tag, pendingProps, key, mode);&#125;; 创建alternate fiber以处理任务的实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 创建一个alternate fiber处理任务export function createWorkInProgress( current: Fiber, pendingProps: any, expirationTime: ExpirationTime,): Fiber &#123; let workInProgress = current.alternate; if (workInProgress === null) &#123; // We use a double buffering pooling technique because we know that we'll // only ever need at most two versions of a tree. We pool the "other" unused // node that we're free to reuse. This is lazily created to avoid allocating // extra objects for things that are never updated. It also allow us to // reclaim the extra memory if needed. workInProgress = createFiber( current.tag, pendingProps, current.key, current.mode, ); workInProgress.type = current.type; workInProgress.stateNode = current.stateNode; if (__DEV__) &#123; // DEV-only fields workInProgress._debugID = current._debugID; workInProgress._debugSource = current._debugSource; workInProgress._debugOwner = current._debugOwner; &#125; workInProgress.alternate = current; current.alternate = workInProgress; &#125; else &#123; workInProgress.pendingProps = pendingProps; // We already have an alternate. // Reset the effect tag. workInProgress.effectTag = NoEffect; // The effect list is no longer valid. workInProgress.nextEffect = null; workInProgress.firstEffect = null; workInProgress.lastEffect = null; if (enableProfilerTimer) &#123; // We intentionally reset, rather than copy, actualDuration &amp; actualStartTime. // This prevents time from endlessly accumulating in new commits. // This has the downside of resetting values for different priority renders, // But works for yielding (the common case) and should support resuming. workInProgress.actualDuration = 0; workInProgress.actualStartTime = -1; &#125; &#125; // Don't touching the subtree's expiration time, which has not changed. workInProgress.childExpirationTime = current.childExpirationTime; if (pendingProps !== current.pendingProps) &#123; // This fiber has new props. workInProgress.expirationTime = expirationTime; &#125; else &#123; // This fiber's props have not changed. workInProgress.expirationTime = current.expirationTime; &#125; workInProgress.child = current.child; workInProgress.memoizedProps = current.memoizedProps; workInProgress.memoizedState = current.memoizedState; workInProgress.updateQueue = current.updateQueue; workInProgress.firstContextDependency = current.firstContextDependency; // These will be overridden during the parent's reconciliation workInProgress.sibling = current.sibling; workInProgress.index = current.index; workInProgress.ref = current.ref; if (enableProfilerTimer) &#123; workInProgress.selfBaseDuration = current.selfBaseDuration; workInProgress.treeBaseDuration = current.treeBaseDuration; &#125; return workInProgress;&#125; Fiber类型上一小节，Fiber对象中有个tag属性，标记fiber类型，而fiber实例是和组件对应的，所以其类型基本上对应于组件类型，在packages/shared/ReactWorkTags.js中：12345678910111213141516171819export type TypeOfWork = | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16;export const FunctionalComponent = 0; // 函数式组件export const FunctionalComponentLazy = 1;export const ClassComponent = 2; // Class类组件export const ClassComponentLazy = 3;export const IndeterminateComponent = 4; // Before we know whether it is functional or classexport const HostRoot = 5; // 组件树根组件，可以嵌套export const HostPortal = 6; // 子树。可以是一个入口点不同的渲染器。export const HostComponent = 7; // 标准组件，如地div， span等export const HostText = 8; // 文本export const Fragment = 9; // 片段export const Mode = 10;export const ContextConsumer = 11;export const ContextProvider = 12;export const ForwardRef = 13;export const ForwardRefLazy = 14;export const Profiler = 15;export const PlaceholderComponent = 16; // placeholder（占位符） 在调度执行任务的时候会根据不同类型fiber，即fiber.tag值进行不同处理。 FiberRoot对象FiberRoot对象，主要用来管理组件树组件的更新进程，同时记录组件树挂载的DOM容器相关信息，在packages/react-reconciler/src/ReactFiberRoot.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export type FiberRoot = &#123; // fiber节点的容器元素相关信息，通常会直接传入容器元素 containerInfo: any, // Used only by persistent updates. pendingChildren: any, // 当前fiber树中激活状态（正在处理）的fiber节点， current: Fiber, // The following priority levels are used to distinguish between 1) // uncommitted work, 2) uncommitted work that is suspended, and 3) uncommitted // work that may be unsuspended. We choose not to track each individual // pending level, trading granularity for performance. // // The earliest and latest priority levels that are suspended from committing. earliestSuspendedTime: ExpirationTime, latestSuspendedTime: ExpirationTime, // The earliest and latest priority levels that are not known to be suspended. earliestPendingTime: ExpirationTime, latestPendingTime: ExpirationTime, // The latest priority level that was pinged by a resolved promise and can // be retried. latestPingedTime: ExpirationTime, // If an error is thrown, and there are no more updates in the queue, we try // rendering from the root one more time, synchronously, before handling // the error. didError: boolean, pendingCommitExpirationTime: ExpirationTime, // 准备好提交的已处理完成的work-in-progress finishedWork: Fiber | null, // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if // it's superseded by a new one. timeoutHandle: TimeoutHandle | NoTimeout, // Top context object, used by renderSubtreeIntoContainer context: Object | null, pendingContext: Object | null, // Determines if we should attempt to hydrate on the initial mount +hydrate: boolean, // Remaining expiration time on this root. // TODO: Lift this into the renderer nextExpirationTimeToWorkOn: ExpirationTime, expirationTime: ExpirationTime, // List of top-level batches. This list indicates whether a commit should be // deferred. Also contains completion callbacks. // TODO: Lift this into the renderer firstBatch: Batch | null, // 多组件树FirberRoot对象以单链表存储链接，指向下一个需要调度的FiberRoot nextScheduledRoot: FiberRoot | null,&#125;; 创建FiberRoot实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123; ClassComponent, HostRoot, Mode,&#125; from 'shared/ReactTypeOfWork';// 创建返回一个初始根组件对应的fiber实例export function createHostRootFiber(isAsync: boolean): Fiber &#123; let mode = isAsync ? AsyncMode | StrictMode : NoContext; if (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123; // Always collect profile timings when DevTools are present. // This enables DevTools to start capturing timing at any point– // Without some nodes in the tree having empty base times. mode |= ProfileMode; &#125; // 创建fiber return createFiber(HostRoot, null, null, mode);&#125;export function createFiberRoot( containerInfo: any, isAsync: boolean, hydrate: boolean,): FiberRoot &#123; // 创建初始根组件对应的fiber实例 const uninitializedFiber = createHostRootFiber(isAsync); // 组件树根组件的FiberRoot对象 const root = &#123; // 根组件对应的fiber实例 current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, &#125;; // 组件树根组件fiber实例的stateNode指向FiberRoot对象 uninitializedFiber.stateNode = root; return root;&#125; ReactChildFiber在生成组件树的FiberRoot对象后，会为子组件生成各自的fiber实例，这一部分由ReactChildFiber模块实现，在packages/react-reconciler/src/ReactChildFiber.js中： 1234// 调和（处理更新）子fibersexport const reconcileChildFibers = ChildReconciler(true);// 挂载（初始化）子fibersexport const mountChildFibers = ChildReconciler(false); 而ChildReconciler方法所做的则是根据传入参数判断是调用初始化子组件fibers逻辑还是执行调和已有子组件fibers逻辑。 ChildReconciler方法，返回reconcileChildFibers方法： 判断子级传递内容的数据类型，执行不同的处理，这也对应着我们写React组件时传递props.children时，其类型可以是对象或数组，字符串，是数字等； 然后具体根据子组件类型，调用不同的具体调和处理函数； 最后返回根据子组件创建或更新得到的fiber实例； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126function reconcileChildFibers( returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any, expirationTime: ExpirationTime, ): Fiber | null &#123; // This function is not recursive. // If the top level item is an array, we treat it as a set of children, // not as a fragment. Nested arrays on the other hand will be treated as // fragment nodes. Recursion happens at the normal flow. // Handle top level unkeyed fragments as if they were arrays. // This leads to an ambiguity between &lt;&gt;&#123;[...]&#125;&lt;/&gt; and &lt;&gt;...&lt;/&gt;. // We treat the ambiguous cases above the same. const isUnkeyedTopLevelFragment = typeof newChild === 'object' &amp;&amp; newChild !== null &amp;&amp; newChild.type === REACT_FRAGMENT_TYPE &amp;&amp; newChild.key === null; if (isUnkeyedTopLevelFragment) &#123; newChild = newChild.props.children; &#125; // Handle object types const isObject = typeof newChild === 'object' &amp;&amp; newChild !== null; if (isObject) &#123; // 子组件实例类型，以Symbol符号表示的 switch (newChild.$$typeof) &#123; case REACT_ELEMENT_TYPE: return placeSingleChild( reconcileSingleElement( returnFiber, currentFirstChild, newChild, expirationTime, ), ); // React组件调用 case REACT_PORTAL_TYPE: return placeSingleChild( reconcileSinglePortal( returnFiber, currentFirstChild, newChild, expirationTime, ), ); &#125; &#125; if (typeof newChild === 'string' || typeof newChild === 'number') &#123; return placeSingleChild( reconcileSingleTextNode( returnFiber, currentFirstChild, '' + newChild, expirationTime, ), ); &#125; if (isArray(newChild)) &#123; return reconcileChildrenArray( returnFiber, currentFirstChild, newChild, expirationTime, ); &#125; if (getIteratorFn(newChild)) &#123; return reconcileChildrenIterator( returnFiber, currentFirstChild, newChild, expirationTime, ); &#125; if (isObject) &#123; throwOnInvalidObjectType(returnFiber, newChild); &#125; if (__DEV__) &#123; if (typeof newChild === 'function') &#123; warnOnFunctionType(); &#125; &#125; if (typeof newChild === 'undefined' &amp;&amp; !isUnkeyedTopLevelFragment) &#123; // If the new child is undefined, and the return fiber is a composite // component, throw an error. If Fiber return types are disabled, // we already threw above. switch (returnFiber.tag) &#123; case ClassComponent: case ClassComponentLazy: &#123; if (__DEV__) &#123; const instance = returnFiber.stateNode; if (instance.render._isMockFunction) &#123; // We allow auto-mocks to proceed as if they're returning null. break; &#125; &#125; &#125; // Intentionally fall through to the next case, which handles both // functions and classes // eslint-disable-next-lined no-fallthrough case FunctionalComponent: &#123; const Component = returnFiber.type; invariant( false, '%s(...): Nothing was returned from render. This usually means a ' + 'return statement is missing. Or, to render nothing, ' + 'return null.', Component.displayName || Component.name || 'Component', ); &#125; &#125; &#125; // Remaining cases are all treated as empty. return deleteRemainingChildren(returnFiber, currentFirstChild); &#125; return reconcileChildFibers;&#125; Fiber架构在学习Fiber的时候，我尝试去阅读源码，发现通过这种方式很难快速理解，学习Fiber，而先了解调和器是干什么的及调和器在React中的存在形式，然后再学习Fiber的结构及算法实现思路，明白从组件被定义到渲染至页面它需要做什么，这也是本篇文章的组织形式。 优先级（ExpirationTime VS PriorityLevel）我们已经知道Fiber可以切分任务并设置不同优先级，那么是如何实现划分优先级的呢，其表现形式什么呢？ ExpirationTimeFiber切分任务并调用requestIdleCallback和requestAnimationFrameAPI，保证渲染任务和其他任务，在不影响应用交互，不掉帧的前提下，稳定执行，而实现调度的方式正是给每一个fiber实例设置到期执行时间，不同时间即代表不同优先级，到期时间越短，则代表优先级越高，需要尽早执行。 所谓的到期时间（ExpirationTime），是相对于调度器初始调用的起始时间而言的一个时间段；调度器初始调用后的某一段时间内，需要调度完成这项更新，这个时间段长度值就是到期时间值。 Fiber提供ReactFiberExpirationTime模块实现到期时间的定义，在packages/react-reconciler/src/ReactFiberExpirationTime.js中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export const NoWork = 0; // 没有任务等待处理export const Sync = 1; // 同步模式，立即处理任务export const Never = MAX_SIGNED_31_BIT_INT; // 1073741823 Max 31: Math.pow(2, 30) - 1 const UNIT_SIZE = 10; // 过期时间单元（ms）const MAGIC_NUMBER_OFFSET = 2; // 到期时间偏移量// 以ExpirationTime特定单位（1单位=10ms）表示的到期执行时间export function msToExpirationTime(ms: number): ExpirationTime &#123; // 总是增加一个偏移量，在ms&lt;10时与Nowork模式进行区别 return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;&#125;// 以毫秒表示的到期执行时间export function expirationTimeToMs(expirationTime: ExpirationTime): number &#123; return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;&#125;// 向上取整（整数单位到期执行时间）// precision范围精度：弥补任务执行时间误差function ceiling(num: number, precision: number): number &#123; return (((num / precision) | 0) + 1) * precision;&#125;// 计算处理误差时间在内的到期时间function computeExpirationBucket( currentTime, expirationInMs, bucketSizeMs,): ExpirationTime &#123; return ( MAGIC_NUMBER_OFFSET + ceiling( currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE, ) );&#125;export const LOW_PRIORITY_EXPIRATION = 5000;export const LOW_PRIORITY_BATCH_SIZE = 250;export function computeAsyncExpiration( currentTime: ExpirationTime,): ExpirationTime &#123; return computeExpirationBucket( currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE, );&#125;// We intentionally set a higher expiration time for interactive updates in// dev than in production.//// If the main thread is being blocked so long that you hit the expiration,// it's a problem that could be solved with better scheduling.//// People will be more likely to notice this and fix it with the long// expiration time in development.//// In production we opt for better UX at the risk of masking scheduling// problems, by expiring fast.export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;export const HIGH_PRIORITY_BATCH_SIZE = 100;export function computeInteractiveExpiration(currentTime: ExpirationTime) &#123; return computeExpirationBucket( currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE, );&#125; 该模块提供的功能主要有： Sync：同步模式，在UI线程立即执行此类任务，如动画反馈等； 异步模式： 转换：到期时间特定单位和时间单位（ms）的相互转换； 计算：计算包含允许误差在内的到期时间； PriorityLevel其实在15.x版本中出现了对于任务的优先层级划分，ReactPriorityLevel模块，在/src/renderers/shared/fiber/ReactPriorityLevel.js中：12345678910export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;module.exports = &#123; NoWork: 0, // No work is pending. SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects. AnimationPriority: 2, // Needs to complete before the next frame. HighPriority: 3, // Interaction that needs to complete pretty soon to feel responsive. LowPriority: 4, // Data fetching, or result from updating stores. OffscreenPriority: 5, // Won't be visible but do the work in case it becomes visible.&#125;; 相对于PriorityLevel的简单层级划分，在16.x版本中使用的则是ExpirationTime的到期时间方式表示任务的优先级，可以更好的对任务进行切分，调度。 调度器（Scheduler）前面介绍调和器主要作用就是在组件状态变更时，调用组件树各组件的render方法，渲染，卸载组件，而Fiber使得应用可以更好的协调不同任务的执行，调和器内关于高效协调的实现，我们可以称它为调度器（Scheduler）。 顾名思义，调度器即调度资源以执行指定任务，React应用中应用组件的更新与渲染，需要占用系统CPU资源，如果不能很好的进行资源平衡，合理调度，优化任务执行策略，那很容易造成CPU这一紧缺资源的消耗和浪费，容易造成页面卡顿，动画掉帧，组件更新异常等诸多问题，就像城市交通调度一样，如果不能有效调度，交通状况很可能将拥堵不堪。 在React 15.x版本中，组件的状态变更将直接导致其子组件树的重新渲染，新版本Fiber算法将在调度器方面进行全面改进，主要的关注点是： 合并多次更新：没有必要在组件的每一个状态变更时都立即触发更新任务，有些中间状态变更其实是对更新任务所耗费资源的浪费，就比如用户发现错误点击时快速操作导致组件某状态从A至B再至C，这中间的B状态变更其实对于用户而言并没有意义，那么我们可以直接合并状态变更，直接从A至C只触发一次更新； 任务优先级：不同类型的更新有不同优先级，例如用户操作引起的交互动画可能需要有更好的体验，其优先级应该比完成数据更新高； 推拉式调度：基于推送的调度方式更多的需要开发者编码间接决定如何调度任务，而拉取式调度更方便React框架层直接进行全局自主调度； 源码在packages/react-reconciler/src/ReactFiberScheduler.js中： 1234567891011121314151617181920212223export &#123; requestCurrentTime, computeExpirationForFiber, captureCommitPhaseError, onUncaughtError, renderDidSuspend, renderDidError, retrySuspendedRoot, markLegacyErrorBoundaryAsFailed, isAlreadyFailedLegacyErrorBoundary, scheduleWork, requestWork, flushRoot, batchedUpdates, unbatchedUpdates, flushSync, flushControlled, deferredUpdates, syncUpdates, interactiveUpdates, flushInteractiveUpdates, computeUniqueAsyncExpiration,&#125;; 如上调度器主要输出API为实现调度任务，拉取更新，延迟更新等功能。 调度器与优先级调度器如何切分任务划分优先级的呢？在React调和算法中，任务由fiber实例描述，所以要划分任务优先级，等效于设置fiber的到期时间（expirationTime），调度器内提供了computeExpirationForFiber方法以计算某一个fiber的到期时间，源码在packages/react-reconciler/src/ReactFiberScheduler.js中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import &#123; NoWork, Sync, Never, msToExpirationTime, expirationTimeToMs, computeAsyncExpiration, computeInteractiveExpiration,&#125; from './ReactFiberExpirationTime';function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) &#123; let expirationTime; if (expirationContext !== NoWork) &#123; // An explicit expiration context was set; expirationTime = expirationContext; &#125; else if (isWorking) &#123; if (isCommitting) &#123; // 在提交阶段的更新任务 需要明确设置同步优先级（Sync Priority） expirationTime = Sync; &#125; else &#123; // 在渲染阶段发生的更新任务 // 需要设置为下一次渲染时间的到期时间优先级 expirationTime = nextRenderExpirationTime; &#125; &#125; else &#123; // No explicit expiration context was set, and we're not currently // performing work. Calculate a new expiration time. if (fiber.mode &amp; AsyncMode) &#123; if (isBatchingInteractiveUpdates) &#123; // This is an interactive update expirationTime = computeInteractiveExpiration(currentTime); &#125; else &#123; // This is an async update expirationTime = computeAsyncExpiration(currentTime); &#125; // If we're in the middle of rendering a tree, do not update at the same // expiration time that is already rendering. if (nextRoot !== null &amp;&amp; expirationTime === nextRenderExpirationTime) &#123; expirationTime += 1; &#125; &#125; else &#123; // 同步更新，设置为同步标记 expirationTime = Sync; &#125; &#125; if (isBatchingInteractiveUpdates) &#123; // This is an interactive update. Keep track of the lowest pending // interactive expiration time. This allows us to synchronously flush // all interactive updates when needed. if ( lowestPendingInteractiveExpirationTime === NoWork || expirationTime &gt; lowestPendingInteractiveExpirationTime ) &#123; lowestPendingInteractiveExpirationTime = expirationTime; &#125; &#125; return expirationTime;&#125; 若当前处于任务提交阶段（更新提交至DOM渲染）时，设置当前fiber到期时间为Sync，即同步执行模式； 若处于DOM渲染阶段时，则需要延迟此fiber任务，将fiber到期时间设置为下一次DOM渲染到期时间； 若不在任务执行阶段，则需重新设置fiber到期时间： 若明确设置useSyncScheduling且fiber.internalContextTag值不等于AsyncUpdates，则表明是同步模式，设置为Sync； 否则，调用computeAsyncExpiration方法重新计算此fiber的到期时间； 12345678910111213141516171819202122// 重新计算当前时间（ExpirationTime单位表示）function recalculateCurrentTime() &#123; const ms = now() - startTime; // ExpirationTime单位表示的当前时间 // 时间段值为 now() - startTime（起始时间） mostRecentCurrentTime = msToExpirationTime(ms); return mostRecentCurrentTime;&#125; // 计算异步任务的到期时间function computeAsyncExpiration() &#123; // 计算得到ExpirationTime单位的当前时间 // 聚合相似的更新在一起 // 更新应该在 ~1000ms，最多1200ms内完成 const currentTime = recalculateCurrentTime(); // 对于每个fiber的期望到期时间的增值，最大值为1000ms const expirationMs = 1000; // 到期时间的可接受误差时间，200ms const bucketSizeMs = 200; // 返回包含误差时间在内的到期时间 return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);&#125; 对于每一个fiber我们期望的到期时间参数是1000ms，另外由于任务执行时间误差，接受200ms误差，最后计算得到的到期时间默认返回值为ExpirationTime单位。 任务调度上一节介绍了调度器主要提供computeExpirationForFiber等方法支持计算任务优先级（到期时间），接下来介绍调度器如何调度任务。 React应用更新时，Fiber从当前处理节点，层层遍历至组件树根组件，然后开始处理更新，调用前面的requestIdleCallback等API执行更新处理。 主要调度逻辑实现在scheduleWork： 通过fiber.return属性，从当前fiber实例层层遍历至组件树根组件； 依次对每一个fiber实例进行到期时间判断，若大于传入的期望任务到期时间参数，则将其更新为传入的任务到期时间； 调用requestWork方法开始处理任务，并传入获取的组件树根组件FiberRoot对象和任务到期时间； 12 渲染与调和在调和阶段，不涉及任何DOM处理，在处理完更新后，需要渲染模块将更新渲染至DOM，这也是React应用中虚拟DOM（Virtual DOM）的概念，即所有的更新计算都基于虚拟DOM，计算完后才将优化后的更新渲染至真实DOM。Fiber使用requestIdleCallbackAPI更高效的执行渲染更新的任务，实现任务的切分。 本文不断更新中]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS系统使用指南]]></title>
    <url>%2F2018%2F08%2F11%2Fmacos-tutorial.html</url>
    <content type="text"><![CDATA[Mac OS是一套运行于苹果Macintosh系列电脑上的操作系统。Mac OS是首个在商用领域成功的图形用户界面操作系统。现行的最新的系统版本是OS X 10.12 ，且网上也有在PC上运行的Mac系统，简称 Mac PC。Mac系统是基于Unix内核的图形化操作系统；一般情况下在普通PC上无法安装的操作系统。由苹果公司自行开发。苹果机的操作系统已经到了OS 10，代号为MAC OS X(X为10的罗马数字写法），这是MAC电脑诞生15年来最大的变化。新系统非常可靠；它的许多特点和服务都体现了苹果公司的理念。另外，疯狂肆虐的电脑病毒几乎都是针对Windows的，由于MAC的架构与Windows不同，所以很少受到病毒的袭击。MAC OSX操作系统界面非常独特，突出了形象的图标和人机对话。苹果公司不仅自己开发系统，也涉及到硬件的开发。接下来，我们就总结下Mac OS常见的使用指南。 Mac电脑使用：您的安全性偏好设置仅允许安装来自App Store和被认可的开发者的应用（解决方法）1. 打开dock栏里面的“系统偏好设置”； 2. 在系统偏好设置里面，找到“安全性与隐私”选项； 3. 在安全性与隐私里面，找到左下角的锁型图标，然后点击锁，会弹出输入电脑开机密码的窗口，输入密码之后，点击“解锁”按钮，那个锁型变为开启的锁； 4. 解锁后，如果你的电脑里面在允许从以下位置下载应用有三个选项，就在允许从以下位置下载的应用选项中选择“任何来源”，在弹出的确认框里点击“允许来自任何来源”；如果你的电脑里面允许从以下位置下载的应用中只有两个选项，那你就直接去打开你刚才需要安装的那个程序的安装包，双击重新安装，会有一个提示框，也是提示允许来自任何来源安装的，然后就可以安装成功了，最后打开即可。 用终端连接远程服务器12345# 登录$ ssh -t root@121.199.61.169 -p 22# 退出$ control + d 隐藏/显示 隐藏文件12# 凡是前面带有小点的隐藏文件，或者是显示淡蓝色的文件都是隐藏文件$ shift + cmmand + .]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式开发指南]]></title>
    <url>%2F2018%2F08%2F10%2Fregular-expression-tutorial.html</url>
    <content type="text"><![CDATA[正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen。 使用技巧exec() 方法定义和用法exec() 方法用于检索字符串中的正则表达式的匹配。 语法12// string: 必需。要检索的字符串。RegExpObject.exec(string); 返回值返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 说明exec() 方法的功能非常强大，它是一个通用的方法，而且使用起来也比 test() 方法以及支持正则表达式的 String 对象的方法更为复杂。 如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。 但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。 提示和注释重要事项：如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。 提示：请注意，无论 RegExpObject 是否是全局模式，exec() 都会把完整的细节添加到它返回的数组中。这就是 exec() 与 String.match() 的不同之处，后者在全局模式下返回的信息要少得多。因此我们可以这么说，在循环中反复地调用 exec() 方法是唯一一种获得全局模式的完整模式匹配信息的方法。 ()和$1…$9的理解和使用()就是起到一个分组作用，将匹配到的放到mathches集合中，$相当于集合名字，1-9就相当于索引，$1…$9相当于对应索引的值。 示例一12345// 将yyyy-MM-dd格式的日期转换为yyyy年MM月dd日const str = "2018-07-02";const reg =/(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)/;const date = str.replace(reg,"$1年$2月$3日");console.log(date); // "2018年07月02日" 示例二12345// 将yyyy-MM-dd格式的日期转换为yyyy/MM/dd/const str = "2018-07-02";const reg =/(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)/;const date = str.replace(reg,"$1/$2/$3");console.log(date); // "2018/07/02" ^在[]里面和在[]外面如何区分^在[]里面123456789/[^0-9]/.test('abc') // true/[^0-9]/.test('123') // false``` 归纳：^在[]里面代表是非数字，所以它代表是非。**^在[]外面**``` js/^[0-9]/.test('abc') // false/^[0-9]/.test('1bc') // true 归纳：^在[]外面代表是为首的数字，所以它代表头。 ^在[]里面和在[]外面有一个记忆的方法：乌龟把头(^)缩进里面，变为无（非)头乌龟，乌龟把头(^)伸出来，变为头(首）领。]]></content>
      <categories>
        <category>regex</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发指南]]></title>
    <url>%2F2018%2F08%2F09%2Fwechat-public-development-tutorial.html</url>
    <content type="text"><![CDATA[微信浏览器？啊，它是什么，好不好用，能吃不？我记得有个说法是这么评价微信浏览器的，微信浏览器就是移动端IE6。是程序员就知道IE什么样，好不好用。面向IE开发，我们经常会写出稀奇古怪的bug代码，同样的，基于微信浏览器开发也会BUG百出。因此，很有必要整理一些基于微信浏览器的开发技巧和开发问题。 开发问题vue 路由采用 history 模式在IOS中签名失败 Android签名良好基于微信公众号开发，我们经常会使用到分享、上传图片等功能，然而这种种功能都需要微信签名。提到签名，我们应该就会遇到签名失败的情况。接下来我们说说 vue 路由采用 history 模式在IOS中签名失败，Android签名良好的情况。 原因history 模式下视图是通过 pushState 来切换的，但IOS手机在微信浏览器中记录的 URL 只会是第一次进入时的URL，所以在IOS中，无论你路由怎么切换。真实的URL都是第一次进入应用时的URL。 解决办法每次路由变化时都重新请求下签名，同时在路由钩子函数里改写一下路由： 123456// beforeRouterif (isWeixin() &amp;&amp; to.meta.wxSign &amp;&amp; to.path !== location.pathname) &#123; location.assign(window.location.protocol + '//' + window.location.host + to.fullPath)&#125; else &#123; next();&#125; 两（多）张两张二维码无法在同一屏幕视窗中共存同一屏幕视窗”是指微信内置浏览器中在当前的手机屏幕上显示的可见范围，我们发现，当同一同一屏幕视窗中存在两个或以上的二维码的时候，微信客户端就会识别错误，无论你按哪个二维码长按识别，识别出来都是同一个目标。这个问题在 iOS 版（iPhone）微信2.2及安卓版上均有。 原因长按的时候相当于将当前手机屏幕截屏，识别截屏后的图片，这样一张图片有两个二维码图的时候当然只会识别出一个。 解决办法不要将两个二维码共存在同一个页面中。 微信只调用相机不使用相册时，安卓会退出并刷新页面解决办法相机和相册两者都加上！ 本文持续更新中]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[package.json 文件中的 module 字段]]></title>
    <url>%2F2018%2F08%2F08%2Fpackage-json-module.html</url>
    <content type="text"><![CDATA[通常基于 NPM 托管的项目都会有一个 package.json 文件，它是项目的描述文件，它的内容是一个标准的 JSON 对象。相信大家对 package.json 常用配置肯定熟悉的不能再熟悉了，例如项目名称（name）、项目版本号（version）、项目描述 （description）、npm 命令（scripts）等等，而我们今天主要聊聊pkg.module字段的功能以及使用场景。 pck.module之前查阅了package.json的文档，并没有找到我们想要的 module 字段的定义，无意中看了一个帖子才知道它是 rollup 中最早就提出的概念 — pkg.module。在这之前 npm 包大都是基于 CommonJS 规范的。当我们当 require 引入包的时候，就会根据 main 字段去查找入口文件。 而在 ES6 规范出现后，ES6 定义了一套基于 import、export 操作符的模块规范。它与 CommonJS 规范最大的区别在 ES6 中的 import 和 export 都是静态的。静态意味着一个模块要暴露或引入的所有方法在编译阶段就能全部确定，之后不能再改变。这样做的好处就是打包工具在打包阶段就可以分析出代码中用到了某个模块中的哪几个方法。其它没有用到的方法就可以从最终的 bundle 文件中剔除掉。这样既可以减少 bundle 文件的大小，又可以提高脚本的执行速度。这个机制被称为 Tree Shaking。在这个构建思想的基础上，开发基于 ES Module 规范的包是很有必要的。 之前我们说过 CommonJS 规范的包都是以 main 字段表示入口文件了，如果 ES Module 的也用 main 字段，就会对使用者造成困扰，如果他的项目不支持打包构建，比如大多数 node 项目(尽管 node9+ 支持 ES Module)，这时库开发者的模块系统跟项目构建的模块系统的冲突，更像是一种规范上的问题。况且目前大部分仍是采用 CommonJS，所以 rollup 便使用了另一个字段：module。如下配置：123456&#123; "name": "mypck", "version": "1.0.0", "main": "dist/index.cjs.js", "module": "dist/index.esm.js"&#125; webpack 从版本 2 开始也可以识别 pkg.module 字段。打包时，如果存在 module 字段，会优先使用，如果没找到对应的文件，则使用 main 字段，并按照 CommonJS 规范打包。所以目前主流的打包工具（webpack, rollup）都是支持 pkg.module 的，鉴于其优点，module 字段很有可能加入 package.json 的规范之中。另外，越来越多的 npm 包已经同时支持两种模块，使用者可以根据情况自行选择，并且实现也比较简单，只是模块导出的方式。 注意：虽然打包工具支持了 ES Module，但是并不意味着其他的 es6 代码可以正常使用，因为使用者并不会对我们的 npm 包做编译处理，比如 webpack rules 中 exclude: /node_modules/，所以如果不是事先约定好后编译或者没有兼容性的需求，我们仍需要用 babel 处理，从而产出兼容性更好的 npm 包。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Commit message 和 Change log 编写指南]]></title>
    <url>%2F2018%2F08%2F07%2Fgit-commit-change-writing-guide.html</url>
    <content type="text"><![CDATA[Git 每次提交代码，都要编写 Commit message（提交说明），否则就不允许提交。 1$ git commit -m "hello world" 上面代码的 -m 参数，就是用来指定 commit mesage 的。如果一行不够，可以只执行 git commit，就会跳出文本编辑器，让你写多行。1$ git commit 基本上，你写什么都行。 但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。 目前，社区有多种 Commit message 的写法规范。本文介绍 Angular 规范，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。 Commit message 的作用提供更多的历史信息，方便快速浏览。比如，下面的命令显示上次发布后的变动，每个 commit 占据一行。你只看行首，就知道某次 commit 的目的。1$ git log &lt;last tag&gt; HEAD --pretty=format:%s 可以过滤某些commit（比如文档改动），便于快速查找信息。比如，下面的命令仅仅显示本次发布新增加的功能。 1$ git log &lt;last release&gt; HEAD --grep feature 可以直接从commit生成Change log。Commitizen：撰写合格 Commit message 的工具Commitizen 是一个撰写合格 Commit message 的工具。使用之前，我们先安装它： 1$ npm install -g commitizen 然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。 1$ commitizen init cz-conventional-changelog --save --save-exact 以后，凡是用到 git commit 命令，一律改为使用 git cz。这时，就会出现选项，用来生成符合格式的 Commit message。 commitlintcommitlint 用于检查 Node 项目的 Commit message 是否符合格式。使用前，我们先安装它： 1234# Install commitlint cli and angular config$ npm install --save-dev @commitlint/&#123;config-conventional,cli&#125;# For Windows:$ npm install --save-dev @commitlint/config-conventional @commitlint/cli 接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为 commit-msg 时运行。12345678&#123; "husky": &#123; "hooks": &#123; "pre-commit": "lint-staged", "commit-msg": "commitlint -E HUSKY_GIT_PARAMS" &#125; &#125;&#125; 然后，每次 git commit 的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。这里面有使用 husky，所以我们还要安装 husky 才能使用。 1$ npm install husky@next --save-dev Change log如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。生成的文档包括以下三个部分： New features Bug fixes Breaking changes. conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。12$ npm install -g conventional-changelog-cli$ conventional-changelog -p angular -i CHANGELOG.md -s -w -r 0 为了方便使用，可以将其写入 package.json 的 scripts 字段：12345&#123; "scripts": &#123; "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s -w -r 0" &#125;&#125; 以后，直接运行下面的命令即可：1$ npm run changelog]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git修复线上指定版本的问题]]></title>
    <url>%2F2018%2F08%2F05%2Fgit-assign-version-fix.html</url>
    <content type="text"><![CDATA[作为一个码农，bug 就像家常便饭一样。有了 bug 就需要修复，在 git 中，由于分支是如此的强大，所以，每个 bug 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。今天我们就来聊聊如何使用git修复线上指定版本的问题？第一步：查看远程分支，并确定要修复的分支，如图，远程分支为origin/V1.2.0. 如果没有远程分支或不清楚是哪个分支，那我相信在您每开发完一个版本发布生产时都会打包一个标签，就比如我们团队用的 gitlab 管理的项目： 这边很清楚的能够看到我们有 3 个远程分支，59 个标签，找到对应的标签生成对应的分支即可。如果您们目前尚未使用 gitlab，那只能用 git 命令了，不懂的伙伴，强烈推荐去看廖大神git教程。 第二步：创建本地分支V1.2.0，并拉取远程分支代码，同时切换到本地分支，如图 第三步：开发新代码，比如我这边测试代码空格，如图 第四步：开发完成，正常提交流程：git status、git add -A、git commit -m “修复某某问题”，如图 第五步：提交完成，把本地分支推送到远程分支git push origin V1.2.0:V1.2.0 第六步：切换到开发分支：git checkout dev，然后合并刚才修改的代码：git merge V1.2.0 最后：删除新创建的分支：git branch -D V1.2.0]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript模块打包工具Rollup——完全入门指南]]></title>
    <url>%2F2018%2F08%2F04%2Frollup-tutorial.html</url>
    <content type="text"><![CDATA[版本：v0.63.5。 Rollup 是前端模块化的一个打包工具，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。简单地说，它可以从一个入口文件开始，将所有使用的模块根据命令或者根据 Rollup 配置文件打包成一个目标文件，并且 Rollup 会自动过滤掉那些没有被使用过的函数或变量，从而使代码最小化，如果想使用直接导入这一个目标文件即可，因此 Rollup 极其适合构建一个工具库。 这里提到 Rollup 的两个特别重要的特性，第一个就是它使用了 ES2015 的模板标准，这意味着你可以直接使用 import 和 export 而不需要引入 babel。另一个重要特性叫做 tree-shaking，这个特性可以帮助你将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。举个简单的例子，我们在 foo.js 文件定义了 f1 和 f2 两个方法，然后在入口文件 index.js 只引入了 foo.js 文件中的 f1 方法，那么在最后打包 index.js 文件时，Rollup 就不会将 f2 方法打包到最终文件中。（这个特性是基于 ES6 模块的静态分析的，也就是说，只有 export 而没有 import 的变量是不会被打包到最终代码中的）。 入门创建第一个 bundle开始前，需要安装Node.js，这样才可以使用npm；还需要了解如何使用command line。 使用 Rollup 最简单的方法是通过 Command Line Interface （或 CLI）。先全局安装 Rollup （之后会介绍如何在项目中进行安装，更便于打包，但现在不用担心这个问题）。在命令行中输入以下内容： 1$ npm install rollup --global 现在可以运行 rollup 命令了。试试吧~ 1$ rollup 由于没有传递参数，所以 Rollup 打印出了使用说明。这和运行 rollup –help 或 rollup -h 的效果一样。 我们来创建一个简单的项目： 12$ mkdir -p my-rollup-project/src$ cd my-rollup-project 首先，我们需要个入口文件。将以下代码粘贴到新建的文件 src/main.js 中： 123456// src/main.jsimport &#123; foo1 &#125; from './foo.js';export default function () &#123; foo1();&#125; 之后创建入口文件引用的 foo.js 模块:12345678// src/foo.jsexport function foo1() &#123; console.log('function foo1')&#125;export function foo2() &#123; console.log('function foo2')&#125; 现在可以创建 bundle 了：1$ rollup src/main.js -o bundle.js -f cjs -o 表示打包后输出的文件路径，在 -o 后面的 bundle.js 就是我们最终生成的打包文件了（其实这里我们省略了参数 -i，用来表示入口文件的路径， Rollup 是会把没有加参数的文件默认是入口文件）；-f 选项（–output.format 的缩写）指定了所创建 bundle 的类型（默认使用 es 模块标准来对文件进行打包）——这里是 CommonJS（在 Node.js 中运行）。现在我们看一下输出文件 bundle.js：12345678910111213'use strict';function foo1() &#123; console.log('function foo1');&#125;// src/main.jsfunction main () &#123; foo1();&#125;module.exports = main; 恭喜，你已经用 Rollup 完成了第一个 bundle。 使用配置文件在项目中创建一个名为 rollup.config.js 的文件，增加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// rollup.config.js // 1. output 为对象export default &#123; input: 'src/main.js', output: &#123; file: 'bundle.js', format: 'cjs' &#125;&#125;;// 2. output 为数组export default &#123; input: 'src/main.js', output: [&#123; file: 'dist/bundle.cjs.js', format: 'cjs' &#125;, &#123; file: 'dist/bundle.umd.js', name: 'moduleName', format: 'umd' &#125;, &#123; file: 'dist/bundle.es.js', format: 'es' &#125;]&#125;;// 整个配置为数组export default [&#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.cjs1.js', format: 'cjs' &#125;&#125;, &#123; input: 'src/main.js', output: [&#123; file: 'dist/bundle.cjs2.js', format: 'cjs' &#125;, &#123; file: 'dist/bundle.umd2.js', name: 'moduleName', format: 'umd' &#125;, &#123; file: 'dist/bundle.es2.js', format: 'es' &#125;]&#125;] input 表示打包的入口文件，output 表示打包输出文件的配置（如果要输出多个，可以是一个数组，如果是数组，Rollup 会把每一个数组元素当成一个配置输出结果，因此可以在一个配置文件内设置多种输出配置），file 表示输出文件的名称路径，format 表示要打包成的模块类型。若使用 iife 或 umd 模块类型打包，需要添加属性moduleName，用来表示模块的名称；若用 amd 模块打包，可以配置 amd 相关的参数（使用 umd 模块模式时，也会使用到 amd 相关配置参数）：1234amd: &#123; id: 'amd-name', // amd具名函数名称 define: 'def' // 用来代替define函数的函数名称&#125; 我们用 –config 或 -c 来使用配置文件： 1$ rollup -c 同样的命令行选项将会覆盖配置文件中的选项：1$ rollup -c -o bundle-2.js 在这里我们发现配置文件使用了 ES6 语法，这是因为 Rollup 本身会处理配置文件 ，所以可以使用 export default 语法——代码不会经过 Babel 等类似工具编译，所以只能使用所用 Node.js 版本支持的 ES2015 语法。 如果愿意的话，也可以指定与默认 rollup.config.js 文件不同的配置文件：12$ rollup --config rollup.config.dev.js$ rollup --config rollup.config.prod.js 当然，我们也可以在 package.json 文件中编写 npm scripts 命令： 1"build": "rollup -c" 针对不同模板类型我们简单编写几个命令：123456"build:amd": "rollup index.js -f amd -o ./dist/dist.amd.js","build:cjs": "rollup index.js -f cjs -o ./dist/dist.cjs.js","build:es": "rollup index.js -f es -o ./dist/dist.es.js","build:iife": "rollup index.js -f iife -n result -o ./dist/dist.iife.js","build:umd": "rollup index.js -f umd -n result -o ./dist/dist.umd.js","build": "npm run build:amd &amp;&amp; npm run build:cjs &amp;&amp; npm run build:es &amp;&amp; npm run build:iife &amp;&amp; npm run build:umd" 在这里我们发现在设置模块为 iife（立即执行函数）和 umd 时，还加上了一个参数 -n，这是为了事先设定模块的名称，才能让其他人通过这个模块名称引用。 使用ES6编写代码许多开发人员在他们的项目中使用Babel，以便他们可以使用未被浏览器和 Node.js 支持的将来版本的 JavaScript 特性。Rollup 虽然支持了解析 import 和 export 两种语法，但是不会解析其他不被支持 JavaScript 特性，使用 Babel 和 Rollup 的最简单方法是使用rollup-plugin-babel。 安装它：1$ npm i -D babel-core rollup-plugin-babel rollup-plugin-node-resolve 编写 Rollup 配置文件 rollup.config.js:12345678910111213141516171819// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'cjs' &#125;, plugins: [ json(), resolve(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;) ]&#125;; 这里有几个特别注意的地方。首先，我们设置 “modules”: false，否则 Babel 会在 Rollup 有机会做处理之前，将我们的模块转成 CommonJS，导致 Rollup 的一些处理失败。 其次，我们使用 external-helpers 插件，它允许 Rollup 在包的顶部只引用一次 “helpers”，而不是每个使用它们的模块中都引用一遍（这是默认行为）。 第三，我们将 .babelrc 文件放在 src 中，而不是根目录下。 这允许我们对于不同的任务有不同的 .babelrc 配置，比如像测试，如果我们以后需要的话 - 通常为单独的任务单独配置会更好。 现在，在我们运行 rollup 之前，我们需要安装 latest preset 和 external-helpers 插件： 1$ npm i -D babel-preset-latest babel-plugin-external-helpers 现在我们用 es6 编辑 src / main.js： 123456// src/main.jsimport &#123; version &#125; from '../package.json';export default () =&gt; &#123; console.log('version：' + version);&#125; 运行 Rollup npm run build，检查打包后的 bundle：1234567891011'use strict';var version = "0.0.1";// src/main.jsvar main$1 = (function () &#123; console.log('version：' + version);&#125;);module.exports = main$1; 配置文件配置参数external：为rollup设置外部模块和全局变量平时开发中，我们经常会引入一些第三方模块，但是在使用的时候，我们又不想把它们打包到一个文件里，想让它们作为单独的模块（或文件）来使用，方便浏览器进行缓存，这个时候就需要使用配置文件中的 external 属性了。 我们这边以 jquery 为例，在开始使用之前，我们先安装它：1$ npm i jquery --save-dev 编写 Rollup 配置文件 rollup.config.js，加入external配置:12345678910111213141516171819202122// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs'export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'cjs' &#125;, plugins: [ json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;) ], external: ['jquery']&#125;; external 用来表示一个模块是否要被当成外部模块使用，属性的值可以是一个字符串数组或一个方法，当传入的是一个字符串数组时，所有数组内的模块名称都会被当成是外部模块，不会被打包到最终文件中。当传入的是一个方法时，方法有一个参数 id，表示解析的模块的名称，我们可以自定义解析方式，若是要当做外部模块不打包到最终文件中，则返回 true，若要一起打包到最终文件中，则返回 false。 globalsglobals 的值是一个对象，key表示使用的模块名称（npm 模块名），value 表示在打包文件中引用的全局变量名，在这里我们就是把jquery模块的全局变量名设置为jQuery，重新打包。 编写 Rollup 配置文件 rollup.config.js，加入globals配置:1234567891011121314151617181920212223242526// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs'export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', name: 'result', format: 'iife', globals: &#123; jquery: 'jQuery' &#125; &#125;, plugins: [ json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;) ], external: ['jquery']&#125;; 运行 Rollup npm run build，检查打包后的 bundle： 1234567891011121314151617var result = (function (jQuery) &#123; 'use strict'; jQuery = jQuery &amp;&amp; jQuery.hasOwnProperty('default') ? jQuery['default'] : jQuery; var version = "0.0.1"; // src/main.js var main$1 = (function () &#123; console.log(jQuery); console.log('version：' + version); &#125;); return main$1;&#125;(jQuery)); 在重新打包出来的文件中，我们发现最后传入的参数已经由 $ 变为了 jQuery，而且 Rollup 也没有输出提示信息。 paths有时候我们可能会使用 CDN 上的 js 文件，但是又不想在本地安装一个相同的模块（也有可能没有对应的模块），可能在版本升级的时候会产生一些问题，这个时候我们就需要使用 Rollup 的 paths 属性了，这个属性可以帮你把依赖的文件地址注入到打包后的文件里。 编写 Rollup 配置文件 rollup.config.js，加入 paths 配置: 1234567891011121314151617181920212223242526272829// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs'export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', name: 'result', format: 'amd', globals: &#123; jquery: 'jQuery' &#125;, paths: &#123; jquery: 'https://cdn.bootcss.com/jquery/3.2.1/jquery.js' &#125; &#125;, plugins: [ json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;) ], external: ['jquery']&#125;; 运行 Rollup npm run build，检查打包后的 bundle： 12345678910111213141516define(['https://cdn.bootcss.com/jquery/3.2.1/jquery.js'], function (jQuery) &#123; 'use strict'; jQuery = jQuery &amp;&amp; jQuery.hasOwnProperty('default') ? jQuery['default'] : jQuery; var version = "0.0.1"; // src/main.js var main$1 = (function () &#123; console.log(jQuery); console.log('version：' + version); &#125;); return main$1;&#125;); 可以看到 Rollup 已经把我们需要的 CDN 地址作为依赖加入到了打包文件中。 插件使用插件随着构建更复杂的 bundle，通常需要更大的灵活性——引入 npm 安装的模块、通过 Babel 编译代码、和 JSON 文件打交道等。为此，我们可以用 插件(plugins) 在打包的关键过程中更改 Rollup 的行为。the Rollup wiki维护了可用的插件列表。 我们这边将以rollup-plugin-json的使用为例，它的作用是令 Rollup 从 JSON 文件中读取数据。 将 rollup-plugin-json 安装为开发依赖：1$ npm install --save-dev rollup-plugin-json 我们用的是 –save-dev 而不是 –save，因为实际执行的代码并不依赖这个插件——只是在打包时使用。 更新 src/main.js 文件，从 package.json 而非 src/foo.js 中读取数据：123456// src/main.jsimport &#123; version &#125; from '../package.json';export default function () &#123; console.log('version：' + version);&#125; 编写 Rollup 配置文件 rollup.config.js，加入 JSON 插件：1234567891011// rollup.config.jsimport json from 'rollup-plugin-json';export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'cjs' &#125;, plugins: [ json() ]&#125;; npm run build 执行 Rollup。结果如下：1234567891011'use strict';var version = "0.0.1";// src/main.jsfunction main$1 () &#123; console.log('version：' + version);&#125;module.exports = main$1; 插件列表rollup-plugin-commonjs有时候我们会引入一些其他模块的文件（第三方的或是自己编写的），但是目前，npm 中的大多数包都是以 CommonJS 模块的形式出现的。在它们更改之前，我们需要将CommonJS模块转换为 ES2015 供 Rollup 解析。这个rollup-plugin-commonjs插件就是用来将 CommonJS 转换成 ES2015 模块的。请注意，rollup-plugin-commonjs 应该用在其他插件转换你的模块之前 - 这是为了防止其他插件的改变破坏 CommonJS 的检测。 在我们使用之前，需要先安装它：1$ npm i rollup-plugin-commonjs --save-dev 编写 Rollup 配置文件 rollup.config.js: 123456789101112131415161718192021// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs'export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'cjs' &#125;, plugins: [ json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;) ]&#125;; 编写 cjs 模块的文件： 1234567exports.foo1 = function() &#123; console.log('function foo1')&#125;exports.foo2 = function() &#123; console.log('function foo2')&#125; npm run build 执行 Rollup。结果如下：1234567891011'use strict';var version = "0.0.1";// src/main.jsvar main$1 = (function () &#123; console.log('version：' + version);&#125;);module.exports = main$1; rollup-plugin-uglify代码发布时，我们经常会把自己的代码压缩到最小，以减少网络请求中的传输文件大小。Rollup rollup-plugin-uglify 就是来帮你压缩代码的，在使用之前，我们先安装它：1$ npm i rollup-plugin-uglify --save-dev 编写 Rollup 配置文件 rollup.config.js，加入 uglify 插件： 12345678910111213141516171819202122232425262728293031// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs';import &#123; uglify &#125; from 'rollup-plugin-uglify'export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', name: 'result', format: 'amd', globals: &#123; jquery: 'jQuery' &#125;, paths: &#123; jquery: 'https://cdn.bootcss.com/jquery/3.2.1/jquery.js' &#125; &#125;, plugins: [ json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;), uglify() ], external: ['jquery']&#125;; 运行打包命令，查看打包后的目标文件，发现代码已经被压缩了。但是，压缩过的代码在 debug 时会带来很大的不便，因此我们需要在压缩代码的同时生成一个 sourceMap 文件。幸运的是，Rollup 自己就支持 sourceMap 文件的生成，不需要我们去引入其他插件，只需要在配置文件中 output 选项加上以下代码即可： 12// rollup.config.jssourcemap: true 若是将 sourceMap 属性的值设置为 inline，则会将 sourceMap 的内容添加到打包文件的最后。 rollup-plugin-eslint在大型工程的团队开发中，我们需要保证团队代码风格的一致性，因此需要引入 eslint，而且在打包时需要检测源文件是否符合 eslint 设置的规范，若是不符合则抛出异常并停止打包。Rollup rollup-plugin-eslint 就是用于设置代码规范，使用之前我们先安装它： 1$ npm i eslint rollup-plugin-eslint --save-dev 编写 eslint 配置文件 .eslintrc： 1234567891011121314151617&#123; "env": &#123; "browser": true, "commonjs": true, "es6": true, "node": true &#125;, "parserOptions": &#123; "ecmaFeatures": &#123; "jsx": false &#125;, "sourceType": "module" &#125;, "rules": &#123; "semi": ["error","never"] &#125;&#125; 编写 Rollup 配置文件 rollup.config.js，加入 eslint 插件：123456789101112131415161718192021222324252627282930313233343536373839// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs';import &#123; uglify &#125; from 'rollup-plugin-uglify';import &#123; eslint &#125; from 'rollup-plugin-eslint';export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', name: 'result', format: 'amd', globals: &#123; jquery: 'jQuery' &#125;, paths: &#123; jquery: 'https://cdn.bootcss.com/jquery/3.2.1/jquery.js' &#125;, sourcemap: true &#125;, plugins: [ eslint(&#123; throwOnError: true, throwOnWarning: true, include: ['src/**'], exclude: ['node_modules/**'] &#125;), json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;), uglify() ], external: ['jquery']&#125;; 这里有两个属性需要特别说明下：throwOnError 和 throwOnWarning 设置为 true 时，如果在 eslint 的检查过程中发现了 error 或 warning，就会抛出异常，阻止打包继续执行（如果设置为 false，就只会输出 eslint 检测结果，而不会停止打包）。 如果我们使用IDE或编辑器的 eslint 插件，有时候这些插件会去检查打包完的文件，导致你的提示框里一直会有 eslint 检测到错误的消息，我们现在有两种解决方案，第一种是创建一个 .eslintignore 文件，将打包文件加进去，让 eslint 忽略这个文件，还有一种就是让 Rollup 在打包文件的开始和最后自动生成注释来阻止 eslint 检测代码，使用这种方法时，需要使用 Rollup 配置文件的两个属性：banner和footer，这两个属性会在生成文件的开头和结尾插入一段你自定义的字符串。我们利用这个属性，在打包文件的开头添加/*eslint-disable */注释，让 eslint 不检测这个文件。 添加banner和footer属性 1banner: '/*eslint-disable */' 如果说 banner 和 footer 是在文件开始和结尾添加字符串，那么 intro 和 outro 就是在被打包的代码开头和结尾添加字符串了，以 iife 模式来举例，如果我们配置了这四个属性，那么输出结果就会是：12345678910// banner字符串(function () &#123;'use strict';// intro字符串// 被打包的代码// outro字符串&#125;());// footer字符串 rollup-plugin-replace有时候我们会把开发/生产环境的信息直接写在源文件里面，这个时候用 intro/outro 来注入代码的方式就不适合了。这个时候我们就需要使用 rollup-plugin-replace 插件来对源代码的变量值进行替换，在使用之前，我们先安装它： 1$ npm i rollup-plugin-replace --save-dev 编写 Rollup 配置文件 rollup.config.js，加入 replace 插件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs';import &#123; uglify &#125; from 'rollup-plugin-uglify';import &#123; eslint &#125; from 'rollup-plugin-eslint';import &#123; version &#125; from '../package.json';import replace from 'rollup-plugin-replace';const VERSION = process.env.VERSION || version;const copyright = new Date().getFullYear() &gt; 2018 ? '2018-' + new Date().getFullYear() : 2018;const banner = '/*!\n' + ' * idebug v' + VERSION + '\n' + ' * (c) ' + copyright + ' Weich\n' + ' * Released under the MIT License.\n' + ' */';// const weexFactoryPlugin = &#123;// intro () &#123;// return 'module.exports = function weexFactory (exports, document) &#123;'// &#125;,// outro () &#123;// return '&#125;'// &#125;// &#125;;export default &#123; input: 'src/main.js', output: &#123; banner: banner, footer: '/* my-library version ' + VERSION + ' */', file: 'dist/bundle.js', name: 'result', format: 'iife', globals: &#123; jquery: 'jQuery' &#125;, paths: &#123; jquery: 'https://cdn.bootcss.com/jquery/3.2.1/jquery.js' &#125;, sourcemap: true &#125;, plugins: [ // weexFactoryPlugin, replace(&#123; __VERSION__: VERSION &#125;), eslint(&#123; throwOnError: true, throwOnWarning: true, include: ['src/**'], exclude: ['node_modules/**'] &#125;), json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;), uglify(&#123; output: &#123; comments: function(node, comment) &#123; var text = comment.value; var type = comment.type; if (type == "comment2") &#123; // multiline comment return /idebug|ENVIRONMENT/i.test(text); &#125; &#125; &#125; &#125;) ], external: ['jquery']&#125;; 接下来就可以直接在源码中使用 __VERSION__ 了，编写入口文件 index.js：1234567// src/main.jsimport jQuery from 'jquery'export default () =&gt; &#123; console.log(jQuery) console.log('version：__VERSION__' )&#125; 执行打包命令，并检查源文件里有没有被替换。 命令行命令行的参数-v/--version：打印已安装的Rollup版本号。 -w/--watch：我们在开发过程中，需要频繁对源文件进行修改，如果每次都自己手动输一遍打包命令，那真的是要烦死，因此，我们在 rollup 命令后面加上 -w/–watch 参数，就能让 rollup 监听文件变化，即时打包。 本文持续更新中]]></content>
      <categories>
        <category>rollup</category>
      </categories>
      <tags>
        <tag>rollup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端(手机端)页面自适应解决方案—rem布局篇]]></title>
    <url>%2F2018%2F08%2F03%2Fmobile-rem-layout.html</url>
    <content type="text"><![CDATA[假设设计妹妹给我们的设计稿尺寸为750 * 1340。结合网易、淘宝移动端首页html元素上的动态font-size属性、设计稿尺寸、前端与设计之间协作流程一般分为下面两种： 一、网易做法：引入：页面开头处引入下面这段代码，用于动态计算font-size 12345678910111213141516171819202122232425(function(doc, win) &#123; var docEl = doc.documentElement, isIOS = navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), dpr = isIOS ? Math.min(win.devicePixelRatio, 3) : 1, dpr = window.top === window.self ? dpr : 1, //被iframe引用时，禁止缩放 dpr = 1, scale = 1 / dpr, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize'; docEl.dataset.dpr = dpr; var metaEl = doc.createElement('meta'); metaEl.name = 'viewport'; metaEl.content = 'initial-scale=' + scale + ',maximum-scale=' + scale + ', minimum-scale=' + scale; docEl.firstElementChild.appendChild(metaEl); var recalc = function() &#123; var width = docEl.clientWidth; if (width / dpr &gt; 750) &#123; width = 750 * dpr; &#125; // 乘以100，px : rem = 100 : 1 docEl.style.fontSize = 100 * (width / 750) + 'px'; &#125;; recalc() if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false);&#125;)(document, window); 使用：未引入前：1234body &#123; width: 750px; height: 640px;&#125; 引入后：除以100并将px换成rem 1234body &#123; width: 7.5rem; height: 6.4rem;&#125; 换算的依据： 123456789// 乘以100，px : rem = 100 : 1var recalc = function() &#123; var width = docEl.clientWidth; if (width / dpr &gt; 750) &#123; width = 750 * dpr; &#125; // 乘以100，px : rem = 100 : 1 docEl.style.fontSize = 100 * (width / 750) + 'px';&#125;; 二、淘宝做法（推荐做法，尤其是app内嵌页面）：引入：页面开头处引入下面这段代码，用于动态计算font-size，或者单独放入一个文件，引入文件也可以 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118;(function(win, lib) &#123; var doc = win.document; var docEl = doc.documentElement; var metaEl = doc.querySelector('meta[name="viewport"]'); var flexibleEl = doc.querySelector('meta[name="flexible"]'); var dpr = 0; var scale = 0; var tid; var flexible = lib.flexible || (lib.flexible = &#123;&#125;); if (metaEl) &#123; var match = metaEl.getAttribute('content').match(/initial\-scale=([\d\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125; &#125; else if (flexibleEl) &#123; var content = flexibleEl.getAttribute('content'); if (content) &#123; var initialDpr = content.match(/initial\-dpr=([\d\.]+)/); var maximumDpr = content.match(/maximum\-dpr=([\d\.]+)/); if (initialDpr) &#123; dpr = parseFloat(initialDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; if (maximumDpr) &#123; dpr = parseFloat(maximumDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; &#125; &#125; if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) &#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; &#125; docEl.setAttribute('data-dpr', dpr); if (!metaEl) &#123; metaEl = doc.createElement('meta'); metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(metaEl); &#125; else &#123; var wrap = doc.createElement('div'); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); &#125; &#125; function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; // 适配平板 if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem; &#125; win.addEventListener('resize', function() &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener('pageshow', function(e) &#123; if (e.persisted) &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); if (doc.readyState === 'complete') &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125; else &#123; doc.addEventListener('DOMContentLoaded', function(e) &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125;, false); &#125; refreshRem(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = refreshRem; flexible.rem2px = function(d) &#123; var val = parseFloat(d) * this.rem; if (typeof d === 'string' &amp;&amp; d.match(/rem$/)) &#123; val += 'px'; &#125; return val; &#125; flexible.px2rem = function(d) &#123; var val = parseFloat(d) / this.rem; if (typeof d === 'string' &amp;&amp; d.match(/px$/)) &#123; val += 'rem'; &#125; return val; &#125;&#125;)(window, window['lib'] || (window['lib'] = &#123;&#125;)); 使用： 未引入前： 1234body &#123; width: 750px; height: 640px;&#125; 引入后： 12345@font-size-base: 75;body &#123; width: 750rem/@font-size-base; height: 640rem/@font-size-base;&#125; 换算依据： 12345678910function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; // 适配平板 if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125; 这边是用的less，如果您没有用less，就需要手动计算，当然也可以转化为px : rem = 100 : 1。如果想转化为px : rem = 100 : 1，可以修改上面的refreshRem函数： 12345678910function refreshRem() &#123; var width = docEl.getBoundingClientRect().width // 适配平板 if (width / dpr &gt; 750) &#123; width = 750 * dpr &#125; var rem = 100 * (width / 750) docEl.style.fontSize = rem + 'px' flexible.rem = win.rem = rem;&#125; 使用： 未引入前： 1234body &#123; width: 750px; height: 640px;&#125; 引入后：除以100并将px换成rem 1234body &#123; width: 7.5rem; height: 6.4rem;&#125; 换算依据就是上面修改的代码： 12345678910function refreshRem() &#123; var width = docEl.getBoundingClientRect().width // 适配平板 if (width / dpr &gt; 750) &#123; width = 750 * dpr &#125; var rem = 100 * (width / 750) docEl.style.fontSize = rem + 'px' flexible.rem = win.rem = rem;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next、nuxt等服务端渲染框架如何在服务器部署，并用PM2守护程序]]></title>
    <url>%2F2018%2F08%2F03%2Flinux-nginx-ssr-deploy.html</url>
    <content type="text"><![CDATA[貌似从前几年，前后端分离逐渐就开始流行起来，把一些渲染计算的工作抛向前端以便减轻服务端的压力，但为啥现在又开始流行在服务端渲染了呢？如vue全家桶或者react全家桶，都推荐通过服务端渲染来实现路由。搞得我们慌得不行，不禁让我想起一句话：从来没有任何一门语言的技术栈像Javascript一样，学习者拼尽全力也不让精通。没办法，流行，咱们就得学！ 前断时间写了一篇vuejs、react如何在服务器部署？，结果反响不错！最近好多朋友私信或邀请问很多关于next.js和nuxt.js的问题，比如关于nextjs 和 nuxtjs如何部署，pm2如何配合…在这里我们就一起讨论下在服务器上使用PM2守护next.js、nuxt.js等服务端渲染框架构建的项目！该篇我们只讨论服务端渲染应用部署，静态应用部署就是我前段时间写的vuejs、react如何在服务器部署？。 Nginx配置既然是应用，我们就应该有域名，在这里我们以nginx配置为例，简单配置如下：Next域名：http://next.sosout.com/Nuxt域名：http://nuxt.sosout.com/123456789101112131415161718192021222324252627282930http &#123; .... # 省略其他配置 server &#123; listen 80; server_name *.sosout.com; if ($host ~* "^(.*?)\.sosout\.com$") &#123; set $domain $1; &#125; location / &#123; if ($domain ~* "next") &#123; root /mnt/html/next; &#125; if ($domain ~* "nuxt") &#123; root /mnt/html/nuxt; &#125; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; access_log /mnt/logs/nginx/access.log main; &#125; #tcp_nopush on; include /etc/nginx/conf.d/*.conf;&#125; Nginx反向代理由于服务端渲染的各个应用端口号各不相同，因此这个时候我们就需要反向代理了，配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#通过upstream nodejs 可以配置多台nodejs节点，做负载均衡#keepalive 设置存活时间。如果不设置可能会产生大量的timewait#proxy_pass 反向代理转发 http://nodejsupstream nodenext &#123; server 127.0.0.1:3001; #next项目 监听端口 keepalive 64;&#125;server &#123; listen 80; server_name next.sosout.com; location / &#123; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header Host $host; proxy_set_header X-Nginx-Proxy true; proxy_cache_bypass $http_upgrade; proxy_pass http://nodenext; #反向代理 &#125;&#125;upstream nodenuxt &#123; server 127.0.0.1:3002; #nuxt项目 监听端口 keepalive 64;&#125;server &#123; listen 80; server_name nuxt.sosout.com; location / &#123; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header Host $host; proxy_set_header X-Nginx-Proxy true; proxy_cache_bypass $http_upgrade; proxy_pass http://nodenuxt; #反向代理 &#125;&#125; 服务器的准备工作已完成，接下来我们就分别看看Next.js和Nuxt.js服务端渲染应用如何部署？ Next.js服务端渲染应用部署部署 Next.js 服务端渲染的应用不能直接使用next命令，而应该先进行编译构建，然后再启动 Next 服务，官方通过以下两个命令来完成：12$ next build$ next start 官方推荐的 package.json 配置如下： 1234567891011&#123; "name": "my-app", "dependencies": &#123; "next": "latest" &#125;, "scripts": &#123; "dev": "next", "build": "next build", "start": "next start" &#125;&#125; 而我更推荐如下配置，稍后你会发现这样和pm2一起使用更方便，自动化部署也方便: 1234567891011&#123; "name": "my-app", "dependencies": &#123; "next": "latest" &#125;, "scripts": &#123; "dev": "next", "start": "next start -p $PORT", "build": "next build &amp;&amp; PORT=3001 npm start" &#125;&#125; next.js服务端渲染应用部署这样就完成了，官方先后执行npm run build 、npm start即可完成部署。而我这边只要执行npm run build，其实我只是把两个合并成一个，并设置了端口以便区别其他应用，避免端口占用！ 接下来简单的说一下next这几个命令：next:启动一个热加载的Web服务器（开发模式）next build:利用webpack编译应用，压缩JS和CSS资源（发布用）。next start:以生成模式启动一个Web服务器 (next build 会先被执行)。 Nuxt.js服务端渲染应用部署其实部署 Nuxt.js 服务端渲染的应用和Next.js极其相似！在这里我就把代码粘粘贴贴，复复制制，改改写写。。。。Nuxt.js 服务端渲染的应用不能直接使用nuxt命令，而应该先进行编译构建，然后再启动 Nuxt 服务，官方通过以下两个命令来完成： 12$ nuxt build$ nuxt start 官方推荐的 package.json 配置如下： 1234567891011&#123; "name": "my-app", "dependencies": &#123; "nuxt": "latest" &#125;, "scripts": &#123; "dev": "nuxt", "build": "nuxt build", "start": "nuxt start" &#125;&#125; 而我更推荐如下配置，稍后你会发现这样和pm2一起使用更方便，自动化部署也方便: 1234567891011&#123; "name": "my-app", "dependencies": &#123; "nuxt": "latest" &#125;, "scripts": &#123; "dev": "nuxt", "start": "PORT=3002 nuxt start", "build": "nuxt build &amp;&amp; npm start" &#125;&#125; nuxt.js服务端渲染应用部署这样就完成了，官方先后执行npm run build 、npm start即可完成部署。而我这边只要执行npm run build，其实我只是把两个合并成一个，并设置了端口以便区别其他应用，避免端口占用！ 接下来简单的说一下nuxt这几个命令：nuxt:启动一个热加载的Web服务器（开发模式）nuxt build:利用webpack编译应用，压缩JS和CSS资源（发布用）。nuxt start:以生成模式启动一个Web服务器 (nuxt build 会先被执行)。 PM2守护程序Next.js使用pm2，进入对应的应用目录，执行以下命令： 1$ pm2 start npm --name "my-next" -- run build Nuxt.js使用pm2，进入对应的应用目录，执行以下命令： 1$ pm2 start npm --name "my-nuxt" -- run build 使用pm2时，把两个部署命令合成一个更方便！执行完pm2的启动命令后，我们用pm2 list查看一下进程列表，我截一下我个人服务器的pm2列表： 以后您就可以用pm2进行维护了，比如我们的next应用更改了代码，因为当时创建时给next应用命名的进程名称为my-next，因此我们可以直接使用pm2 reload my-next进行重载。接下来我就简单介绍一下pm2，如果有需要，我可以另写一篇关于pm2的文章！ pm2 简单介绍pm2是nodejs的一个带有负载均衡功能的应用进程管理器的模块，类似有Supervisor，forever，用来进行进程管理。 一、安装：1$ npm install pm2 -g 二、启动：1234$ pm2 start app.js$ pm2 start app.js --name my-api #my-api为PM2进程名称$ pm2 start app.js -i 0 #根据CPU核数启动进程个数$ pm2 start app.js --watch #实时监控app.js的方式启动，当app.js文件有变动时，pm2会自动reload 三、查看进程：12$ pm2 list$ pm2 show 0 或者 # pm2 info 0 #查看进程详细信息，0为PM2进程id 四、监控：1$ pm2 monit 五、停止：12$ pm2 stop all #停止PM2列表中所有的进程$ pm2 stop 0 #停止PM2列表中进程为0的进程 六、重载：12$ pm2 reload all #重载PM2列表中所有的进程$ pm2 reload 0 #重载PM2列表中进程为0的进程 七、重启：12$ pm2 restart all #重启PM2列表中所有的进程$ pm2 restart 0 #重启PM2列表中进程为0的进程 八、删除PM2进程：12$ pm2 delete 0 #删除PM2列表中进程为0的进程$ pm2 delete all #删除PM2列表中所有的进程 九、日志操作：123$ pm2 logs [--raw] #Display all processes logs in streaming$ pm2 flush #Empty all log file$ pm2 reloadLogs #Reload all logs 十、升级PM2：12$ npm install pm2@lastest -g #安装最新的PM2版本$ pm2 updatePM2 #升级pm2 十一、更多命令参数请查看帮助：1$ pm2 --help 十二、PM2目录结构： 1、默认的目录是：当前用于的家目录下的.pm2目录（此目录可以自定义，请参考：十三、自定义启动文件），详细信息如下：12345678$HOME/.pm2 #will contain all PM2 related files$HOME/.pm2/logs #will contain all applications logs$HOME/.pm2/pids #will contain all applications pids$HOME/.pm2/pm2.log #PM2 logs$HOME/.pm2/pm2.pid #PM2 pid$HOME/.pm2/rpc.sock #Socket file for remote commands$HOME/.pm2/pub.sock #Socket file for publishable events$HOME/.pm2/conf.js #PM2 Configuration 十三、自定义启动文件： 1、创建一个test.json的示例文件，格式如下： 12345678910111213141516&#123; "apps": &#123; "name": "test", "cwd": "/data/wwwroot/nodejs", "script": "./test.sh", "exec_interpreter": "bash", "min_uptime": "60s", "max_restarts": 30, "exec_mode" : "cluster_mode", "error_file" : "./test-err.log", "out_file": "./test-out.log", "pid_file": "./test.pid" "watch": false &#125;&#125; 2、参数说明： 123456789101112apps：json结构，apps是一个数组，每一个数组成员就是对应一个pm2中运行的应用name：应用程序的名称cwd：应用程序所在的目录script：应用程序的脚本路径exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejsmin_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量max_restarts：设置应用程序异常退出重启的次数，默认15次（从0开始计数）exec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是forkerror_file：自定义应用程序的错误日志文件out_file：自定义应用程序日志文件pid_file：自定义应用程序的pid文件watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件。 部署（以nuxt为例）基础模板的部署方式何为基础模板？使用了vue init nuxt-community/starter-template &lt;project-name&gt;进行搭建的！ 第一步，打包在执行npm run build的时候，nuxt会自动打包。 第二步，选择要部署的文件（社友最关心的步骤）： .nuxt/文件夹 package.json文件 nuxt.config.js文件(如果你配置proxy等，则需要上传这个文件，建议把它传上去) 第三步，启动你的nuxt：使用pm2启动你的nuxt.js： 12$ npm install // or yarn install 如果未安装依赖或依赖有更改$ pm2 start npm --name "my-nuxt" -- run start]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>spa</tag>
        <tag>pm2</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuejs、react如何在服务器部署？]]></title>
    <url>%2F2018%2F08%2F02%2Flinux-nginx-spa-deploy.html</url>
    <content type="text"><![CDATA[最近好多伙伴说，我用vue做的项目本地是可以的，但部署到服务器遇到好多问题：资源找不到，直接访问index.html页面空白，刷新当前路由404。。。用react做的项目也同样遇到类似问题。现在我们一起讨论下单页面如何部署到服务器？ 由于前端路由缘故，单页面应用应该放到nginx或者apache、tomcat等web代理服务器中，千万不要直接访问index.html，同时要根据自己服务器的项目路径更改react或vue的路由地址。 如果说项目是直接跟在域名后面的，比如:http://www.sosout.com，根路由就是/。如果说项目是直接跟在域名后面的一个子目录中的，比如:http://www.sosout.com/children ，根路由就是/children，不能直接访问index.html。 以配置nginx为例，配置过程大致如下： 我们首先假设以下两条规则：1. 项目文件目录： /mnt/html/spa（spa目录下的文件就是执行了npm run dist 后生成的dist目录下的文件）2. 访问域名：spa.sosout.com 进入nginx.conf新增如下配置： 123456789101112131415161718server &#123; listen 80; server_name spa.sosout.com; root /mnt/html/spa; index index.html; location ~ ^/favicon\.ico$ &#123; root /mnt/html/spa; &#125; location / &#123; try_files $uri $uri/ /index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; access_log /mnt/logs/nginx/access.log main;&#125; 注意事项：1、配置域名的话，需要80端口，成功后，只要访问域名即可访问的项目2、如果你使用了react-router的 browserHistory 模式或 vue-router的 history 模式，在nginx配置还需要重写路由： 12345678910111213141516171819202122server &#123; listen 80; server_name spa.sosout.com; root /mnt/html/spa; index index.html; location ~ ^/favicon\.ico$ &#123; root /mnt/html/spa; &#125; location / &#123; try_files $uri $uri/ @fallback; index index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; location @fallback &#123; rewrite ^.*$ /index.html break; &#125; access_log /mnt/logs/nginx/access.log main;&#125; 为什么要重写路由？因为我们的项目只有一个根入口，当输入类似/home的url时，如果找不到对应的页面，nginx会尝试加载index.html，这是通过react-router或vue-router就能正确的匹配我们输入的/home路由，从而显示正确的home页面，如果browserHistory模式或history模式的项目没有配置上述内容，会出现404的情况。 简单举两个例子，一个vue项目一个react项目： vue项目： 域名：http://tb.sosout.com 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import App from '../App'// 首页const home = r =&gt; require.ensure([], () =&gt; r(require('../page/home/index')), 'home')// 物流const logistics = r =&gt; require.ensure([], () =&gt; r(require('../page/logistics/index')), 'logistics')// 购物车const cart = r =&gt; require.ensure([], () =&gt; r(require('../page/cart/index')), 'cart')// 我的const profile = r =&gt; require.ensure([], () =&gt; r(require('../page/profile/index')), 'profile')// 登录界面const login = r =&gt; require.ensure([], () =&gt; r(require('../page/user/login')), 'login')export default [&#123; path: '/', component: App, // 顶层路由，对应index.html children: [&#123; path: '/home', // 首页 component: home &#125;, &#123; path: '/logistics', // 物流 component: logistics, meta: &#123; login: true &#125; &#125;, &#123; path: '/cart', // 购物车 component: cart, meta: &#123; login: true &#125; &#125;, &#123; path: '/profile', // 我的 component: profile &#125;, &#123; path: '/login', // 登录界面 component: login &#125;, &#123; path: '*', redirect: '/home' &#125;]&#125;] 12345678910111213141516171819202122232425262728293031323334############# 其他配置############http &#123; ############ # 其他配置 ############ server &#123; listen 80; server_name tb.sosout.com; root /mnt/html/tb; index index.html; location ~ ^/favicon\.ico$ &#123; root /mnt/html/tb; &#125; location / &#123; try_files $uri $uri/ @fallback; index index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; location @fallback &#123; rewrite ^.*$ /index.html break; &#125; access_log /mnt/logs/nginx/access.log main; &#125; ############ # 其他配置 ############ &#125; react项目： 域名：http://antd.sosout.com 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/*** 疑惑一：* React createClass 和 extends React.Component 有什么区别?* 之前写法：* let app = React.createClass(&#123;* getInitialState: function()&#123;* // some thing* &#125;* &#125;)* ES6写法(通过es6类的继承实现时state的初始化要在constructor中声明)：* class exampleComponent extends React.Component &#123;* constructor(props) &#123;* super(props);* this.state = &#123;example: 'example'&#125;* &#125;* &#125;*/import React, &#123;Component, PropTypes&#125; from 'react'; // react核心import &#123; Router, Route, Redirect, IndexRoute, browserHistory, hashHistory &#125; from 'react-router'; // 创建route所需import Config from '../config/index';import layout from '../component/layout/layout'; // 布局界面import login from '../containers/login/login'; // 登录界面/** * (路由根目录组件，显示当前符合条件的组件) * * @class Roots * @extends &#123;Component&#125; */class Roots extends Component &#123; render() &#123; // 这个组件是一个包裹组件，所有的路由跳转的页面都会以this.props.children的形式加载到本组件下 return ( &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; ) &#125;&#125;// const history = process.env.NODE_ENV !== 'production' ? browserHistory : hashHistory;// 快速入门const home = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/home/homeIndex').default) &#125;, 'home');&#125;// 百度图表-折线图const chartLine = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/charts/lines').default) &#125;, 'chartLine');&#125;// 基础组件-按钮const button = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/general/buttonIndex').default) &#125;, 'button');&#125;// 基础组件-图标const icon = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/general/iconIndex').default) &#125;, 'icon');&#125;// 用户管理const user = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/user/userIndex').default) &#125;, 'user');&#125;// 系统设置const setting = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/setting/settingIndex').default) &#125;, 'setting');&#125;// 广告管理const adver = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/adver/adverIndex').default) &#125;, 'adver');&#125;// 组件一const oneui = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/ui/oneIndex').default) &#125;, 'oneui');&#125;// 组件二const twoui = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/ui/twoIndex').default) &#125;, 'twoui');&#125;// 登录验证const requireAuth = (nextState, replace) =&gt; &#123; let token = (new Date()).getTime() - Config.localItem('USER_AUTHORIZATION'); if(token &gt; 7200000) &#123; // 模拟Token保存2个小时 replace(&#123; pathname: '/login', state: &#123; nextPathname: nextState.location.pathname &#125; &#125;); &#125;&#125;const RouteConfig = ( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path="/home" component=&#123;layout&#125; onEnter=&#123;requireAuth&#125;&gt; &lt;IndexRoute getComponent=&#123;home&#125; onEnter=&#123;requireAuth&#125; /&gt; // 默认加载的组件，比如访问www.test.com,会自动跳转到www.test.com/home &lt;Route path="/home" getComponent=&#123;home&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/chart/line" getComponent=&#123;chartLine&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/general/button" getComponent=&#123;button&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/general/icon" getComponent=&#123;icon&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/user" getComponent=&#123;user&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/setting" getComponent=&#123;setting&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/adver" getComponent=&#123;adver&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/ui/oneui" getComponent=&#123;oneui&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/ui/twoui" getComponent=&#123;twoui&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;/Route&gt; &lt;Route path="/login" component=&#123;Roots&#125;&gt; // 所有的访问，都跳转到Roots &lt;IndexRoute component=&#123;login&#125; /&gt; // 默认加载的组件，比如访问www.test.com,会自动跳转到www.test.com/home &lt;/Route&gt; &lt;Redirect from="*" to="/home" /&gt; &lt;/Router&gt;);export default RouteConfig; 1234567891011121314151617181920212223242526272829303132333435############# 其他配置############http &#123; ############ # 其他配置 ############ server &#123; listen 80; server_name antd.sosout.com; root /mnt/html/reactAntd; index index.html; location ~ ^/favicon\.ico$ &#123; root /mnt/html/reactAntd; &#125; location / &#123; try_files $uri $uri/ @router; index index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; location @router &#123; rewrite ^.*$ /index.html break; &#125; access_log /mnt/logs/nginx/access.log main; &#125; ############ # 其他配置 ############ &#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>spa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 选择器]]></title>
    <url>%2F2018%2F08%2F01%2Fcss-selector.html</url>
    <content type="text"><![CDATA[今天团队中一个正在交接的小弟出去面试，气冲冲的回来吐槽面试官不会面试，竟然会问CSS选择器，在我苦口婆心的劝说下，小弟终于意识到CSS选择器的重要性，为了让他能够找到一个好工作，我便写了这篇文章供他学习。 简介定义我们都知道一条CSS样式定义有两部分组成，形式如下：选择器 {}，在{}之前的部分就是选择器。选择器指明了{}中的样式的作用对象，也就是样式作用于网页中的哪些元素。 作用CSS选择器用于定位我们想要给予样式的 HTML 元素，但不只是在 CSS 中，JavaScript 对 CSS 的选择器也是支持的，比如document.querySelector、document.querySelectorAll。 分类基本选择器 选择器 名称 描述 版本 * 通配选择器 选择所有的元素 CSS2 element 元素选择器 选择指定的元素 CSS1 #idName id选择器 选择id属性等于idName的元素 CSS1 .className 类选择器 选择class属性包含className的元素 CSS1 通配符选择器「 * 」这个选择器是匹配页面中所有的元素，选择器也能选取另一个元素中的所有元素，不过这个选择器的效率比较低，一般用来清除浏览器的默认样式。123456789/* 清楚浏览器默认样式 */* &#123; margin: 0; padding: 0;&#125;div * &#123; color: red;&#125; 1234&lt;div&gt; &lt;span&gt;span&lt;/span&gt; &lt;p&gt;p&lt;/p&gt;&lt;/div&gt; span，p 都变红。 元素选择器「 element 」通过标签名来选择元素。123div &#123; color: red;&#125; 12345&lt;div&gt;div1&lt;/div&gt;&lt;p&gt; &lt;div&gt;div2&lt;/div&gt;&lt;/p&gt;&lt;div&gt;div3&lt;/div&gt; div1，div2，div3 都变红 id选择器「 #idName 」以id属性来命名，在页面中只能出现一次，具有唯一性，并且权重值最高，相当于一个人的身份证。注意：应用于多个元素，样式同样生效。12&lt;div id="box"&gt;div&lt;/div&gt;&lt;p id="box"&gt;p&lt;/p&gt; 123#box &#123; color: red;&#125; div，p都变红。 类选择器 「 .className 」class选择器/类选择器/用class属性给元素命名，在页面中可以出现很多次，相当于人的名字。12&lt;div class="box"&gt;div&lt;/div&gt;&lt;p class="box"&gt;p&lt;/p&gt; 123.box &#123; color: red;&#125; div，p 都变红。 组合选择器 选择器 名称 描述 版本 E,F 多元素选择器 同时匹配元素E或元素F CSS1 E F 后代选择器 匹配E元素所有的后代（不只是子元素、子元素向下递归）元素F CSS1 E &gt; F 子元素选择器 匹配E元素的所有直接子元素F CSS2 E + F 相邻兄弟选择器 匹配E元素之后的相邻的同级元素F CSS2 E ~ F 普通兄弟选择器 匹配E元素之后的同级元素F（无论直接相邻与否） CSS3 多元素选择器 「 E,F 」选择所有的E元素和F元素，中间用逗号隔开。12&lt;div&gt;div&lt;/div&gt;&lt;p&gt;p&lt;/p&gt; 1234// 同时匹配div标签和p标签div, p &#123; color: red;&#125; div，p 都变红。 后代选择器 「 E F 」选择所有被E元素包含的所有的F元素（包括子、孙），中间用空格隔开。1234567&lt;div&gt; &lt;span&gt;span1&lt;/span&gt; &lt;p&gt; &lt;span&gt;span2&lt;/span&gt; &lt;/p&gt; &lt;span&gt;span3&lt;/span&gt;&lt;/div&gt; 123div span &#123; color: red;&#125; span1，span2，span3 都变红。 子元素选择器 「 E &gt; F 」选择所有作为E元素的直接子元素F，对更深一层的元素不起作用，用 &gt; 表示。1234567&lt;div&gt; &lt;span&gt;span1&lt;/span&gt; &lt;p&gt; &lt;span&gt;span2&lt;/span&gt; &lt;/p&gt; &lt;span&gt;span3&lt;/span&gt;&lt;/div&gt; 123div &gt; span &#123; color: red;&#125; span1，span3 变红。 相邻兄弟选择器 「 E + F 」选择紧跟E元素后的F元素，用 + 表示，选择相邻的第一个兄弟元素。1234567&lt;p&gt;p1&lt;/p&gt;&lt;div&gt;div &lt;p&gt;p2&lt;/p&gt;&lt;/div&gt;&lt;p&gt;p3&lt;/p&gt;&lt;span&gt;span&lt;/span&gt;&lt;p&gt;p4&lt;/p&gt; 123div + p &#123; color: red;&#125; p3 变红。 普通兄弟选择器 「 E ~ F 」选择E元素之后的所有同级元素F（无论直接相邻与否），作用于多个元素，用 ~ 隔开。1234567&lt;p&gt;p1&lt;/p&gt;&lt;div&gt;div &lt;p&gt;p2&lt;/p&gt;&lt;/div&gt;&lt;p&gt;p3&lt;/p&gt;&lt;span&gt;span&lt;/span&gt;&lt;p&gt;p4&lt;/p&gt; 123div ~ p &#123; color: red;&#125; p3，p4 变红。 属性选择器 选择器 例子 例子描述 版本 [attribute] [target] 选择所有带有target属性元素。 CSS2 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素。 CSS2 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 CSS2 [attribute&#124;=value] [lang&#124;=en] 选择 lang 属性值以 “en” 开头的所有元素。 CSS2 [attribute^=value]] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 a 元素。 CSS3 [attribute$=value] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 a 元素。 CSS3 [attribute*=value] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 a 元素。 CSS3 伪类选择器 选择器 例子 例子描述 版本 :link a:link 选择所有未被访问的链接。 CSS1 :visited a:visited 选择所有已被访问的链接。 CSS1 :active a:active 选择活动链接。 CSS1 :hover a:hover 选择鼠标指针位于其上的链接。 CSS1 :focus input:focus 选择获得焦点的 input 元素。 CSS2 伪元素选择器 选择器 例子 例子描述 版本 :first-letter p:first-letter 选择每个 p 元素的首字母。 CSS1 :first-line p:first-line 选择每个 p 元素的首行。 CSS1 :first-child p:first-child 选择属于父元素的第一个子元素的每个 p 元素。 CSS2 :before p:before 在每个 p 元素的内容之前插入内容。 CSS2 :after p:after 在每个 p 元素的内容之后插入内容。 CSS2 :lang(language) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 p 元素。 CSS2 补充内容更多伪类、伪元素选择器，见如下截图： 优先级当创建的样式表越来越复杂时，一个标签的样式将会受到越来越多的影响，用户看到的其实是通过层叠计算得来的，通俗点讲就是先计算再重叠得来的。 计算指的是用户代理（浏览器只是用户代理的一种“实例”）在渲染HTML的时候，对CSS进行层叠计算的过程。 层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在CSS处于核心地位，CSS的全称层叠样式表正是强调了这一点。 说到这，我们就不得不说一下优先级。优先级是决定不同选择器的相同样式规则对同一元素的生效情况，优先级高的将覆盖优先级低的样式规则。而优先级又受到样式来源和选择器特殊性的影响。 特指度说到优先级，我们又需要讲一下另一个概念：特指度。特指度表示一个css选择器表达式的重要程度，可以通过一个公式来计算出一个数值，数越大，越重要。这个计算叫做“I-C-E”计算公式；1.I——Id：1002.C——Class（类 | 伪类 | 属性选择）：103.E——Element（标签 | 伪元素）：14. 通用选择器：0 即针对一个css选择器表达式，遇到一个id就往特指度数值中加100，遇到一个class就往特指度数值中加10，遇到一个element就往特指度数值中加1。 下面举几个css表达式的特指度计算结果： CSS选择器表达式 特指度计算结果 p 1 p.large 11 p#large 101 div p#large 102 div p#large ul.list 113 div p#large ul.list li 114 还有一个特别重要的点：!important优先级最高，高于上面一切。通配（*） 选择器最低，低于一切。 错误的说法在学习过程中，我们可能发现给选择器加权值的说法，即 ID 选择器权值为 100，类选择器权值为 10，标签选择器权值为 1，当一个选择器由多个 ID 选择器、类选择器或标签选择器组成时，则将所有权值相加，然后再比较权值。这种说法其实是有问题的。比如一个由 11 个类选择器组成的选择器和一个由 1 个 ID 选择器组成的选择器指向同一个标签，按理说 110 &gt; 100，应该应用前者的样式，然而事实是应用后者的样式。错误的原因是：选择器的权值不能进位。虽然 11 个类选择器组成的选择器的总权值为 110，但因为 11 个均为类选择器，所以其实总权值最多不能超过 100， 我们可以理解为 99.99，所以最终应用后者样式。 多重样式间的优先级w3school给出的优先级顺序从低到高是： 浏览器缺省设置外部样式表内部样式表（位于 head 标签内部）内联样式（在 HTML 元素内部） 但如果外部样式表放在内部样式表后面其实是会覆盖内部样式表的，举个例子： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; color: red; &#125; &lt;/style&gt; &lt;link rel="stylesheet" type="text/css" href="index.css" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123.box &#123; color: blue;&#125; 最终得到的是蓝色的字体，很明显，内部样式被放在后面的外部样式覆盖了。所以我更倾向于认为外部样式表和内部样式表具有相同的优先级。 除了选择器，样式自身还可以继承和提升优先级，规则如下：一：从祖先元素继承来的样式优先级低于通用选择器；甚至低于浏览器的缺省设置，比如最常见的，重置链接的默认样式时必须写在链接元素上，放在祖先元素中是没有卵用滴二：使用大杀器!important可将样式提升到最高等级，不管这个样式在哪个样式表或选择器中；如果在同一样式中出现了多个!important，就得看上面的权重规则进行pk了。 因此多重样式间遵循：继承来的样式 &lt; 浏览器缺省设置 &lt; 外部样式表 = 内部样式表 &lt; 内联样式 总结优先级正确的排序是： 1important &gt; 内联样式 &gt; ID &gt; 类 | 伪类 | 属性选择 &gt; 标签 | 伪元素 &gt; 继承 &gt; 通配符]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>selector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git clone 太慢的解决方式]]></title>
    <url>%2F2018%2F08%2F01%2Fgithub-do-slow.html</url>
    <content type="text"><![CDATA[众所周知，虽然github没有在国内被墙，但是依然访问很慢。在 clone 项目到本地时，如果项目很大（比如我clone antd的时候估算了一下大概有一百多兆），那就很麻烦了。这里介绍一些比较通用的解决方案。在我机器上 clone 速度从二十几k提高到二百多k，瞬间拽的不要不要的。 一、查找域名对应的ip地址，并修改hosts文件12151.101.76.249 github.global.ssl.fastly.net 192.30.253.112 github.com]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 异步编程]]></title>
    <url>%2F2018%2F07%2F30%2Fjavascript-async-programme.html</url>
    <content type="text"><![CDATA[背景我们都知道，Javascript 语言的执行环境是“单线程”的。单线程在程序执行时，一次只能完成一个任务。如果有多个任务，就必须排队，前面一个任务完成，在执行后面一个任务，以此类推。 这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。 基于JavaScript的单线程语言执行环境及其不足，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。 同步，即任务一步一步执行，当前任务执行完毕后才能继续执行后续任务；异步则是后续任务不需等待前一个任务结束也可执行，当前任务执行结束后可以通过状态、通知或回调来通知调用者。 异步编程实现回调函数回调函数是异步编程最基本的方法。 假定有两个函数 f1 和 f2，f2 依赖 f1 的执行结果。 123f1();f2(); 如果 f1 是一个很耗时的任务，这时我就可以考虑把 f2 写出 f1 的回调函数。 12345678function f1(callback) &#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000);&#125;f1(f2); 采用回调函数，我们就把同步操作变成了异步操作，这样 f1 就不会堵塞主程序运行，相当于先执行主程序逻辑，将耗时的操作推迟执行。 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 事件监听采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 假定有两个函数 f1 和 f2，f1绑定一个 done 事件（这里采用的jQuery的写法）1f1.on('done', f2); 对 f1 进行改写： 123456function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger('done'); &#125;, 1000);&#125; 上述代码表示，执行完 f1 任务，立即触发 done 事件，当 f1 发生 done 事件，就执行 f2。 事件监听的优点是可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 数据类型]]></title>
    <url>%2F2018%2F07%2F29%2Fjavascript-types.html</url>
    <content type="text"><![CDATA[概述JavaScript 每一个值，都属于某一种数据类型，JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值）。 数值（number）：整数和小数（比如1和3.14）；字符串（string）：文本（比如Hello World）；布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）；undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值；null：表示空值，即此处的值为空；对象（object）：各种值组成的集合。 通常，数值、字符串、布尔值这三种类型，合称为原始数据类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成数据类型（complex type）的值，即引用数据类型，因为一个对象往往是多个原始类型的值的合成，对象可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。 基本数据类型JavaScript中有5种基本数据类型，分别是Number、String、Boolean、Undefined、Null。 基本数据类型存放在栈中基本数据类型是存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以自由分配。基本类型是直接按值存放的，所以我们可以直接操作保存在变量中的实际的值。 基本数据类型值不可变(immutable)性质基本类型是不可变的(immutable)，只有对象是可变的(mutable)。有时我们会尝试“改变”字符串的内容，但在JS中，任何看似对string值的”修改”操作，实际都是创建新的string值。任何方法都无法改变一个基本类型的值：12345678910var str = "abc";str[0] = "d";str.name = "efg";str.method = function() &#123;&#125;;console.log(str); // abcconsole.log(str[0]); // aconsole.log(str.name); // undefinedconsole.log(str.method); // undefined 基本类型的比较是值的比较基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如：123var a = 1;var b = 1;console.log(a === b); // true 比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如123var a = 1;var b = true;console.log(a == b); // true 引用数据类型引用数据类型存放在堆中引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配。 引用类型值可变引用类型的值是可变的。123456789var obj = &#123; x: 0&#125;;obj.x = 100;console.log(obj.x)// 100 被修改obj = &#123; // 等同于重新赋值，重新开辟内存，不是修改 x: 1000&#125;; console.log(obj.x)// 1000 被修改 引用类型的比较是引用的比较每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： 123var a = [1,2,3];var b = [1,2,3];console.log(a === b); // false 传值与传址 JavaScript 所有函数的参数都是按值传递的,也就是说把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 基本数据类型：在我们进行赋值或方法调用操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中，前后两个变量是两个独立相互不影响的变量，比如：123456var a = 10;var b = a;a ++ ;console.log(a); // 11console.log(b); // 10 引用数据类型：在引用类型的赋值或方法调用时，传递的是值的内存地址，也就是说传递前和传递后都指向栈中同一个引用（也就是同一个内存空间），这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响，比如1234567891011var person = &#123; name : "Tom"&#125;;function obj(peo) &#123; peo.name = "Jerry"; peo = &#123; // 等同于重新赋值，重新开辟内存，不是修改 name : "Jack" &#125;;&#125;obj(person);console.log(person.name); // Jerry 数据结构栈数据结构与C/C++不同，JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以简单粗暴的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思维来实现一些功能，比如JavaScript的执行上下文。执行上下文的执行顺序借用了栈数据结构的存取方式，因此理解栈数据结构的原理与特点十分重要。 要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析，如下图左侧： 这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。图中已经详细的表明了栈空间的存储原理。 堆数据结构堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似。 书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。 队列在JavaScript中，理解队列数据结构的目的主要是为了清晰的明白事件循环（Event Loop）的机制到底是怎么回事。 队列是一种先进先出（FIFO）的数据结构。正如排队过安检一样，排在队伍前面的人一定是最先过检的人，用以下的图示可以清楚的理解队列的原理： 引用数据类型与堆内存与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。 123456var a1 = 0; // 原始变量var a2 = 'this is string'; // 原始变量var a3 = null; // 原始变量var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。 在前端面试中我们常常会遇到这样一个类似的题目：123456// demo01.jsvar a = 20;var b = a;b = 30;// 这时a的值是多少？ 123456// demo02.jsvar m = &#123; a: 10, b: 20 &#125;var n = m;n.a = 15;// 这时m.a的值是多少 在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b = a执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。在demo02中，我们通过var n = m执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。 因此当我改变n时，m也发生了变化。这就是引用类型的特性。 拷贝首先深拷贝和浅拷贝只针对像 Object, Array 这样的复杂对象的。简单来说，浅拷贝只拷贝一层对象的属性，而深拷贝则递归拷贝了所有层级。 浅拷贝下面是一个简单的浅拷贝实现： 123456789101112var obj = &#123; a:1, arr: [2,3] &#125;;var shallowObj = shallowCopy(obj);function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125; 因为浅拷贝只会将对象的各个属性进行依次拷贝，并不会进行递归拷贝，而 JavaScript 存储对象都是存地址的，所以浅拷贝会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址，大概的示意图如下： 导致的结果就是： 12shallowObj.arr[1] = 5;obj.arr[1] // = 5 深拷贝而深拷贝则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深拷贝的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。 12var obj = &#123; a:1, arr: [1,2] &#125;;var obj2 = deepCopy(obj); 结果如下面的示意图所示： 需要注意的是，如果对象比较大，层级也比较多，深拷贝会带来性能上的问题。在遇到需要采用深拷贝的场景时，可以考虑有没有其他替代的方案。在实际的应用场景中，也是浅拷贝更为常用。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>types</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tree-shaking-tutorial]]></title>
    <url>%2F2018%2F07%2F28%2Ftree-shaking-tutorial.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 相等运算符]]></title>
    <url>%2F2018%2F07%2F26%2Fjavascript-equality-operator.html</url>
    <content type="text"><![CDATA[概述JavaScript中，相等运算符（==）是一个很让人头痛的运算符，它的语法行为多变，不符合直觉。比如下面这个表达式，它的值是什么？想知道答案或语言内部怎么处理，我们可以去查看规格。规格对每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现的算法细节。相等运算符的总体的行为描述：相等运算符用于比较两个值，返回true或false。 抽象比较算法 在执行抽象相等比较算法的过程中，会发现会将xy操作数进行隐式类型转化的，这也是==运算符副作用的体现。 ToPrimitive() toPrimitive方法的目的就是将输入的参数转化成非对象类型。 DefaultValue() 由于0的类型是数值，null的类型是 Null（这是规格4.3.13 小节的规定，是内部 Type 运算的结果，跟typeof运算符无关）。因此上面的前 11 步都得不到结果，要到第 12 步才能得到false。10 == null // 输出结果：false 解析：0 数值 null 对象 返回 false [] == false正确输出结果：true 当js引擎解析到[] == false 的时候，会解析执行左右表达式，并分别取出执行结果的值，上述分别为数组对象和false。然后将数组设置为x，false设置为y按抽象比较算法执行。在执行抽象相等比较算法的过程中，会发现会将xy操作数进行隐式类型转化的，这也是==运算符副作用的体现。 对于 [] == false的问题应该关注上述步骤的78910步骤。因为[]和false不是同一类型，所以执行到8的时候会将false调用toNumber()内部方法转化成数字，然后在执行抽象相等比较算法。toNumber（）会将false转化成+0. 然后将[] == +0.继续进行比较算法，执行到10 之后开始使用toPrimitive( )对[]进行转化。 [] == []正确输出结果：false 0 == null正确输出结果：false [] == {}正确输出结果：false 其他例子123456789null == undefined; // 如果x是null，y是undefined，返回true。1 == true // 如果Type(x)是布尔值，返回ToNumber(x) == y的结果，true转化为数值1，所以输出结果：true 2 == true // 如果Type(x)是布尔值，返回ToNumber(x) == y的结果，true转化为数值1，所以输出结果：false0 == false // 如果Type(x)是布尔值，返回ToNumber(x) == y的结果，true转化为数值0，所以输出结果：true0 == "" // 如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) == y的结果，""转化为数值0，所以输出结果：trueundefined == ""; // falsenull == false; // falseundefined == false; // false]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>equality</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 函数]]></title>
    <url>%2F2018%2F07%2F24%2Fjavascript-function.html</url>
    <content type="text"><![CDATA[函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。 立即执行函数在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。 有时，我们需要在定义函数之后，立即调用该函数。这时，我们不能在函数的定义之后加上圆括号，这会产生语法错误。12function()&#123; /* code */ &#125;();// SyntaxError: Unexpected token ( 产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。12345// 语句function f() &#123;&#125;// 表达式var f = function f() &#123;&#125; 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做立即执行函数（Immediately-Invoked Function Expression），简称 IIFE。 注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。 123// 报错(function()&#123; /* code */ &#125;())(function()&#123; /* code */ &#125;()) 推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。123var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;(); 甚至像下面这样写，也是可以的。1234!function () &#123; /* code */ &#125;();~function () &#123; /* code */ &#125;();-function () &#123; /* code */ &#125;();+function () &#123; /* code */ &#125;(); 定义简单说立即执行函数就是声明一个匿名函数、马上调用这个匿名函数。 上面是一个典型的立即执行函数。首先，声明一个匿名函数 function(){alert(‘我是匿名函数’)}。然后，在匿名函数后面接一对括号 ()，调用这个匿名函数。 作用只有一个作用：创建一个独立的作用域。 这个作用域里面的变量，外面访问不到（即避免「变量污染」）。 以一个著名的面试题为例： 123456var liList = ul.getElementsByTagName('li')for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5 &#125;&#125; 为什么 alert 的总是 6 呢，因为 i 是贯穿整个作用域的，而不是给每个 li 分配了一个 i，如下： 那么怎么解决这个问题呢？用立即执行函数给每个 li 创造一个独立作用域即可：12345678var liList = ul.getElementsByTagName('li')for(var i=0; i&lt;6; i++)&#123; !function(ii)&#123; liList[ii].onclick = function()&#123; alert(ii) // 0、1、2、3、4、5 &#125; &#125;(i)&#125; 在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 打包后文件分析]]></title>
    <url>%2F2018%2F07%2F23%2Fwebpack-analyze-packaged-file.html</url>
    <content type="text"><![CDATA[版本：v4.17.1 前言Webpack 是目前使用最为火热的打包工具，没有之一，每月有数百万的下载量，为成千上万的网站和应用提供支持。我们网页拥有着复杂的JavaScript代码和一大堆依赖包，webpack 把我们的项目当做一个整体，通过一个给定的入口文件（如：index.js），Webpack将从这个文件开始分析我们的项目的所有依赖文件，然后经过一系列处理，最后打包为一个（或多个）浏览器可识别的JavaScript文件。可我们是否想过 Webpack 输出的 bundle.js 是什么样子的吗？ 为什么原来一个个的模块文件被合并成了一个单独的文件？为什么输出文件（如：bundle.js）能直接运行在浏览器中？现在我们就来详细的分析 webpack 打包后文件。 打包源码12345678910111213141516171819202122232425// webpack.config.jsconst path = require('path');module.exports = &#123; devtool: "source-map", mode: 'development', entry: './main.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;&#125;// main.jsimport helloWorld from './src/index1';import worldHello from './src/index2';console.log(helloWorld, worldHello);export default './main.js';// index1.jsexport default 'Hello World';// index2.jsexport default 'World Hello'; 分析打包后文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// webpackBootstrap 启动函数// modules 即为存放所有模块的对象，对象中的每一个属性都是一个函数(function(modules) &#123; // 安装过的模块都存放在这里面，作用是把已经加载过的模块缓存在内存中，提升性能 var installedModules = &#123;&#125;; // 加载参数对象中每一个模块，moduleId 为要加载模块对象的 key // 函数作用和 Node.js 中 require 语句相似 function __webpack_require__(moduleId) &#123; // 如果需要加载的模块已经被加载过，就直接从内存缓存中返回 if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // 如果缓存中不存在需要加载的模块，就新建一个模块，并把它存在缓存中 // webpack1的时候都是全称，现在估计为了省点空间，都变成了id =&gt; i, load =&gt; l var module = installedModules[moduleId] = &#123; // 加载模块对象的 key i: moduleId, // 该模块是否已经加载完毕 l: false, // 该模块的导出值 exports: &#123;&#125; &#125;; // 从 modules 中获取 key 为 moduleId 的模块对应的函数 // 再调用这个函数，同时把函数需要的参数传入 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 把这个模块标记为已加载 module.l = true; // 返回这个模块的导出值 return module.exports; &#125; // 在源文件中，直接使用__webpack_modules__，生成文件用__webpack_require__.m替换 __webpack_require__.m = modules; // 暴露module缓存 __webpack_require__.c = installedModules; // 为harmory exports 定义 getter function, configurable=false表明，此属性不能修改 // 例如export const，由于是常量，需要用__webpack_require__.d进行定义 __webpack_require__.d = function(exports, name, getter) &#123; if(!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125; &#125;; // define __esModule on exports __webpack_require__.r = function(exports) &#123; if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123; Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;); &#125; Object.defineProperty(exports, '__esModule', &#123; value: true &#125;); &#125;; // create a fake namespace object // mode &amp; 1: value is a module id, require it // mode &amp; 2: merge all properties of value into the ns // mode &amp; 4: return value when already ns object // mode &amp; 8|1: behave like require __webpack_require__.t = function(value, mode) &#123; if(mode &amp; 1) value = __webpack_require__(value); if(mode &amp; 8) return value; if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value; var ns = Object.create(null); __webpack_require__.r(ns); Object.defineProperty(ns, 'default', &#123; enumerable: true, value: value &#125;); if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key)); return ns; &#125;; // 兼容 non-harmony 模块，这些模块如果设了__esModule属性，则被标记为non-harmony __webpack_require__.n = function(module) &#123; var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module['default']; &#125; : function getModuleExports() &#123; return module; &#125;; __webpack_require__.d(getter, 'a', getter); return getter; &#125;; // Object.prototype.hasOwnProperty.call __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; // Webpack 配置中的 publicPath，用于加载被分割出去的异步代码 __webpack_require__.p = ""; // 使用 __webpack_require__ 去加载 key 为 ./main.js 的模块，并且返回该模块导出的内容 // key 为 ./main.js 的模块就是 main.js 对应的文件，也就是执行入口模块 // __webpack_require__.s 的含义是启动模块对应的 key return __webpack_require__(__webpack_require__.s = "./main.js");&#125;)(&#123;// 所有的模块都存放在了一个对象里，根据每个模块在对象的 key 来区分和定位模块"./main.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); var _src_index1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/index1.js"); var _src_index2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/index2.js"); console.log(_src_index1__WEBPACK_IMPORTED_MODULE_0__["default"], _src_index2__WEBPACK_IMPORTED_MODULE_1__["default"]); __webpack_exports__["default"] = ('./main.js'); &#125;),"./src/index1.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); __webpack_exports__["default"] = ('Hello World'); &#125;),"./src/index2.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); __webpack_exports__["default"] = ('World Hello'); &#125;)&#125;); 上面这段 js 就是使用 webpack 编译后的代码，其中就包含了 webpack 的运行时代码，其中就是关于模块的实现。 以上看上去复杂的代码其实是一个立即执行函数，可以简写为如下：123456789101112(function(modules) &#123; // 模拟 require 语句 function __webpack_require__() &#123; &#125; // 执行存放所有模块中 key 值为 ./main.js 的模块 __webpack_require__('./main.js');&#125;)(&#123; "./main.js": fn // 函数&#125;) 自执行函数的入参是个对象，这个对象包含了所有的模块，包裹在函数中。自执行函数体里的逻辑就是处理模块的逻辑。关键在于__webpack_require__函数，这个函数就是require或者是import的替代，我们可以看到在函数体内先定义了这个函数，然后调用了它。这里会传入一个moduleId，这个例子中是./main.js，也就是我们的入口模块main.js的内容。 我们再看__webpack_require__内执行了：12modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);return module.exports； 即从入参的 modules 对象中取第一个函数进行调用，并入参： module module.exports webpack_require 我们再看第一个函数（即入口模块）的逻辑： 12345678(function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); var _src_index1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/index1.js"); var _src_index2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/index2.js"); console.log(_src_index1__WEBPACK_IMPORTED_MODULE_0__["default"], _src_index2__WEBPACK_IMPORTED_MODULE_1__["default"]); __webpack_exports__["default"] = ('./main.js');&#125;) 我们可以看到入口模块又调用了__webpack_require__(&quot;./src/index1.js&quot;)和__webpack_require__(&quot;./src/index2.js&quot;)去引用入参数组里的第2和第3个函数。 然后会将入参的__webpack_exports__对象添加default属性，并赋值。这里的__webpack_exports__就是这个模块的module.exports通过对象的引用传参，间接的给module.exports添加属性，这就是webpack模块化的实现原理。 最后会将module.exports return出来。就完成了__webpack_require__函数的使命。比如在入口模块中又调用了__webpack_require__(&quot;./src/index1.js&quot;)，就会得到这个模块返回的module.exports。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用lerna优雅地管理多个package]]></title>
    <url>%2F2018%2F07%2F21%2Flerna-repo.html</url>
    <content type="text"><![CDATA[背景对于维护过多个package的同学来说，都会遇到一个选择器：这些package是放在一个仓库里维护还是放在多个仓库里单独维护，数量较少的时候，多个仓库维护不会有太大问题，但是当package数量逐渐增多时，一些问题逐渐暴露出来： package之间相互依赖，开发人员需要在本地手动执行npm link，维护版本号的更替； issue难以统一追踪，管理，因为其分散在独立的repo里； 每一个package都包含独立的node_modules，而且大部分都包含babel,webpack等开发时依赖，安装耗时冗余并且占用过多空间。 yarn workspaces命令在根目录安装 npm 包，以 danger 为例：$ yarn add danger --dev -W]]></content>
      <categories>
        <category>lerna</category>
      </categories>
      <tags>
        <tag>lerna</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 文本两边对齐有些文字的间距就被拉开了]]></title>
    <url>%2F2018%2F07%2F18%2Fcss-text-justify.html</url>
    <content type="text"><![CDATA[有时为了保持文章段落的美观，我们希望文章段落最好能够两边对齐，我们一般的解决办法是使用text-align: justify，但遇到中英混搭的段落时，文本之间距离被拉大。这个问题原因很简单，这个所谓的两端对齐，指的就是无论这一行当中有多少内容，都需要撑满整行（最后一行除外）。 如果我们希望实现的是左右两端都是比较整齐的，又是英文的状态，不希望出现右边有比较大空缺的话，可以使用正常的左对齐，然后配合word-break进行控制，word-break控制的是单词的切断方式，默认情况下，英文单词是不允许被随意中断的，但是如果我们添加以下代码：1word-break: break-all;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[danger 入门教程]]></title>
    <url>%2F2018%2F07%2F14%2Fdanger-tutorial.html</url>
    <content type="text"><![CDATA[背景在 Code Review 时，我们可能经常要去检查各种事情，比如 pr 是否提到了 develop 分支、commit 中是否有毒（存在 merge commit）、禁止某些文件在 pr 中有修改、pr 的描述是否正常等等各种事情。有时我们会忘记检查这些事情，merge 之后才发现，这个就非常尴尬了。 快速入门指南获取我们建议通过 Yarn 安装 Danger，当然我们也可以使用 npm CLI。 安装我们这边以 Yarn 为例：1yarn add danger --dev 创建 Danger 配置文件 dangerfile.js 或 dangerfile.ts]]></content>
      <categories>
        <category>danger</category>
      </categories>
      <tags>
        <tag>danger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 使用指南]]></title>
    <url>%2F2018%2F07%2F13%2Fwebpack-tutorial.html</url>
    <content type="text"><![CDATA[使用指南require.contextrequire.context：创建自己的（模块）上下文，这个方法有 3 个参数：要搜索的文件夹目录，是否还应该搜索它的子目录，以及一个匹配文件的正则表达式。1require.context(directory, useSubdirectories = false, regExp = /^\.\//) 1234567891011121314151617/*** 创建一个* 包含了 test 文件夹* 不包含子目录下面的* 所有文件名以 `.test.js` 结尾的、* 能被 require 请求到的文件的上下文。*/require.context("./test", false, /\.test\.js$/);/*** 创建一个* 包含了父级文件夹* 包含子目录下面的* 所有文件名以 `.stories.js` 结尾的* 能被 require 请求到的文件的上下文。*/require.context("../", true, /\.stories\.js$/); require.context模块导出（返回）一个（require）函数，这个函数可以接收一个参数：request 函数 – 这里的 request 应该是指在 require() 语句中的表达式。require.context 第一个参数不能是变量，webpack在编译阶段无法定位目录。导出的方法有 3 个属性： resolve, keys, id。resolve：函数，它返回请求被解析后得到的模块 id。keys：函数，它返回一个数组，由所有可能被上下文模块处理的请求组成。id：上下文模块里面所包含的模块 id. 它可能在你使用 module.hot.accept 的时候被用到。 示例一：引入多张图片123import img1 from '../../assets/img1.jpeg';import img2 from '../../assets/img2.jpeg';import img3 from '../../assets/img3.jpeg'; 上面页面上需要的图片很多，这样做太麻烦了，有没有批量引入的办法呢？12const requireContext = require.context("../../assets", false, /^\.\/.*\.jpeg$/);const images = requireContext.keys().map(requireContext); 示例二：多个js文件12const context = require.context('./', false, /\.js$/);const models = context.keys().filter(item =&gt; item !== './index.js').map(context); 问题指南webpack-cli（v4）Q：由于webpack-cli从webpack包里面分离出来了，未安装webpack-cli会产生以下错误：1234567One CLI for webpack must be installed. These are recommended choices, delivered as separate packages: - webpack-cli (https://github.com/webpack/webpack-cli) The original webpack full-featured CLI. - webpack-command (https://github.com/webpack-contrib/webpack-command) A lightweight, opinionated webpack CLI.We will use &quot;npm&quot; to install the CLI via &quot;npm install -D&quot;.Which one do you like to install (webpack-cli/webpack-command): A：1$ npm install webpack-cli -D mode（v4）Q：未设置mode属性123WARNING in configurationThe &apos;mode&apos; option has not been set, webpack will fallback to &apos;production&apos; for this value. Set &apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults for each environment.You can also set it to &apos;none&apos; to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/ A：development：开发模式，webpack会默认配置常用于开发的参数，如输出运行时的错误信息等production：产品模式，webpack会默认配置常用语产品构建的餐宿，如压缩代码等12345678// 配置文件module.exports = &#123; mode: 'development' // mode: 'production'&#125;// 命令行webpack --mode developmentwebpack --mode production]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件编程]]></title>
    <url>%2F2018%2F07%2F12%2Fsoftware-programm-method.html</url>
    <content type="text"><![CDATA[编程范式声明式编程(Declarative)声明式编程：告诉“机器”我们想要的是什么(what)，让机器想出如何去做(how)。比如react和vue，我们只负责想要什么数据、事件等等，具体怎么渲染那是react和vue的事情。 命令式编程(Imperative)命令式编程：命令“机器”如何去做事情(how)，不管我们想要的是什么(what)，它都会按照我们的命令实现。比如jquery命令式渲染，我们需要知道如何增加，删除、更改、插入等等，渲染工作需要自己完成！ 数据驱动所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。 脚本语言JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。]]></content>
      <categories>
        <category>programm</category>
      </categories>
      <tags>
        <tag>programm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA_HOME环境变量失效的解决办法]]></title>
    <url>%2F2018%2F07%2F09%2Fjava-dev-variable-failure.html</url>
    <content type="text"><![CDATA[今天团队中一个同事搭建java开发环境，遇到了一个很奇怪的问题。在cmd中输入java -version会报如下错误:1Error:could not open `D:\Java\jre7\lib\amd64\jvm.cfg' 原因是因为重装导致的。 解决办法： Path系统环境变量中，把%JAVA_HOME%\bin调整到最前面即可。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-saga-source-analysis]]></title>
    <url>%2F2018%2F07%2F08%2Fredux-saga-source-analysis.html</url>
    <content type="text"></content>
      <categories>
        <category>redux-saga</category>
      </categories>
      <tags>
        <tag>redux-saga</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深聊import、require、export、module.exports]]></title>
    <url>%2F2018%2F07%2F05%2Fmodule-import-require.html</url>
    <content type="text"><![CDATA[前言ES6标准发布后，module成为标准，标准的使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口，甚至有时候也会常常看到两者互用的场景。只有把这些语法搞清楚才能在未来的标准编程游刃有余。 webpack 模块化webpack 本身维护了一套模块系统，这套模块系统兼容了所有前端历史进程下的模块规范，包括 amd commonjs es6 等，本文主要针对 commonjs es6 规范进行说明。模块化的实现其实就在最后编译的文件内。 我们以一个小 demo 为例12345678910111213141516171819202122232425// webpack.config.jsconst path = require('path');module.exports = &#123; devtool: "source-map", mode: 'development', entry: './main.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;&#125;// main.jsimport helloWorld from './src/index1';import worldHello from './src/index2';console.log(helloWorld, worldHello);export default './main.js';// index1.jsexport default 'Hello World';// index2.jsexport default 'World Hello'; demo 打包后文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// webpackBootstrap 启动函数// modules 即为存放所有模块的对象，对象中的每一个属性都是一个函数(function(modules) &#123; // 安装过的模块都存放在这里面，作用是把已经加载过的模块缓存在内存中，提升性能 var installedModules = &#123;&#125;; // 加载参数对象中每一个模块，moduleId 为要加载模块对象的 key // 函数作用和 Node.js 中 require 语句相似 function __webpack_require__(moduleId) &#123; // 如果需要加载的模块已经被加载过，就直接从内存缓存中返回 if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // 如果缓存中不存在需要加载的模块，就新建一个模块，并把它存在缓存中 // webpack1的时候都是全称，现在估计为了省点空间，都变成了id =&gt; i, load =&gt; l var module = installedModules[moduleId] = &#123; // 加载模块对象的 key i: moduleId, // 该模块是否已经加载完毕 l: false, // 该模块的导出值 exports: &#123;&#125; &#125;; // 从 modules 中获取 key 为 moduleId 的模块对应的函数 // 再调用这个函数，同时把函数需要的参数传入 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 把这个模块标记为已加载 module.l = true; // 返回这个模块的导出值 return module.exports; &#125; // 在源文件中，直接使用__webpack_modules__，生成文件用__webpack_require__.m替换 __webpack_require__.m = modules; // 暴露module缓存 __webpack_require__.c = installedModules; // 为harmory exports 定义 getter function, configurable=false表明，此属性不能修改 // 例如export const，由于是常量，需要用__webpack_require__.d进行定义 __webpack_require__.d = function(exports, name, getter) &#123; if(!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125; &#125;; // define __esModule on exports __webpack_require__.r = function(exports) &#123; if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123; Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;); &#125; Object.defineProperty(exports, '__esModule', &#123; value: true &#125;); &#125;; // create a fake namespace object // mode &amp; 1: value is a module id, require it // mode &amp; 2: merge all properties of value into the ns // mode &amp; 4: return value when already ns object // mode &amp; 8|1: behave like require __webpack_require__.t = function(value, mode) &#123; if(mode &amp; 1) value = __webpack_require__(value); if(mode &amp; 8) return value; if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value; var ns = Object.create(null); __webpack_require__.r(ns); Object.defineProperty(ns, 'default', &#123; enumerable: true, value: value &#125;); if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key)); return ns; &#125;; // 兼容 non-harmony 模块，这些模块如果设了__esModule属性，则被标记为non-harmony __webpack_require__.n = function(module) &#123; var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module['default']; &#125; : function getModuleExports() &#123; return module; &#125;; __webpack_require__.d(getter, 'a', getter); return getter; &#125;; // Object.prototype.hasOwnProperty.call __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; // Webpack 配置中的 publicPath，用于加载被分割出去的异步代码 __webpack_require__.p = ""; // 使用 __webpack_require__ 去加载 key 为 ./main.js 的模块，并且返回该模块导出的内容 // key 为 ./main.js 的模块就是 main.js 对应的文件，也就是执行入口模块 // __webpack_require__.s 的含义是启动模块对应的 key return __webpack_require__(__webpack_require__.s = "./main.js");&#125;)(&#123;// 所有的模块都存放在了一个对象里，根据每个模块在对象的 key 来区分和定位模块"./main.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); var _src_index1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/index1.js"); var _src_index2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/index2.js"); console.log(_src_index1__WEBPACK_IMPORTED_MODULE_0__["default"], _src_index2__WEBPACK_IMPORTED_MODULE_1__["default"]); __webpack_exports__["default"] = ('./main.js'); &#125;),"./src/index1.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); __webpack_exports__["default"] = ('Hello World'); &#125;),"./src/index2.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); __webpack_exports__["default"] = ('World Hello'); &#125;)&#125;); 上面这段 js 就是使用 webpack 编译后的代码，其中就包含了 webpack 的运行时代码，其中就是关于模块的实现。 以上看上去复杂的代码其实是一个立即执行函数，可以简写为如下：123456789101112(function(modules) &#123; // 模拟 require 语句 function __webpack_require__() &#123; &#125; // 执行存放所有模块中 key 值为 ./main.js 的模块 __webpack_require__('./main.js');&#125;)(&#123; "./main.js": fn // 函数&#125;) 自执行函数的入参是个对象，这个对象包含了所有的模块，包裹在函数中。自执行函数体里的逻辑就是处理模块的逻辑。关键在于__webpack_require__函数，这个函数就是require或者是import的替代，我们可以看到在函数体内先定义了这个函数，然后调用了它。这里会传入一个moduleId，这个例子中是./main.js，也就是我们的入口模块main.js的内容。 我们再看__webpack_require__内执行了：12modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);return module.exports； 即从入参的 modules 对象中取第一个函数进行调用，并入参： module module.exports webpack_require 我们再看第一个函数（即入口模块）的逻辑： 12345678(function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); var _src_index1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/index1.js"); var _src_index2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/index2.js"); console.log(_src_index1__WEBPACK_IMPORTED_MODULE_0__["default"], _src_index2__WEBPACK_IMPORTED_MODULE_1__["default"]); __webpack_exports__["default"] = ('./main.js');&#125;) 我们可以看到入口模块又调用了__webpack_require__(&quot;./src/index1.js&quot;)和__webpack_require__(&quot;./src/index2.js&quot;)去引用入参数组里的第2和第3个函数。 然后会将入参的__webpack_exports__对象添加default属性，并赋值。这里的__webpack_exports__就是这个模块的module.exports通过对象的引用传参，间接的给module.exports添加属性，这就是webpack模块化的实现原理。 最后会将module.exports return出来。就完成了__webpack_require__函数的使命。比如在入口模块中又调用了__webpack_require__(&quot;./src/index1.js&quot;)，就会得到这个模块返回的module.exports。 babel 的作用按理说 webpack 的模块化方案已经很好的将 es6 模块化转换成 webpack 的模块化，但是其余的 es6 语法还需要做兼容性处理。babel 专门用于处理 es6 转换 es5。当然这也包括 es6 的模块语法的转换。其实两者的转换思路差不多，区别在于 webpack 的原生转换 可以多做一步静态分析，使用tree-shaking 技术。 babel 能提前将 es6 的 import 等模块关键字转换成 commonjs 的规范。这样 webpack 就无需再做处理，直接使用 webpack 运行时定义的 webpack_require 处理。 导出模块es6 的导出模块写法：1234567export default 123;export const a = 123;const b = 3;const c = 4;export &#123; b, c &#125;; babel 会将这些统统转换成 commonjs 的 exports：12345exports.default = 123;exports.a = 123;exports.b = 3;exports.c = 4;exports.__esModule = true; babel 转换 es6 的模块输出逻辑非常简单，即将所有输出都赋值给 exports，并带上一个标志 __esModule 表明这是个由 es6 转换来的 commonjs 输出。 babel将模块的导出转换为commonjs规范后，也会将引入 import 也转换为 commonjs 规范。即采用 require 去引用模块，再加以一定的处理，符合es6的使用意图。 引入 default1import a from './a.js'; 在es6中 import a from ‘./a.js’ 的本意是想去引入一个 es6 模块中的 default 输出。 通过babel转换后得到var a = require(./a.js)，require得到的对象却是整个对象，肯定不是 es6 语句的本意，所以需要对 a 做些改变。 我们在导出提到，default 输出会赋值给导出对象的default属性。 1exports.default = 123; 所以 babel 加了个help _interopRequireDefault函数：12345678910function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; 'default': obj &#125;;&#125;var _a = require('assert');var _a2 = _interopRequireDefault(_a);var a = _a2['default']; 所以这里最后的 a 变量就是 require 的值的 default 属性。如果原先就是commonjs规范的模块，那么就是那个模块的导出对象。 引入 * 通配符我们使用import * as a from &#39;./a.js&#39;es6语法的本意是想将 es6 模块的所有命名输出以及defalut输出打包成一个对象赋值给a变量。 已知以 commonjs 规范导出：1234exports.default = 123;exports.a = 123;exports.b = 3;exports.__esModule = true; 那么对于 es6 转换来的输出通过 var a = require(‘./a.js’) 导入这个对象就已经符合意图。 所以直接返回这个对象：123if (obj &amp;&amp; obj.__esModule) &#123; return obj;&#125; 如果本来就是 commonjs 规范的模块，导出时没有default属性，需要添加一个default属性，并把整个模块对象再次赋值给default属性：12345678910111213141516function _interopRequireWildcard(obj) &#123; if (obj &amp;&amp; obj.__esModule) &#123; return obj; &#125; else &#123; var newObj = &#123;&#125;; // (A) if (obj != null) &#123; for (var key in obj) &#123; if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; &#125; &#125; newObj.default = obj; return newObj; &#125;&#125; import { a } from ‘./a.js’直接转换成 require(‘./a.js’).a 即可。 小结经过上面的转换分析，我们得知即使我们使用了 es6 的模块系统，如果借助 babel 的转换，es6 的模块系统最终还是会转换成 commonjs 的规范。所以我们如果是使用 babel 转换 es6 模块，混合使用 es6 的模块和 commonjs 的规范是没有问题的，因为最终都会转换成 commonjs。 babel5 &amp; babel6我们在上文 babel 对导出模块的转换提到，es6 的 export default 都会被转换成 exports.default，即使这个模块只有这一个输出。 我们经常会使用 es6 的 export default 来输出模块，而且这个输出是这个模块的唯一输出，我们会误以为这种写法输出的是模块的默认输出。12// a.jsexport default 123; 123// b.js 错误var foo = require('./a.js') 在使用require进行引用时，我们也会误以为引入的是a文件的默认输出。结果这里需要改成var foo = require(&#39;./a.js&#39;).default。 这个场景在写 webpack 代码分割逻辑时经常会遇到。12345require.ensure([], (require) =&gt; &#123; callback(null, [ require('./src/pages/profitList').default, ]);&#125;); 这是 babel6 的变更，在 babel5 的时候可不是这样的。 在 babel5 时代，大部分人在用 require 去引用 es6 输出的 default，只是把 default 输出看作是一个模块的默认输出，所以 babel5 对这个逻辑做了 hack，如果一个 es6 模块只有一个 default 输出，那么在转换成 commonjs 的时候也一起赋值给 module.exports，即整个导出对象被赋值了 default 所对应的值。 这样就不需要加 default，require(‘./a.js’) 的值就是想要的 default值。但这样做是不符合 es6 的定义的，在es6 的定义里，default 只是个名字，没有任何意义。 12export default = 123;export const a = 123; 这两者含义是一样的，分别为输出名为 default 和 a 的变量。 还有一个很重要的问题，一旦 a.js 文件里又添加了一个具名的输出，那么引入方就会出麻烦。 12345678910// a.jsexport default 123;export const a = 123; // 新增// b.js var foo = require('./a.js');// 由之前的 输出 123// 变成 &#123; default: 123, a: 123 &#125; 所以 babel6 去掉了这个hack，这是个正确的决定，升级 babel6 后产生的不兼容问题 可以通过引入babel-plugin-add-module-exports解决。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netlify 入门教程]]></title>
    <url>%2F2018%2F07%2F02%2Fnetlify-tutorial.html</url>
    <content type="text"><![CDATA[官网 快速入门指南部署简单通过持续部署，您可以通过推送到Git或通过webhook来触发构建。 支持HTTPS使用我们真正的一键式SSL设置保护您的网站或应用。Netlify自动与Let’s Encrypt集成，并自动配置，分发和更新您的证书。 支持命令行如果你住在终端，Netlify的命令行工具将是你最好的朋友。您可以直接从终端访问任何Netlify功能。 React 源码 netlify 的配置文件 netlify.toml：123456789[build] base = "" publish = "fixtures/dom/build" command = "yarn build --type=UMD_DEV &amp;&amp; cd fixtures/dom/ &amp;&amp; yarn &amp;&amp; yarn prestart &amp;&amp; yarn build"[[redirects]] from = "/*" to = "/index.html" status = 200]]></content>
      <categories>
        <category>netlify</category>
      </categories>
      <tags>
        <tag>netlify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入探究 setTimeout]]></title>
    <url>%2F2018%2F07%2F01%2Fjavascript-setTimeout.html</url>
    <content type="text"><![CDATA[基本使用1setTimeout(function|string, number); setTimeout 方法接收两个参数，第一个参数为回调函数或字符串，第二个参数为触发时间（单位：毫秒） 123setTimeout( function() &#123; console.log('console after 1 second');&#125;, 1000); 上面这段代码将会在 1 秒后在控制台打印出 console after 1 second 1234setTimeout( 'console.log("console after 2 seconds")', 2000 ); 当第一个参数为字符串，而不是函数时会怎样呢？setTimeout 方法会将这个字符串解析为一段 js 代码，然后在 2 秒后执行这段代码。如果这个字符串无法被解析为 js 代码，将会报错。 接下来我们再看看另外一个例子，这是一位群友的疑惑点： 123456789101112131415161718192021222324252627// 示例一：先输出 setTimeout，然后每 1s 输出一次 setTimeoutfunction show() &#123; console.log('setTimeout'); setTimeout(show, 1000);&#125;show();// 示例二：先输出 setTimeout，然后每 1s 输出一次 setTimeoutfunction show() &#123; console.log('setTimeout'); setTimeout('show()', 1000);&#125;show();// 示例三：无任何输出function show() &#123; console.log('setTimeout'); setTimeout('show', 1000);&#125;show();// 示例四：show会被立刻执行，被延迟执行的是show执行后的返回值。所以show会不断的重复调用直到堆栈爆满，从而引发内存溢出function show() &#123; console.log('setTimeout'); setTimeout(show(), 1000);&#125;show(); 返回值12345678var timeout = setTimeout(function() &#123; console.log('this is a timeout')&#125;, 1000);console.log(timeout, typeof timeout);// 1, "number"// this is a timeout 用变量 timeout 接收 setTimeout() 的返回值，然后将 timeout 打印出来，会发现 timeout 的值是 1，类型是number 为什么 setTimeout() 的返回值会是一个数值类型呢？是不是每一个 setTimeout() 的返回值都会是1？ 12345678910111213141516171819var timeout1 = setTimeout(function() &#123; //&#125;, 1000);var timeout2 = setTimeout(function() &#123; //&#125;, 1000);var timeout3 = setTimeout(function() &#123; //&#125;, 1000);console.log('timeout1---', timeout1);console.log('timeout2---', timeout2);console.log('timeout3---', timeout3);// timeout1--- 1// timeout2--- 2// timeout3--- 3 从上面的代码中能够发现，每一个 setTimeout() 的返回值都不同，返回值并不都是1，而是都对应着唯一的一个值 这个值其实就是对应的 setTimtout() 的 ID，随着当前页面定时器的不断增多，当需要对某一个定时器做操作时，通过 ID 就能够确定到该定时器。 如何结束/阻止一个 setTimeout 的执行实际项目中，添加一个定时器以后，在其回调函数还未执行之前，满足某些条件时可能需要阻止该回调的执行，也就是取消一个定时器，那这时候该怎么做呢？javascript 已经为我们提供了现成的方法： 1clearTimeout( timeout ); 上面这个方法就可以阻止一个定时器的执行，它接收一个参数，这个参数就是需要取消的定时器的 ID，也就是该定时器的返回值 12345var timeout = setTimeout(function() &#123; alert('this is a timeout')&#125;, 1000);clearTimeout( timeout ); 上面代码中的定时器timeout在一秒后并不会执行，因为已经通过clearTimeout( timeout )取消了它的执行 实现异步编程我们使用异步编程很重要的一个目的就是为了不因为耗时任务而阻塞其他 js 代码的执行。我们知道 alert 会阻塞 js 代码的执行，这是因为 js 是单线程的，弹出框出现后如果不对其进行操作就无法执行后面的代码（类似的 confirm 也是） 123alert('this is an alert box');var test = 'this is a text string';console.log(test); 上面的代码在弹出框出现后如果不点击确定，将永远不会执行后面的代码 1234567setTimeout(function() &#123; alert('this is an alert box');&#125;, 1000);var test = 'this is a text string';console.log(test);// this is a text string 上面的代码将 alert 放在了一个延时 1 秒的定时器中，这样就会先打印出 test，过一秒后再显示弹出框。或许你会说，本身 alert 就延时了 1 秒执行，当然不会阻塞其他的代码执行。那么你可以试着将延时1000改为0，这就表示弹出框应该是没有延时立即执行，但是你会发现实际上还是先打印出 test，再执行了 alert。为什么会这样呢？我们下面再说 在实际项目中，我们可以利用 setTimeout 的异步特性，解决一些问题，比如某个对象还未实例化，为了保证该对象在使用到时能够确保已经被实例化，就可以通过 setTimeout 来实现 setTimeout 回调函数的执行时机现在我们来说说为什么延时设为 0 ，回调函数却没有立即执行的问题。我们知道浏览器是基于事件循环的，其中会有多个队列，页面的渲染是一个队列，js 代码的执行也是一个队列。js 代码执行时会创建一系列的任务，而这些任务秉承着先进先出的原则被加入到队列中。但是 setTimeout 是特殊的，当执行到 setTimeout 时，js会将其拿出来放到一个单独的特殊队列中，这个队列中的任务在 js 队列还有未执行完的任务时，永远不会被执行 举个不恰当的栗子，小明想玩游戏，但是作业还没做完，由于小明是单线程的，虽然现在很想玩游戏，但是他还是给自己设定了条件：作业不做完不能玩游戏，一做完立刻玩游戏（延时为0），于是玩游戏这个任务就被小明归置到了一个特殊的任务队列里面，在作业队列任务完成之前不执行特殊队列里面玩游戏的任务，作业完成小明闲下来后立刻开始玩游戏。所以只有浏览器的 js 引擎闲下来以后，才会执行所有 setTimeout，即使延时为 0。 123456var flag = true;setTimeout(function() &#123; flag = false;&#125;, 1000);while(flag) &#123;&#125;alert('this is an alert box'); 问：上面的代码什么时候会显示弹出框？ 答：永远都不会 上面的代码中，while是一个耗时函数，虽然setTimeout只延时了一秒执行，但是由于主队列中的while会永远的执行下去，所以setTimeout所在的队列永远不会被执行，代码会永远阻塞在while循环这边。当然，上面的这种无限循环在项目中不可能出现，而代码执行速度极快，只要不出现十分耗时的代码，定时器几乎还是能够按照我们的意愿在指定时间执行回调函数。 通过 setTimeout 优化用户体验既然setTimeout必须等到主队列中的任务执行完以后才会执行，那我们在碰到一些十分耗时的代码时，是不是可以通过它来放在页面的阻塞呢？当然是可以的，将耗时代码写进setTimeout的回调，时间设置为 0，这样只要 js 引擎空闲下来就回去执行这些耗时代码，就不会阻塞页面给用户造成卡顿的体验，从而提升用户体验。 不易察觉的危险——内存泄漏 什么是内存泄漏？ 一块内存在分配使用完毕以后，既不会被再次使用，又没有被及时回收，直到程序执行完毕都始终占据着这块内存。 setTimeout 什么情况会导致内存泄漏？ setTimeout的第一个参数可以是函数，也可以是字符串。当传入字符串时，就会有内存泄漏产生。先看下面两个例子 123456789setTimeout(function test1() &#123; var a = 1; console.log(a);&#125;, 0)setTimeout((function test2() &#123; var b = 1; console.log(b);&#125;).toString(), 0) 执行代码后，打开控制台，分别输入函数名test1和test2 12345test1// Uncaught ReferenceError: test1 is not definedtest2// ... (打印出 test2 的函数体) 会发现，当第一个参数为函数时，回调函数执行完毕后，test1函数被销毁，其所使用内存也被释放；当第一个参数为字符串时，test2却始终存在，它没有被销毁，始终占据着内存，也就造成了内存泄漏，所以让我们需要使用 setTimeout时，一定要注意，第一个参数必须传入一个函数。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux 源码全方位剖析]]></title>
    <url>%2F2018%2F06%2F29%2Fredux-source-analysis.html</url>
    <content type="text"><![CDATA[版本：v4.0.0 前言受2014年Facebook的Flux架构模式以及函数式编程语言Elm启发，Dan Abramov在2015年创建了 Redux。很快，Redux因其体小精悍（只有2kB）且没有任何依赖短时间内成为最热门的前端架构。 Redux 是可预测的状态管理框架，它很好的解决多交互，多数据源的诉求。Redux 设计之初，作者就严格遵循三个设计理念原则：单一数据源：整个应用的 state 都被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。store 可以看做是数据存储的一个容器，在这个容器里面，只会维护唯一一个 state tree。store 会给定4种基础操作API：dispatch(action)，getState()，replaceReducer(nextReducer)，subscribe(listener)。根据单一数据源原则，所有数据会通过store.getState()方法调用获取。state只读：根据 state 只读原则，数据变更会通过 store，dispatch(action) 方法，Action 可以理解为变更数据的信息载体，type 是变更数据的唯一标志，payload 是用来携带需要变更的数据，格式大致为：const action = { type: &#39;xxx&#39;, payload: &#39;yyy&#39; }；Reducer 是个纯函数，负责根据 action.type 获取需要变更的数据，然后计算 state 数值。格式为：reducer: prevState =&gt; action =&gt; newState。使用纯函数变更state值：Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。 正常的一个同步数据流为：view 层触发 actionCreator，actionCreator 通过 store.dispatch(action) 方法变更 reducer。但是面对多种多样的业务场景，同步数据流方式显然无法满足。对于改变reducer的异步数据操作，就需要用到中间件的概念，如图所示： 源码结构Redux 的源码结构很简单，源码都在 src 目录下，其目录结构如下：12345678src├── utils ---------------------------------------- 工具函数├── applyMiddleware.js --------------------------- 加载 middleware├── bindActionCreators.js ------------------------ 生成将 action creator 包裹在 dispatch 里的函数├── combineReducers.js --------------------------- 合并 reducer 函数├── compose.js ----------------------------------- 组合函数├── createStore.js ------------------------------- 创建一个 Redux store 来储存应用中所有的 state├── index.js ------------------------------------- 入口 js 源码入口index.js 是整个代码的入口，其代码如下：1234567891011121314151617181920212223242526272829303132import createStore from './createStore'import combineReducers from './combineReducers'import bindActionCreators from './bindActionCreators'import applyMiddleware from './applyMiddleware'import compose from './compose'import warning from './utils/warning'import __DO_NOT_USE__ActionTypes from './utils/actionTypes'function isCrushed() &#123;&#125;if ( process.env.NODE_ENV !== 'production' &amp;&amp; typeof isCrushed.name === 'string' &amp;&amp; isCrushed.name !== 'isCrushed') &#123; warning( 'You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.' )&#125;export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose, __DO_NOT_USE__ActionTypes&#125; 入口代码很简单，首先isCrushed函数主要是为了验证在非生产环境下Redux是否被压缩？如果被压缩了，isCrushed.name !== &#39;isCrushed&#39; 就等于 true，这样就会给开发者一个warn提示。最后暴露createStore、combineReducers、bindActionCreators、applyMiddleware、compose 这几个接口给开发者使用，接下来我们逐一解析这几个 API。 createStore.jscreateStore.js 是 Redux 最重要的一个 API ，它负责创建一个 Redux store 来储存应用中所有的 state，整个应用中应有且仅有一个 store。现在我们来看一下 createStore 源代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177import $$observable from 'symbol-observable'// 私有 actionimport ActionTypes from './utils/actionTypes'import isPlainObject from './utils/isPlainObject'export default function createStore(reducer, preloadedState, enhancer) &#123; // 判断接受的参数个数，来指定 reducer、preloadedState 和 enhancer if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; // 如果 enhancer 存在且是个合法的函数，就调用 enhancer，否则抛出错误提示 if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.') &#125; // 储存当前的 reducer let currentReducer = reducer // 储存当前的状态 let currentState = preloadedState // 储存当前的监听函数列表 let currentListeners = [] // 储存下一个监听函数列表 let nextListeners = currentListeners let isDispatching = false // 这个函数可以根据当前监听函数的列表生成新的下一个监听函数列表引用 function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; // 读取由 store 管理的状态树 function getState() &#123; if (isDispatching) &#123; throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) &#125; return currentState &#125; function subscribe(listener) &#123; // 判断传入的参数是否为函数 if (typeof listener !== 'function') &#123; throw new Error('Expected the listener to be a function.') &#125; if (isDispatching) &#123; throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; // 判断 action 是否有 type｛必须｝ 属性 if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?' ) &#125; // 如果正在 dispatch 则抛出错误 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; // 对抛出 error 的兼容，但是无论如何都会继续执行 isDispatching = false 的操作 try &#123; isDispatching = true // 使用 currentReducer 来操作传入 当前状态和 action，放回处理后的状态 currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; // 判断参数是否是函数类型 function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.REPLACE &#125;) &#125; function observable() &#123; const outerSubscribe = subscribe return &#123; subscribe(observer) &#123; if (typeof observer !== 'object' || observer === null) &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125; &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 这里我们首先要讲一下ActionTypes对象，它是 Redux 的私有 action，不允许外界触发，用来初始化 store 的状态树和改变 reducers 后初始化 store 的状态树。接下来我们从不同角度着重来讲一下 createStore 函数： 参数它可以接受三个参数：reducer、preloadedState、enhancer：reducer：函数，返回下一个状态，接受两个参数：当前状态 和 触发的 action；preloadedState：它是 state 的初始值，可以随意指定，比如服务端渲染的初始状态，但是如果使用 combineReducers 来生成 reducer，那必须保持状态对象的 key 和 combineReducers 中的 key 相对应，另外实际上它并不仅仅是扮演着一个 initialState 的角色，如果我们第二个参数是函数类型，createStore 会认为我们忽略了 preloadedState 而传入了一个enhancer；enhancer：可选参数，一个组合 store creator 的高阶函数，可以翻译成 store 的增强器，顾名思义，就是增强 store 的功能。一般指定为第三方的中间件，时间旅行，持久化等等，返回一个新的强化过的 store creator，这个函数通常用 Redux 提供的 applyMiddleware 函数来生成。 根据传入参数的个数和类型，判断 reducer、preloadedState、enhancer。 返回值调用完函数的返回值：dispatch、subscribe、getState、replaceReducer 和 [$$observable]，这就是我们开发中主要使用的几个接口。 enhancer如果enhancer参数存在且是个合法的函数，那么就调用enhancer函数。enhancer实际上是一个高阶函数，它的参数是创建store的函数createStore，返回值是一个可以创建功能更加强大的store的函数(enhanced store creator)，这和 React 中的高阶组件的概念很相似。store enhancer 函数的结构一般如下：123456function enhancerCreator() &#123; return createStore =&gt; (...args) =&gt; &#123; // do something based old store // return a new enhanced store &#125;&#125; 注意，enhancerCreator是用于创建enhancer store的函数，也就是说enhancerCreator的执行结果才是一个enhancer store。...args参数代表创建store所需的参数，也就是createStore接收的参数，实际上就是（reducer, [preloadedState], [enhancer]）。 现在，我们来创建一个enhancer store，用于输出发送的action的信息和state的变化：1234567891011121314// logging.js（store enhancer）export default function logging() &#123; return createStore =&gt; (reducer, initialState, enhancer) =&gt; &#123; const store = createStore(reducer, initialState, enhancer) function dispatch(action) &#123; console.log(`dispatch an action: $&#123;JSON.stringify(action)&#125;`); const res = store.dispatch(action); const newState = store.getState(); console.log(`current state: $&#123;JSON.stringify(newState)&#125;`); return res; &#125; return &#123;...store, dispatch&#125; &#125;&#125; logging()改变了store dispatch的默认行为，在每次发送action前后，都会输出日志信息，然后在创建store上，使用logging()这个store enhancer:12345678910111213// store.jsimport &#123; createStore, combineReducers &#125; from 'redux';import * as reducer from '../reducer';import logging from '../logging';//创建一个 Redux store 来以存放应用中所有的 state，应用中应有且仅有一个 store。var store = createStore( combineReducers(reducer), logging());export default store; getState123456789101112// 读取由 store 管理的状态树function getState() &#123; if (isDispatching) &#123; throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) &#125; return currentState&#125; 这个函数可以获取当前的状态，createStore 中的 currentState 储存当前的状态树，这是一个闭包，这个参数会持久存在，并且所有的操作状态都是改变这个引用，getState 函数返回当前的 currentState。 subscribe123456789101112131415161718192021222324252627282930313233343536373839function subscribe(listener) &#123; // 判断传入的参数是否为函数 if (typeof listener !== 'function') &#123; throw new Error('Expected the listener to be a function.') &#125; if (isDispatching) &#123; throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125;&#125; 这个函数可以给 store 的状态添加订阅监听函数，一旦调用dispatch，所有的监听函数就会执行；nextListeners就是储存当前监听函数的列表，调用subscribe，传入一个函数作为参数，那么就会给nextListeners列表push这个函数；同时调用subscribe函数会返回一个unsubscribe函数，用来解绑当前传入的函数，同时在subscribe函数定义了一个isSubscribed标志变量来判断当前的订阅是否已经被解绑，解绑的操作就是从nextListeners列表中删除当前的监听函数。 dispatch1234567891011121314151617181920212223242526272829303132333435function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; // 判断 action 是否有 type｛必须｝ 属性 if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?' ) &#125; // 如果正在 dispatch 则抛出错误 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; // 对抛出 error 的兼容，但是无论如何都会继续执行 isDispatching = false 的操作 try &#123; isDispatching = true // 使用 currentReducer 来操作传入 当前状态和 action，放回处理后的状态 currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; 这个函数是用来触发状态改变的，它接受一个 action 对象作为参数，然后 reducer 根据 action 的属性以及当前 store 的状态来生成一个新的状态，赋予当前状态，改变 store 的状态；即currentState = currentReducer(currentState, action)；这里的currentReducer是一个函数，它接受两个参数：当前状态 和 action，然后返回计算出来的新的状态；然后遍历nextListeners列表，调用每个监听函数。 replaceReducer123456789// 判断参数是否是函数类型function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.REPLACE &#125;)&#125; 这个函数可以替换 store 当前的 reducer 函数，首先直接用currentReducer = nextReducer替换；然后dispatch({ type: ActionTypes.INIT })，用来初始化替换后 reducer 生成的初始化状态并且赋予 store 的状态。 observable123456789101112131415161718192021222324function observable() &#123; const outerSubscribe = subscribe return &#123; subscribe(observer) &#123; if (typeof observer !== 'object' || observer === null) &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125;&#125; 对于这个函数，是不直接暴露给开发者的，它提供了给其他观察者模式/响应式库的交互操作。 初始化 store 的状态最后执行dispatch({ type: ActionTypes.INIT })，用来根据 reducer 初始化 store 的状态。 compose.jscompose可以接受一组函数参数，然后从右到左来组合多个函数（这是函数式编程中的方法），最后返回一个组合函数。现在我们来看一下 compose 源代码：123456789101112131415/** * For example, compose(f, g, h) is identical to doing * (...args) =&gt; f(g(h(...args))). */export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; compose其作用是把一系列的函数，组装生成一个新的函数，并且从后到前，后面参数的执行结果作为其前一个的参数，当需要把多个 store 增强器 依次执行的时候，需要用到它。 参数(…funcs)：需要合成的多个函数。每个函数都接收一个函数作为参数，然后返回一个函数。 返回值(Function)：从右到左把接收到的函数合成后的最终函数。 applyMiddleware.js It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer. 这是 redux 作者 Dan 对 middleware 的描述，middleware 提供了一个分类处理 action 的机会，在 middleware 中我们可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给我们改变 action 的机会。Redux middleware 的设计十分特殊，是一个层层包裹的匿名函数，实际上这是函数式编程中的柯里化，一种使用匿名单参数函数来实现多参数函数的方法，柯里化的 middleware 结构好处在于：一：易串联，柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，配合组合的方式，很容易形成 pipeline 来处理数据流。二：共享 store，在 applyMiddleware 执行过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middlewares 内部拿到的 store 是最新且相同的。 redux 提供了 applyMiddleware 这个 api 来加载 middleware。现在我们来看一下 applyMiddleware 源代码：123456789101112131415161718192021222324252627import compose from './compose'export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; // 暴漏 getState 和 dispatch 供第三方中间件使用 const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; // middlewareAPI 作为每个 middleware 的参数依次执行一遍，最终返回函数组成的数组 const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 用 compose 组合函数生成新的 dispatch dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 由上我们可以发现 applyMiddleware 的结构也是一个多层柯里化的函数，借助 compose，applyMiddleware 可以用来和其他插件一起加强 createStore 函数。 参数我们在 createStore 小节中其实就用提及过 applyMiddleware：12345678// 如果 enhancer 存在且是个合法的函数，就调用 enhancer，否则抛出错误提示if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState)&#125; 这里 enhancer 其实就等于 applyMiddleware(mid1, mid2, mid3, …)，因此我们创建一个 store 实际上就变成如下方式了：1applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, preloadedState); 由上述代码可知 applyMiddleware 陆续可以接受四个参数：[md1, mid2, mid3, …]： middlewares 数组；createStore：Redux 原生的 createStore；reducer：函数，返回下一个状态；preloadedState：state 的初始值。接下来，我们看一下 applyMiddleware 用这些参数都做了什么？12345678const store = createStore(...args)const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args)&#125;const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))dispatch = compose(...chain)(store.dispatch) applyMiddleware 利用 createStore 和 (reducer, preloadedState) 创建了一个 store，然后 store 的 getState 方法和 dispatch 方法又分别赋值给 middlewareAPI 变量，紧接着用 middlewareAPI 作为每个 middleware 的参数依次执行一遍，执行完后，最终获得数组 chain：[f1, f2, …, fn] 交给组合函数 compose 处理。compose 可以接受一组函数参数，然后从右到左来组合多个函数（这是函数式编程中的方法），最后返回一个组合函数，例如：1234// 调用dispatch = compose(f, g, h)(store.dispatch)// 返回dispatch = f(g(h(store.dispatch))) 这样通过调用新的 dispatch，每个 middleware 的代码就可以依次执行了。 返回值store：原来的store；dispatch：改变后的dispatch。 combineReducers.jsReducer 是管理 state 的一个模块，它主要做的事情就是当项目初始化时，返回 initalState，当用户用操作时，它会根据 action 进行相应地更新。需要注意的是它是一个纯函数，换言之，它不会改变传入的 state。现在我们来看一下 combineReducers 源码（源码有删减，删除了一些验证代码）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import ActionTypes from './utils/actionTypes'import warning from './utils/warning'import isPlainObject from './utils/isPlainObject'export default function combineReducers(reducers) &#123; // 根据 reducers 生成最终合法的 finalReducers：value 为 函数 const reducerKeys = Object.keys(reducers) const finalReducers = &#123;&#125; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key "$&#123;key&#125;"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers) let unexpectedKeyCache if (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125; &#125; let shapeAssertionError try &#123; assertReducerShape(finalReducers) &#125; catch (e) &#123; shapeAssertionError = e &#125; // 返回最终生成的 reducer return function combination(state = &#123;&#125;, action) &#123; if (shapeAssertionError) &#123; throw shapeAssertionError &#125; if (process.env.NODE_ENV !== 'production') &#123; const warningMessage = getUnexpectedStateShapeWarningMessage( state, finalReducers, action, unexpectedKeyCache ) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; // 遍历一遍验证下是否改变，然后返回原有状态值或者新的状态值 return hasChanged ? nextState : state &#125;&#125; 该函数最终返回 combination 函数，它就是真正 createStore 函数的 reducer，接受一个初始化状态和一个 action 参数；该函数每次调用大致执行以下几个操作：1、for (let i = 0; i &lt; finalReducerKeys.length; i++) { ... }：遍历 finalReducer（有效的 reducer 列表）；2、var previousStateForKey = state[key]：当前遍历项的之前状态，看到这里就应该明白传入的 reducers 组合为什么 key 要和 store 里面的 state 的 key 相对应了；3、var nextStateForKey = reducer(previousStateForKey, action)：当前遍历项的下一个状态；4、nextState[key] = nextStateForKey：将 当前遍历项的下一个状态添加到 nextState；5、hasChanged = hasChanged || nextStateForKey !== previousStateForKey：判断状态是否改变；6、return hasChanged ? nextState : state：如果没有改变就返回原有状态，如果改变了就返回新生成的状态对象。 参数reducers (Object): 一个对象，它的值（value）对应不同的 reducer 函数，这些 reducer 函数后面会被合并成一个。 返回值(Function)：它是真正 createStore 函数的 reducer，接受一个初始化状态和一个 action 参数；每次调用的时候会去遍历 finalReducer（有效的 reducer 列表），然后调用列表中每个 reducer，最终构造一个与 reducers 对象结构相同的 state 对象。 bindActionCreators.jsRedux 中的 bindActionCreators 是通过 dispatch 将 action 包裹起来，这样就可以通过 bindActionCreators 创建方法调用 dispatch(action)。现在我们来看一下 bindActionCreators 源代码：1234567891011121314151617181920212223242526272829303132function bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125;export default function bindActionCreators(actionCreators, dispatch) &#123; // 如果是一个函数，直接返回一个 bindActionCreator 函数，即调用 dispatch 触发 action if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; if (typeof actionCreators !== 'object' || actionCreators === null) &#123; throw new Error( `bindActionCreators expected an object or a function, instead received $&#123; actionCreators === null ? 'null' : typeof actionCreators &#125;. ` + `Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?` ) &#125; // 遍历对象，然后设置每个遍历项的 actionCreator 生成函数，最后返回这个对象 const keys = Object.keys(actionCreators) const boundActionCreators = &#123;&#125; for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const actionCreator = actionCreators[key] if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125; 由此可以看出 bindActionCreators 的实现逻辑比较简单：一、判断传入的参数是否是 object，如果是函数，就直接返回一个将 action creator 包裹在 dispatch 里的函数。二、如果是object，就根据相应的key，生成相应的将 action creator 包裹在 dispatch 里的函数。 为了方便理解，我们用一个 TODO 例子说明下：1234567891011121314// actions/todo.jsexport function addTodo(text) &#123; return &#123; type: 'ADD_TODO', text &#125;&#125;export function removeTodo(id) &#123; return &#123; type: 'REMOVE_TODO', id &#125;&#125; 我们 import 后会得到如下对象：1234567891011&#123; addTodo : text =&gt; &#123; type: 'ADD_TODO', text &#125;, removeTodo : id =&gt; &#123; type: 'REMOVE_TODO', id &#125;&#125; 经过 bindActionCreator 就会变成 key 相同，值为用 dispatch 将 action creator 包裹起来的函数的对象：1234&#123; addTodo : text =&gt; dispatch(addTodo('text')); removeTodo : id =&gt; dispatch(removeTodo('id'));&#125; 由此我们发现可以通过 bindActionCreators 创建方法直接调用 dispatch(action)。 参数它可以接收两个参数：actionCreators、dispatchactionCretors：可以是一个对象，也可以是一个单个函数dispatch：dispatch 函数，从 store 实例中获取，用于包裹 action creator 如果只是传入一个 function，返回的也是一个 function，例如：1234567// actions/todo.jsexport const toggleTodo = (id) =&gt; &#123; return &#123; type: 'TOGGLE_TODO', id &#125;;&#125;; 经过 bindActionCreator：1const boundActionCreators = bindActionCreators(toggleTodo, dispatch); 由于 bindActionCreators 第一个参数是一个函数，结果就会变为：1const boundActionCreators = (id) =&gt; dispatch(toggleTodo(id)); 返回值单个函数，或者是一个对象。 总结通过阅读 Redux 的源码，我们发现 Redux 设计的实在是太精妙了，完全函数式编程，依赖少，耦合低。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex 源码全方位剖析]]></title>
    <url>%2F2018%2F06%2F29%2Fvuex-source-analysis.html</url>
    <content type="text"><![CDATA[背景Vue 火不火？我们看 github stars 就知道，现在已超越 React 了，国民的力量还是很强大的。我们在使用 Vue.js 开发应用时，经常会遇到多个组件共享同一个状态，也或者多个组件去更新同一个状态。对于简单的应用，我们可以]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux 源码全方位剖析]]></title>
    <url>%2F2018%2F06%2F27%2Freact-redux-source-analysis.html</url>
    <content type="text"><![CDATA[前言作为前端攻城狮，我们大多都有使用过 Redux，即便没有使用，我相信听肯定听说过。Redux 是一款可预测的状态管理框架，主要提供一个数据存储中心，供外部访问、修改等，因此 Redux 本身和 React 没有什么本质关系。那么我们如何比较优雅的在 React 使用 Redux？传统方法我们可以在应用初始化时，将 store 挂载在 window 上：window.store = createStore(reducer)，然后在需要的地方使用 Redux API：store.getState()、store.dispatch、store.subscribe。。。现在虽然各个子组件都能够访问 store 了，但这里 store 就变成了全局变量。由于全局变量有诸多的缺点，我们不妨换个思路，把 store 直接集成到 React 应用的顶层 props 里面，然后通过 React 钩子 Context，各个子组件就能访问到顶层 props，例如：1234567// 入口文件 index.jsReactDOM.render( &lt;WrapComponent store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/WrapComponent&gt;, document.getElementById('root'))); 现在各个子组件就能够访问到 store 了，这就是我们 react-redux 的设计思路。react-redux 库提供了顶层组件：Provider，然后通过 React 钩子 Context 向应用注入 store，同时它还利用 connect 高阶方法把 Redux API：store.getState()、store.dispatch、store.subscribe等封装起来，使子组件对 store 毫无感知，就好像没有 store 存在一样，然后根据 store state 和组件自身 props 计算得到新props。我们稍后会详细分析 react-redux 的具体实现，在分析源码之前，我们先看一下 react-redux 的源码结构。 源码结构react-redux 的源码结构很简单，源码都在 src 目录下，其目录结构如下：123456789101112131415161718192021src├── components ----------------------------------- 工具函数│ ├── connectAdvanced.js ----------------------- git钩子的目录│ ├── Provider.js ------------------------------ 别名配置文件├── connect -------------------------------------- 加载 middleware│ ├── connect.js ------------------------------- git钩子的目录│ ├── mapDispatchToProps.js -------------------- 别名配置文件│ ├── mapStateToProps.js ----------------------- Rollup 构建文件│ ├── mergeProps.js ---------------------------- Rollup 构建配置的文件│ ├── selectorFactory.js ----------------------- 生成发布通知│ ├── verifySubselectors.js -------------------- 获取 weex 版本│ ├── wrapMapToProps.js ------------------------ 自动发布新版本weex脚本├── utils ---------------------------------------- 生成将 action creator 包裹在 dispatch 里的函数│ ├── isPlainObject.js ------------------------- git钩子的目录│ ├── PropTypes.js ----------------------------- 别名配置文件│ ├── shallowEqual.js -------------------------- Rollup 构建文件│ ├── Subscription.js -------------------------- Rollup 构建配置的文件│ ├── verifyPlainObject.js --------------------- 生成发布通知│ ├── warning.js ------------------------------- 获取 weex 版本│ ├── wrapActionCreators.js -------------------- 自动发布新版本weex脚本├── index.js ------------------------------------- 入口 js 源码入口index.js 是整个代码的入口，其代码如下：12345import Provider, &#123; createProvider &#125; from './components/Provider'import connectAdvanced from './components/connectAdvanced'import connect from './connect/connect'export &#123; Provider, createProvider, connectAdvanced, connect &#125; 入口代码很简单，暴露 Provider，createProvider，connectAdvanced，connect 这几个接口给开发者使用，接下来我们逐一解析这几个 API。 Provider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; Component, Children &#125; from 'react'import PropTypes from 'prop-types'import &#123; storeShape, subscriptionShape &#125; from '../utils/PropTypes'import warning from '../utils/warning'let didWarnAboutReceivingStore = falsefunction warnAboutReceivingStore() &#123; if (didWarnAboutReceivingStore) &#123; return &#125; didWarnAboutReceivingStore = true warning( '&lt;Provider&gt; does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reduxjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.' )&#125;export function createProvider(storeKey = 'store') &#123; const subscriptionKey = `$&#123;storeKey&#125;Subscription` class Provider extends Component &#123; getChildContext() &#123; return &#123; [storeKey]: this[storeKey], [subscriptionKey]: null &#125; &#125; constructor(props, context) &#123; super(props, context) this[storeKey] = props.store; &#125; render() &#123; return Children.only(this.props.children) &#125; &#125; if (process.env.NODE_ENV !== 'production') &#123; Provider.prototype.componentWillReceiveProps = function (nextProps) &#123; if (this[storeKey] !== nextProps.store) &#123; warnAboutReceivingStore() &#125; &#125; &#125; Provider.propTypes = &#123; store: storeShape.isRequired, children: PropTypes.element.isRequired, &#125; Provider.childContextTypes = &#123; [storeKey]: storeShape.isRequired, [subscriptionKey]: subscriptionShape, &#125; return Provider&#125;export default createProvider()]]></content>
      <categories>
        <category>react-redux</category>
      </categories>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天两分钟，了解一个流行 NPM 库]]></title>
    <url>%2F2018%2F06%2F01%2Fawesome-software-development-resources.html</url>
    <content type="text"><![CDATA[每天两分钟，了解一个流行NPM库，废话少说，直接上npm库。 chokidar像 webpack/grunt/gulp 等工具都提供watch模式，当磁盘文件变化后自动重新运行打包。今天我们要学习的chokidar就是一款专门用于文件监控的库。 serialize-javascript将JavaScript序列化为JSON的超集，其中包括正则表达式，日期和函数。 memory-fs一个简单的内存文件系统。在javascript对象中保存数据。 webpack-dev-middleware它就是一个用来组织包装 webpack 使其可以中介软体或称中间件的容器。回想一下 express 我们大概可以明白关于 middleware 的用途，就是在输入到输出的过程中加工的一种手段。单纯说 middleware 的话，我们可以想成一系列任务。 webpack-hot-middlewarewebpack-hot-middleware 是用来进行页面的热重载的,刷新浏览器 一般和 webpack-dev-middleware 配合使用，实现热加载功能。 globglob模式是指 shell 所使用的简化了的正则表达式。 upathpath的代理，将\替换为/，用于添加，更改，默认，修剪文件扩展名的所有结果和方法。 minimist 轻量级的命令行参数解析引擎chalk 命令行彩色输出esm 零依赖ES模块加载器pify 一个专门用来将callback样式的库转化为Promise风格接口的库，除此之外别无任何其他功能hash-sum 快速唯一 hash 生成器netlify 静态网站托管服务平台]]></content>
      <categories>
        <category>programm</category>
      </categories>
      <tags>
        <tag>resources</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise]]></title>
    <url>%2F2018%2F05%2F25%2Fpromise.html</url>
    <content type="text"><![CDATA[Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 组件注册时什么情况在require后面加上default]]></title>
    <url>%2F2018%2F05%2F20%2Fvue-require-component-way.html</url>
    <content type="text"><![CDATA[今天团队内部一起回顾之前项目时，发现两个记忆中相同配置的项目，但其中一个项目可以直接用这样的代码注册组件：1Vue.component('Menu', require("./components/common/Menu.vue")); 然而另外一个项目却需要这样注册组件：1Vue.component('Menu', require("./components/common/Menu.vue").default); 否则的话就会报错:1Failed to mount component: template or render function not defined 这到底是怎么回事？ 首先 webpack 支持 CommonJS、AMD 和 ES6模块打包。当我们用 .vue 单文件写组件时，在 script 标签内使用的是 ES6 的语法且使用 export default 进行默认导出。然而，require 是 CommonJS 的模块导入方式，不支持模块的默认导出，因此导入的结果其实是一个含 default 属性的对象，因此需要使用 .default 来获取实际的组件，当然我们也可以使用 ES6 的 import 语句，如果使用 import，需要给定一个变量名，所有 import 语句必须统一放在模块的开头。相反，如果 .vue 文件中使用 CommonJS 或 AMD 模块化语法，使用 module.exports 对象进行导出，那么使用 require 导入时就不需要使用 .default 来获取。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESlint 全面解读]]></title>
    <url>%2F2018%2F05%2F12%2Feslint-tutorial.html</url>
    <content type="text"><![CDATA[前言ESLint 最初是由 Nicholas C. Zakas 于2013年6月创建的开源项目。它是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，目标是保证代码的一致性和避免错误。在许多方面，它和 JSLint、JSHint 相似，除了少数的例外：一：ESLint 使用Espree解析 JavaScript。二：ESLint 使用 AST 去分析代码中的模式。三：ESLint 是完全插件化的。每一个规则都是一个插件并且我们可以在运行时添加更多的规则。 安装在安装 ESLint 之前请确保满足以下几个条件：Node.js（&gt; = 4.x），npm version 2+。有两种方式安装 ESLint： 全局安装和本地安装。我们建议全局安装 ESLint：1$ npm install -g eslint 接下来设置一个 eslint 配置文件：1$ eslint --init 配置规则root默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果我们想要所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在我们项目根目录下的package.json文件或者.eslintrc.*文件里的eslintConfig字段下设置&quot;root&quot;: true。ESLint 一旦发现配置文件中有&quot;root&quot;: true，它就会停止在父级目录中寻找。 parserOptions解析器选项可以在.eslintrc.*文件使用parserOptions属性设置。可用的选项有：sourceType - 设置为&quot;script&quot;（默认）或&quot;module&quot;（如果我们的代码是 ECMAScript 模块)。 parser指定一个不同的解析器，以下解析器与 ESLint 兼容：1、Esprima2、Babel-ESLint一个对Babel解析器的包装，使其能够与 ESLint 兼容。3、typescript-eslint-parser一个把 TypeScript 转换为 ESTree 兼容格式的解析器 注意，在使用自定义解析器时，为了让 ESLint 在处理非 ECMAScript 5 特性时正常工作，配置属性 parserOptions 仍然是必须的。解析器会被传入 parserOptions，但是不一定会使用它们来决定功能特性的开关。 env环境变量，可用的环境包括：browser：浏览器环境中的全局变量。node：Node.js 全局变量和 Node.js 作用域。jest：Jest 全局变量。 extends继承一些标准库 常见问题eslint 支持async、await1$ npm install babel-eslint --save-dev 在eslint的配置文件中增加&quot;parser&quot;: &quot;babel-eslint&quot;。]]></content>
      <categories>
        <category>eslint</category>
      </categories>
      <tags>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa 源码全方位剖析]]></title>
    <url>%2F2018%2F05%2F10%2Fkoa-source-analysis.html</url>
    <content type="text"><![CDATA[前言Koa 基于 Node.js 平台的下一代 web 开发框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。使用 Koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 源码结构Koa 的源码结构很简单，源码都在 lib 目录下，其目录结构如下：12345lib├── application.js ------------------------------- 入口文件，也是骨架文件，创建一个服务├── context.js ----------------------------------- app 的 context 对象，传入中间件的上下文对象├── request.js ----------------------------------- app 的请求对象，包含请求相关的一些属性├── response.js ---------------------------------- app 的响应对象，包含响应相关的一些属性]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM依赖包版本号~和^的区别及最佳实践]]></title>
    <url>%2F2018%2F05%2F01%2Fnpm-package-version.html</url>
    <content type="text"><![CDATA[我们经常发现项目的依赖包版本号前面有的是 ~，有的是 ^，我们以 angular 为例： 那么 ~ 和 ^ 有什么作用和区别？ ~：匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0。 ^：匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0。 实际项目中我们该如何选择呢？ 固定版本：首先我们可以指定特定的版本号，直接写1.2.3，前面什么前缀都没有，这样固然没问题，但是如果依赖包发布新版本修复了一些小bug，那么需要手动修改package.json文件。^版本：^版本虽然不需要手动修改package.json文件就可享用修复后的依赖包，但^版本之间跨越比较大，更甚至有些高版本于低版本不兼容。~版本：^版本不仅不需要手动修改package.json文件，也不像^版本之间跨越比较大，这样可以保证项目不会出现大的问题，也能保证包中的小bug可以得到修复。*版本：*版本意味着时刻安装最新版本的依赖包，缺点同^版本，可能会造成版本不兼容。 综上所述，实际项目中我们推荐用 ~ 版本。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 组件间通信方式]]></title>
    <url>%2F2018%2F04%2F25%2Fvue-component-communication.html</url>
    <content type="text"><![CDATA[Vue 组件通信包括：父子组件和兄弟组件间的通信。在组件化系统构建中，组件间通信必不可少的。 父组件向子组件通信props父组件核心传递数据代码如下：123456789101112131415161718&lt;template&gt; &lt;child :msg="message"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from './child.vue';export default &#123; components: &#123; child &#125;, data () &#123; return &#123; message: 'I am Father！' &#125; &#125;&#125;&lt;/script&gt; 子组件核心接收数据代码如下：1234567891011121314&lt;template&gt; &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; msg: &#123; type: String, required: true &#125; &#125;&#125;&lt;/script&gt; msg 为父组件给子组件设置的额外属性值，属性值需在子组件中设置 props，子组件中可直接使用 msg 变量。 实例方法父组件通过 $children 可以访问所有直接子组件（父组件的子组件的子组件不是直接子组件）。注意 $children 并不保证顺序，也不是响应式的。 子组件向父组件通信事件子组件核心传递数据代码如下：12345678910111213141516171819&lt;template&gt; &lt;button @click="handleClick"&gt;传递数据&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; msg: &#123; type: String, required: true &#125; &#125;, methods () &#123; handleClick () &#123; this.$emit("sonMsg", "I am Son！"); &#125; &#125;&#125;&lt;/script&gt; 父组件核心接收数据代码如下：123456789101112131415161718&lt;template&gt; &lt;child @sonMsg="getSonMsg"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from './child.vue';export default &#123; components: &#123; child &#125;, methods: &#123; getSonMsg (msg) &#123; console.log(msg); // I am Son！ &#125; &#125;&#125;&lt;/script&gt; 父组件向子组件传递事件方法，子组件通过 $emit 触发事件，回调给父组件。sonMsg 为子组件触发的事件名称，父组件中 @sonMsg 为向子组件传递的事件名称，getSonMsg 为父组件事件回调方法。 ref设置子组件 ref 属性的值，比如：12&lt;!-- 子组件。 ref的值是组件引用的名称 --&gt;&lt;child-component ref="aName"&gt;&lt;/child-component&gt; 父组件中通过$refs.组件名来获得子组件，也就可以调用子组件的属性和方法了。123const child = this.$refs.aNamechild.属性child.方法() 实例方法子组件通过 $parent 访问父组件。 Bus中央通信目前中央通信是解决兄弟间通信，祖父祖孙间通信的最佳方法，不仅限于此，也可以解决父组件子组件间的相互通信。如下图（盗图）： 各组件可自己定义好组件内接收外部组件的消息事件即可，不用理会是哪个组件发过来；而对于发送事件的组件，亦不用理会这个事件到底怎么发送给我需要发送的组件。 先设置Bus：123// bus.js import Vue from 'vue'export default new Vue(); 发送事件的组件：123import bus from '@/bus';// 方法内执行下面动作bus.$emit('child-message', this.data); 组件内监听事件：123456789101112import bus from '@/bus';export default &#123; name: 'child', methods: &#123; &#125;, created() &#123; bus.$on('child-message', function(data) &#123; console.log('I get it'); &#125;); &#125;&#125;; Bus中央通信的方案各种情况下都可用，比较方便。 复杂的单页应用数据管理当应用足够复杂情况下，我们要使用vuex进行数据管理。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨页面通信的几种方法]]></title>
    <url>%2F2018%2F04%2F20%2Fwindows-communication.html</url>
    <content type="text"><![CDATA[localStorage通过监听window对象的“onstorage”事件，其他窗口获取到本窗口发送的消息，注意，必须是同一款浏览器，并且在同一个域名下。 发送消息页面：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Page A&lt;/title&gt; &lt;script&gt; function setTime() &#123; localStorage.setItem('currentTime', (new Date()).getTime()); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button onClick="setTime()"&gt;设置时间&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 接收消息页面：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Page B&lt;/title&gt;&lt;/head&gt;&lt;script&gt; document.addEventListener('DOMContentLoaded', function() &#123; document.getElementById('message').innerText = localStorage.getItem('currentTime') || '暂无数据'; /*当存储空间中数据发生变化的时候*/ window.onstorage = function(ev) &#123; /*获取正在变化的数据*/ document.getElementById('message').innerText = localStorage.getItem(ev.key) || '暂无数据'; &#125;; &#125;, false);&lt;/script&gt; &lt;body&gt; &lt;div id="message"&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 注意：onload：当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。DOMContentLoaded：当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。开发中我们经常需要给一些元素的事件绑定处理函数，将绑定的函数放在这两个事件的回调中，保证能在页面的某些元素加载完毕之后再绑定事件的函数。相比之下 DOMContentLoaded 机制更加合理，因为我们可以容忍图片，flash延迟加载，却不可以容忍看见内容后页面不可交互。 Window.postMessage()定义window.postMessage 是 HTML5 引入的API，postMessage() 方法允许来自不同源的脚本采用异步方式进行有效的通信，可以实现跨文本文档，多窗口，跨域消息传递。多用于窗口间数据通信，这也使它成为跨域通信的一种有效的解决方案。 postMessage发送消息在需要发送消息的源窗口调用 postMessage 方法即可发送消息。 源窗口源窗口可以是全局的window对象，也可以是以下类型的窗口:文档窗口中的iframe：12var iframe = document.getElementById('my-iframe');var win = iframe.documentWindow; JavaScript打开的弹窗：1var win = window.open(); 当前文档窗口的父窗口：1var win = window.parent; 打开当前文档的窗口：1var win = window.opener(); 找到源window对象后，即可调用postMessage API向目标窗口发送消息：1win.postMessage('Hello', 'ttp://jhssdemo.duapp.com/'); postMessage函数接收两个参数：第一个为将要发送的消息，第二个为源窗口的源。 注：只有当目标窗口的源与postMessage函数中传入的源参数值匹配时，才能接收到消息。 接收postMessage消息要想接收到之前源窗口通过postMessage发出的消息，只需要在目标窗口注册message事件并绑定事件监听函数，就可以在函数参数中获取消息。123456789101112131415161718window.onload = function() &#123; var text = document.getElementById('txt'); function receiveMsg(e) &#123; console.log("Got a message!"); console.log("nMessage: " + e.data); console.log("nOrigin: " + e.origin); // console.log("Source: " + e.source); text.innerHTML = "Got a message!&lt;br&gt;" + "Message: " + e.data + "&lt;br&gt;Origin: " + e.origin; &#125; if (window.addEventListener) &#123; //为窗口注册message事件，并绑定监听函数 window.addEventListener('message', receiveMsg, false); &#125;else &#123; window.attachEvent('message', receiveMsg); &#125;&#125;; message事件监听函数接收一个参数，Event对象实例，该对象有三个属性：data；发送的具体消息。origin：发送消息源。source：发送消息窗口的window对象引用。 说明1、可以将postMessage函数第二个参数设为*，在发送跨域消息时会跳过对发送消息的源的检查。2、postMessage只能发送字符串信息。 实例源窗口：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Html5 postMessage&lt;/title&gt; &lt;style&gt; #otherWin &#123; width: 600px; height: 400px; background-color: #cccccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="btn"&gt;open&lt;/button&gt; &lt;button id="send"&gt;send&lt;/button&gt; &lt;!-- 通过 iframe 嵌入子页面(接收消息目标窗口) --&gt; &lt;iframe id="otherWin" src="http://localhost:8080/b.html"&gt;&lt;/iframe&gt; &lt;br/&gt; &lt;br/&gt; &lt;input type="text" id="message" /&gt; &lt;input type="button" value="Send to child.com" id="sendMessage" /&gt; &lt;script&gt; window.onload = function() &#123; var btn = document.getElementById('btn'); var btn_send = document.getElementById('send'); var sendBtn = document.getElementById('sendMessage'); var win; btn.onclick = function() &#123; //通过window.open打开接收消息目标窗口 win = window.open('http://localhost:8080/b.html', 'popUp'); &#125; btn_send.onclick = function() &#123; // 通过 postMessage 向子窗口发送数据 win.postMessage('Hello', 'http://localhost:8080/'); &#125; function sendIt(e)&#123; // 通过 postMessage 向子窗口发送数据 document.getElementById("otherWin").contentWindow .postMessage( document.getElementById("message").value, "http://localhost:8080/"); &#125; sendBtn.onclick = function(e) &#123; sendIt(e); &#125;; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 目标窗口：1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Html5 postMessage&lt;/title&gt; &lt;style&gt; #txt &#123; width: 500px; height: 300px; background-color: #cccccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;The New Window&lt;/h1&gt; &lt;div id="txt"&gt;&lt;/div&gt; &lt;script&gt; window.onload = function() &#123; var text = document.getElementById('txt'); //监听函数，接收一个参数--Event事件对象 function receiveMsg(e) &#123; console.log("Got a message!"); console.log("nMessage: " + e.data); console.log("nOrigin: " + e.origin); text.innerHTML = "Got a message!&lt;br&gt;" + "Message: " + e.data + "&lt;br&gt;Origin: " + e.origin; &#125; if (window.addEventListener) &#123; //为window注册message事件并绑定监听函数 window.addEventListener('message', receiveMsg, false); &#125;else &#123; window.attachEvent('message', receiveMsg); &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; WebSocket所有的WebSocket都监听同一个服务器地址，利用send发送消息，利用onmessage获取消息的变化，不仅能窗口，还能跨浏览器，兼容性最佳，只是需要消耗点服务器资源。123456789var ws = new WebSocket("ws://www.example.com/socketserver");ws.onopen = function (event) &#123; // 或者把此方法注册到其他事件中，即可与其他服务器通信 ws.send(&#123;username : 'yiifaa', now : Date.now()&#125;); // 通过服务器中转消息&#125;;ws.onmessage = function (event) &#123; // 消费消息 console.log(event.data);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F04%2F19%2Fdesign-pattern-tutorial.html</url>
    <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 策略模式定义定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 优点1、策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句。2、策略模式提供了开放-封闭原则，使代码更容易理解和扩展。3、策略模式中的代码可以复用。 示例：使用策略模式计算奖金比如公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍；现在我们使用一般的编码方式会如下这样编写代码： 一般方式1234567891011121314var calculateBouns = function(salary,level) &#123; if(level === 'A') &#123; return salary * 4; &#125; if(level === 'B') &#123; return salary * 3; &#125; if(level === 'C') &#123; return salary * 2; &#125;&#125;;// 调用如下：console.log(calculateBouns(4000,'A')); // 16000console.log(calculateBouns(2500,'B')); // 7500 第一个参数为薪资，第二个参数为等级；代码缺点如下：1、calculateBouns 函数包含了很多if-else语句。2、calculateBouns 函数缺乏弹性，假如还有D等级的话，那么我们需要在calculateBouns 函数内添加判断等级D的if语句；3、算法复用性差，如果在其他的地方也有类似这样的算法的话，但是规则不一样，我们这些代码不能通用。 组合函数组合函数是把各种算法封装到一个个的小函数里面，比如等级A的话，封装一个小函数，等级为B的话，也封装一个小函数，以此类推；如下代码：1234567891011121314151617181920212223var performanceA = function(salary) &#123; return salary * 4;&#125;;var performanceB = function(salary) &#123; return salary * 3;&#125;; var performanceC = function(salary) &#123; return salary * 2;&#125;;var calculateBouns = function(level,salary) &#123; if(level === 'A') &#123; return performanceA(salary); &#125; if(level === 'B') &#123; return performanceB(salary); &#125; if(level === 'C') &#123; return performanceC(salary); &#125;&#125;;// 调用如下console.log(calculateBouns('A',4500)); // 18000 代码看起来有点改善，但是还是有如下缺点：calculateBouns 函数有可能会越来越大，比如增加D等级的时候，而且缺乏弹性。 策略模式传统面向对象策略模式指的是 定义一系列的算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，实际就是将算法的使用和实现分离出来；算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数，而算法的实现是根据绩效对应不同的绩效规则；一个基于策略模式的程序至少由2部分组成，第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，该Context接收客户端的请求，随后把请求委托给某一个策略类。我们先使用传统面向对象来实现；如下代码：12345678910111213141516171819202122232425262728293031323334353637var performanceA = function()&#123;&#125;;performanceA.prototype.calculate = function(salary) &#123; return salary * 4;&#125;; var performanceB = function()&#123;&#125;;performanceB.prototype.calculate = function(salary) &#123; return salary * 3;&#125;;var performanceC = function()&#123;&#125;;performanceC.prototype.calculate = function(salary) &#123; return salary * 2;&#125;;// 奖金类var Bouns = function()&#123; this.salary = null; // 原始工资 this.levelObj = null; // 绩效等级对应的策略对象&#125;;Bouns.prototype.setSalary = function(salary) &#123; this.salary = salary; // 保存员工的原始工资&#125;;Bouns.prototype.setlevelObj = function(levelObj)&#123; this.levelObj = levelObj; // 设置员工绩效等级对应的策略对象&#125;;// 取得奖金数Bouns.prototype.getBouns = function()&#123; // 把计算奖金的操作委托给对应的策略对象 return this.levelObj.calculate(this.salary);&#125;;var bouns = new Bouns();bouns.setSalary(10000);bouns.setlevelObj(new performanceA()); // 设置策略对象console.log(bouns.getBouns()); // 40000 bouns.setlevelObj(new performanceB()); // 设置策略对象console.log(bouns.getBouns()); // 30000 如上代码使用策略模式重构代码，可以看到代码职责更新分明，代码变得更加清晰。 Javascript代码如下：123456789101112131415var obj = &#123; "A": function(salary) &#123; return salary * 4; &#125;, "B": function(salary) &#123; return salary * 3; &#125;, "C": function(salary) &#123; return salary * 2; &#125; &#125;;var calculateBouns =function(level,salary) &#123; return obj[level](salary);&#125;;console.log(calculateBouns('A',10000)); // 40000 可以看到代码更加简单明了；策略模式指的是定义一系列的算法，并且把它们封装起来，但是策略模式不仅仅只封装算法，我们还可以对用来封装一系列的业务规则，只要这些业务规则目标一致，我们就可以使用策略模式来封装它们； 示例：使用策略模式进行表单校验我们经常来进行表单验证，比如注册登录对话框，我们登录之前要进行验证操作：1、用户名不能为空。2、密码长度不能小于6位。3、手机号码必须符合格式。。。。 比如HTML代码如下：1234567891011121314&lt;form action = "http://www.baidu.com" id="registerForm" method = "post"&gt; &lt;p&gt; &lt;label&gt;请输入用户名：&lt;/label&gt; &lt;input type="text" name="userName"/&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;请输入密码：&lt;/label&gt; &lt;input type="text" name="password"/&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;请输入手机号码：&lt;/label&gt; &lt;input type="text" name="phoneNumber"/&gt; &lt;/p&gt;&lt;/form&gt; 一般方式我们正常的编写表单验证代码如下：123456789101112131415var registerForm = document.getElementById("registerForm");registerForm.onsubmit = function()&#123; if(registerForm.userName.value === '') &#123; alert('用户名不能为空'); return; &#125; if(registerForm.password.value.length &lt; 6) &#123; alert("密码的长度不能小于6位"); return; &#125; if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123; alert("手机号码格式不正确"); return; &#125;&#125; 但是这样编写代码有如下缺点：1、registerForm.onsubmit 函数比较大，代码中包含了很多if语句；2、registerForm.onsubmit 函数缺乏弹性，如果增加了一种新的效验规则，或者想把密码的长度效验从6改成8，我们必须改registerForm.onsubmit 函数内部的代码。违反了开放-封闭原则。3、算法的复用性差，如果在程序中增加了另外一个表单，这个表单也需要进行一些类似的效验，那么我们可能又需要复制代码了； 策略模式第一步我们先来封装策略对象，如下代码：12345678910111213141516171819var strategy = &#123; isNotEmpty: function(value,errorMsg) &#123; if(value === '') &#123; return errorMsg; &#125; &#125;, // 限制最小长度 minLength: function(value,length,errorMsg) &#123; if(value.length &lt; length) &#123; return errorMsg; &#125; &#125;, // 手机号码格式 mobileFormat: function(value,errorMsg) &#123; if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125; &#125;; 接下来我们准备实现Validator类，Validator类在这里作为Context，负责接收用户的请求并委托给strategy 对象，如下代码：123456789101112131415161718192021var Validator = function()&#123; this.cache = []; // 保存效验规则&#125;;Validator.prototype.add = function(dom,rule,errorMsg) &#123; var str = rule.split(":"); this.cache.push(function()&#123; // str 返回的是 minLength:6 var strategy = str.shift(); str.unshift(dom.value); // 把input的value添加进参数列表 str.push(errorMsg); // 把errorMsg添加进参数列表 return strategys[strategy].apply(dom,str); &#125;);&#125;;Validator.prototype.start = function()&#123; for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123; var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息 if(msg) &#123; return msg; &#125; &#125;&#125;; Validator类在这里作为Context，负责接收用户的请求并委托给strategys对象。上面的代码中，我们先创建一个Validator对象，然后通过validator.add方法往validator对象中添加一些效验规则，validator.add方法接收3个参数，如下代码：validator.add(registerForm.password,’minLength:6’,’密码长度不能小于6位’)registerForm.password：校验的input输入框dom节点；minLength:6：是以一个冒号隔开的字符串，冒号前面的minLength代表客户挑选的strategys对象，冒号后面的数字6表示在效验过程中所必须验证的参数，minLength:6的意思是效验 registerForm.password 这个文本输入框的value最小长度为6位；如果字符串中不包含冒号，说明效验过程中不需要额外的效验信息；第三个参数：当效验未通过时返回的错误信息； 当我们往validator对象里添加完一系列的效验规则之后，会调用validator.start()方法来启动效验。如果validator.start()返回了一个errorMsg字符串作为返回值，说明该次效验没有通过，此时需要registerForm.onsubmit方法返回false来阻止表单提交。下面我们来看看初始化代码如下：123456789101112131415161718var validateFunc = function()&#123; var validator = new Validator(); // 创建一个Validator对象 /* 添加一些效验规则 */ validator.add(registerForm.userName,'isNotEmpty','用户名不能为空'); validator.add(registerForm.password,'minLength:6','密码长度不能小于6位'); validator.add(registerForm.userName,'mobileFormat','手机号码格式不正确'); var errorMsg = validator.start(); // 获得效验结果 return errorMsg; // 返回效验结果&#125;;var registerForm = document.getElementById("registerForm");registerForm.onsubmit = function()&#123; var errorMsg = validateFunc(); if(errorMsg)&#123; alert(errorMsg); return false; &#125;&#125; 下面是所有的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var strategys = &#123; isNotEmpty: function(value,errorMsg) &#123; if(value === '') &#123; return errorMsg; &#125; &#125;, // 限制最小长度 minLength: function(value,length,errorMsg) &#123; if(value.length &lt; length) &#123; return errorMsg; &#125; &#125;, // 手机号码格式 mobileFormat: function(value,errorMsg) &#123; if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125; &#125;;var Validator = function()&#123; this.cache = []; // 保存效验规则&#125;;Validator.prototype.add = function(dom,rule,errorMsg) &#123; var str = rule.split(":"); this.cache.push(function()&#123; // str 返回的是 minLength:6 var strategy = str.shift(); str.unshift(dom.value); // 把input的value添加进参数列表 str.push(errorMsg); // 把errorMsg添加进参数列表 return strategys[strategy].apply(dom,str); &#125;);&#125;;Validator.prototype.start = function()&#123; for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123; var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息 if(msg) &#123; return msg; &#125; &#125;&#125;;var validateFunc = function()&#123; var validator = new Validator(); // 创建一个Validator对象 /* 添加一些效验规则 */ validator.add(registerForm.userName,'isNotEmpty','用户名不能为空'); validator.add(registerForm.password,'minLength:6','密码长度不能小于6位'); validator.add(registerForm.userName,'mobileFormat','手机号码格式不正确'); var errorMsg = validator.start(); // 获得效验结果 return errorMsg; // 返回效验结果&#125;;var registerForm = document.getElementById("registerForm");registerForm.onsubmit = function()&#123; var errorMsg = validateFunc(); if(errorMsg)&#123; alert(errorMsg); return false; &#125;&#125;;]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2018%2F04%2F18%2Fdata-structure-and-algorithm.html</url>
    <content type="text"><![CDATA[数组数组的标准定义是：一个存储元素的线性集合（collection），元素可以通过索引来任意存取，索引通常是数字，用来计算元素之间存储位置的偏移量。几乎所有的编程语言都有类似的数据结构。然而 JavaScript 的数组却略有不同。JavaScript 中的数组是一种特殊的对象，用来表示偏移量的索引是该对象的属性，索引可能是整数。然而，这些数字索引在内部被转换为字符串类型，这是因为 JavaScript 对象中的属性名必须是字符串。数组在 JavaScript 中只是一种特殊的对象，所以效率上不如其他语言中的数组高。JavaScript 中的数组，严格来说应该称作对象，是特殊的 JavaScript 对象，在内部被归类为数组。由于 Array 在 JavaScript 中被当作对象，因此它有许多属性和方法可以在编程时使用。 双向链表双向链表属于链表的一种，也叫双链表，双向即是说它的链接方向是双向的，它由若干个节点组成，每个节点都包含下一个节点和上一个节点的指针，所以从双向链表的任意节点开始，都能很方便访问它的前驱结点和后继节点。 特点1、创建双链表时无需指定链表的长度。2、比起单链表，双链表需要多一个指针用于指向前驱节点，所以需要存储空间比单链表多一点。3、双链表的插入和删除需要同时维护 next 和 prev 两个指针。4、双链表中的元素访问需要通过顺序访问，即要通过遍历的方式来寻找元素。 执行过程图解创建创建一个空链表： 插入链尾将the monster is coming这些单词按顺序分别插入尾部，创建“the”节点： 连接起来： 创建“monster”节点： 再连接起来： 以此类推，将剩下的节点全部创建并连接起来： 创建迭代器迭代器的 current 指针初始指向head： 执行两次 next 操作， current 指针指向索引为2的节点： 此时的节点值为： 设置 current 指针指向索引为3的节点： 插入节点在索引1后面插入“big”节点。先将 current 指针指向索引为1的节点，创建一个”big”新节点： 插入到 current 指向位置： 删除节点将“big”节点删除，移动当前指针 current 到“big”节点位置： 执行删除操作，断掉“big”节点与前后两节点的 next 和 prev 指针，然后将“the”节点与“monster”节点关联起来： 双向循环链表前面的双向链表的 head 节点和链尾没有连接关系，所以如果要访问最后一个节点的话需要从头开始遍历，直到最后一个节点。在双向链表基础上改进一下，把 header 节点的 prev 指针指向最后一个节点，而最后一个节点的 next 指针指向 header 节点，于是便构成双向循环链表。 实现细节我们的链表将包括两个构造函数：Node 和 DoublyList。看看它们是怎样运作的。 Nodedata：存储数据。next：指向链表中下一个节点的指针。previous：指向链表中前一个节点的指针。 DoublyList_length：保存链表中节点的个数。head：指定一个节点作为链表的头节点。head：tail 指定一个节点作为链表的尾节点。add(value)：向链表中添加一个节点。searchNodeAt(position)：找到在列表中指定位置 n 上的节点。remove(position)：删除链表中指定位置上的节点。 节点模板在实现中，将会创建一个名为Node的构造函数：12345function Node(value) &#123; this.data = value; this.previous = null; this.next = null;&#125; 想要实现双向链表的双向遍历，我们需要指向链表两个方向的属性。这些属性被命名为previous和next。 接下来，我们需要实现DoublyList并添加三个属性：_length，head和tail。与单链表不同，双向链表包含对链表开头和结尾节点的引用。 由于DoublyList刚被实例化时并不包含任何节点，所以head和tail的默认值都被设置为null。12345function DoublyList() &#123; this._length = 0; this.head = null; this.tail = null;&#125; 操作节点接下来我们讨论以下方法：add(value)，remove(position)和searchNodeAt(position)。所有这些方法都用于单链表，然而，它们必须被重写为可以双向遍历。 方法1/3 add(value)12345678910111213141516DoublyList.prototype.add = function(value) &#123; var node = new Node(value); if (this._length) &#123; this.tail.next = node; node.previous = this.tail; this.tail = node; &#125; else &#123; this.head = node; this.tail = node; &#125; this._length++; return node;&#125;; 在这个方法中，存在两种可能。首先，如果链表是空的，则给它的head和tail分配节点。其次，如果链表中已经存在节点，则查找链表的尾部并把新节点分配给tail.next；同样，我们需要配置新的尾部以供进行双向遍历。换句话说，我们需要把tail.previous设置为原来的尾部。 方法2/3: searchNodeAt(position)创建一个名为searchNodeAt(position)的方法，它接受一个名为position的参数。这个参数是个整数，用来表示链表中的位置n。12345678910111213141516171819DoublyList.prototype.searchNodeAt = function(position) &#123; var currentNode = this.head, length = this._length, count = 1, message = &#123;failure: 'Failure: non-existent node in this list.'&#125;; // 1st use-case: an invalid position if (length === 0 || position &lt; 1 || position &gt; length) &#123; throw new Error(message.failure); &#125; // 2nd use-case: a valid position while (count &lt; position) &#123; currentNode = currentNode.next; count++; &#125; return currentNode;&#125;; 在if中检查第一种情况：参数非法。如果传给searchNodeAt(position)的索引是有效的，那么我们执行第二种情况 —— while循环。 在while的每次循环中，指向头的currentNode被重新指向链表中的下一个节点。这个循环不断执行，一直到count等于position。 方法3/3: remove(position)理解这个方法是最具挑战性的。我先写出代码，然后再解释它。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950DoublyList.prototype.remove = function(position) &#123; var currentNode = this.head, length = this._length, count = 1, message = &#123;failure: 'Failure: non-existent node in this list.'&#125;, beforeNodeToDelete = null, nodeToDelete = null, deletedNode = null; // 1st use-case: an invalid position if (length === 0 || position &lt; 1 || position &gt; length) &#123; throw new Error(message.failure); &#125; // 2nd use-case: the first node is removed if (position === 1) &#123; this.head = currentNode.next; // 2nd use-case: there is a second node if (!this.head) &#123; this.head.previous = null; // 2nd use-case: there is no second node &#125; else &#123; this.tail = null; &#125; // 3rd use-case: the last node is removed &#125; else if (position === this._length) &#123; this.tail = this.tail.previous; this.tail.next = null; // 4th use-case: a middle node is removed &#125; else &#123; while (count &lt; position) &#123; currentNode = currentNode.next; count++; &#125; beforeNodeToDelete = currentNode.previous; nodeToDelete = currentNode; afterNodeToDelete = currentNode.next; beforeNodeToDelete.next = afterNodeToDelete; afterNodeToDelete.previous = beforeNodeToDelete; deletedNode = nodeToDelete; nodeToDelete = null; &#125; this._length--; return message.success;&#125;; remove(position)处理以下四种情况：1、如果remove(position)的参数传递的位置存在, 将会抛出一个错误。2、如果remove(position)的参数传递的位置是链表的第一个节点（head），将把head赋值给deletedNode ，然后把head重新分配到链表中的下一个节点。 此时，我们必须考虑链表中否存在多个节点。 如果答案为否，头部将被分配为null，之后进入if-else语句的if部分。 在if的代码中，还必须将tail设置为null —— 换句话说，我们返回到一个空的双向链表的初始状态。如果删除列表中的第一个节点，并且链表中存在多个节点，那么我们输入if-else语句的else部分。 在这种情况下，我们必须正确地将head的previous属性设置为null —— 在链表的头前面是没有节点的。3、如果remove(position)的参数传递的位置是链表的尾部，首先把tail赋值给deletedNode，然后tail被重新赋值为尾部之前的那个节点，最后新尾部后面没有其他节点，需要将其next值设置为null。4、这里发生了很多事情，所以我将重点关注逻辑，而不是每一行代码。 一旦CurrentNode指向的节点是将要被remove(position)删除的节点时，就退出while循环。这时我们把nodeToDelete之后的节点重新赋值给beforeNodeToDelete.next。相应的，把nodeToDelete之前的节点重新赋值给afterNodeToDelete.previous。——换句话说，我们把指向已删除节点的指针，改为指向正确的节点。最后，把nodeToDelete 赋值为null。 最后，把链表的长度减1，返回deletedNode。 完整代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100function Node(value) &#123; this.data = value; this.previous = null; this.next = null;&#125; function DoublyList() &#123; this._length = 0; this.head = null; this.tail = null;&#125; DoublyList.prototype.add = function(value) &#123; var node = new Node(value); if (this._length) &#123; this.tail.next = node; node.previous = this.tail; this.tail = node; &#125; else &#123; this.head = node; this.tail = node; &#125; this._length++; return node;&#125;; DoublyList.prototype.searchNodeAt = function(position) &#123; var currentNode = this.head, length = this._length, count = 1, message = &#123;failure: 'Failure: non-existent node in this list.'&#125;; // 1st use-case: an invalid position if (length === 0 || position &lt; 1 || position &gt; length) &#123; throw new Error(message.failure); &#125; // 2nd use-case: a valid position while (count &lt; position) &#123; currentNode = currentNode.next; count++; &#125; return currentNode;&#125;; DoublyList.prototype.remove = function(position) &#123; var currentNode = this.head, length = this._length, count = 1, message = &#123;failure: 'Failure: non-existent node in this list.'&#125;, beforeNodeToDelete = null, nodeToDelete = null, deletedNode = null; // 1st use-case: an invalid position if (length === 0 || position &lt; 1 || position &gt; length) &#123; throw new Error(message.failure); &#125; // 2nd use-case: the first node is removed if (position === 1) &#123; this.head = currentNode.next; // 2nd use-case: there is a second node if (!this.head) &#123; this.head.previous = null; // 2nd use-case: there is no second node &#125; else &#123; this.tail = null; &#125; // 3rd use-case: the last node is removed &#125; else if (position === this._length) &#123; this.tail = this.tail.previous; this.tail.next = null; // 4th use-case: a middle node is removed &#125; else &#123; while (count &lt; position) &#123; currentNode = currentNode.next; count++; &#125; beforeNodeToDelete = currentNode.previous; nodeToDelete = currentNode; afterNodeToDelete = currentNode.next; beforeNodeToDelete.next = afterNodeToDelete; afterNodeToDelete.previous = beforeNodeToDelete; deletedNode = nodeToDelete; nodeToDelete = null; &#125; this._length--; return message.success;&#125;;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router-source-analysis]]></title>
    <url>%2F2018%2F04%2F10%2Fvue-router-source-analysis.html</url>
    <content type="text"></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router-source-analysis]]></title>
    <url>%2F2018%2F04%2F10%2Freact-router-source-analysis.html</url>
    <content type="text"></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel 使用指南]]></title>
    <url>%2F2018%2F04%2F08%2Fbabel-tutorial.html</url>
    <content type="text"><![CDATA[问题指南npm startQ：由于 babel@7 升级导致的 break change，transform-decorators-legacy 无需引入了，如果引入就会报以下错误：123456789$ npm startStarting the development server...Failed to compile../src/routes/orders/AllPaidOrderListPage.jsModule build failed: TypeError: Property right of AssignmentExpression expected node to be of a type [&quot;Expression&quot;] but instead got nullat Array.map (&lt;anonymous&gt;) A：将.webpackrc.js中的transform-decorators-legacy进行删除。 问题详情：]]></content>
      <categories>
        <category>babel</category>
      </categories>
      <tags>
        <tag>babel</tag>
      </tags>
  </entry>
</search>
