<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[golang 环境搭建]]></title>
    <url>%2F2019%2F07%2F27%2Fgo-environment-construction.html</url>
    <content type="text"><![CDATA[Golang官网下载地址：https://golang.org/dl/ Linux 下安装 Go 环境 打开官网下载地址选择对应的系统版本, 复制下载链接，这里我选择的是：go1.12.7.linux-amd64.tar.gz，对应下载链接：https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz cd 进入你用来存放安装包的目录。当然你也可以直接输入cd ~，然后执行： 1$ wget https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz 下载完成，执行tar解压到/usr/loacl目录下，得到go文件夹： 1$ tar -C /usr/local -zxvf go1.12.7.linux-amd64.tar.gz 添加/usr/loacl/go/bin目录到PATH变量中，其中添加到/etc/profile或$HOME/.profile都可以： 12345678910# 习惯用vim，没有的话可以用命令`sudo apt-get install vim`安装一个，# 按`o(在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本)`键进行编辑$ vim /etc/profile# 在最后一行添加$ export GOROOT=/usr/local/go$ export GOPATH=/mnt/go_workspaces$ export GOBIN=$GOPATH/bin$ export PATH=$PATH:$GOBIN:$GOROOT/bin# 按`ESC`键跳到命令模式，然后`:wq`保存退出后`source`一下:$ source /etc/profile 执行go version，如果显示版本号，则Go环境安装成功。 1$ go version Mac 下安装 Go 环境Mac分为压缩版和安装版，他们都是64位的。压缩版和Linux的大同小异，因为Mac和Linux都是基于Unix，终端这一块基本上是相同的。压缩版解压后，就可以和Linux一样放到一个目录下，这里也以/usr/local/go/为例。在配置环境变量的时候，针对所有用户和Linux是一样的，都是/etc/profile这个文件；针对当前用户，Mac下是$HOME/.bash_profile，其他配置都一样，包括编辑sudo权限和生效方式，最后在终端里测试：1$ go version]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[征战Objective-C]]></title>
    <url>%2F2019%2F04%2F07%2FObjective-C-tutotial.html</url>
    <content type="text"><![CDATA[Oc语言语法快速预览源代码文件扩展名对比： 头文件 实现文件 c语言 .h .c c++语言 .h .cpp oc语言 .h .m oc&amp;c++ .h .mm 类定义1234// 类名SimpleClass 继承 NSObject 类@interface SimpleClass : NSObject@end 类的属性申明1234567891011121314151617// 类名Person 继承 NSObject 类@interface Person : NSObject// NSString 类型的对象，因为前面有个 *（表示指针，指针指向一块堆内存）@property NSString *firstName;@property NSNumber *yearOfBirth;// 基础类型@property int yearOfBirth;// 只读属性@property (readonly) NSString * fristName;@property NSString *lastName;@end 方法减号方法（普通方法又称对象方法）申明123456789@interface Person: NSObject- (void)someMethod;- (void)someMethodWithValue:(SomeType)value;- (void)someMethodWithFirstValue:(SomeType)info1 secondValue:(AnotherType)info2;@end 加号方法（类方法，又称静态方法）申明12345678910111213@interface NSString: NSObject+ (id)string;+ (id)stringWithString:(NSString *)aString;+ (id)stringWithFormat:(NSString *)format;+ (id)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;+ (id)stringWithCString:(const char *)cString encoding:(NSStringEncoding)enc;@end 类的实现12345#import &quot;XYZPerson.h&quot;@implementation XYZPersion@end 完整的例子123456789101112131415161718// XYZPerson.h文件@interface XYZPerson : NSObject- (void)sayHello;@end// XYZPerson.m文件#import &quot;XYZPerson.h&quot;@implementation XYZPerson- (void)sayHello &#123; // @ 表示这是一个 Oc 类型字符串，不加 @，表示是一个纯 C 语言的字符串 NSLog(@&quot;Hello, World!&quot;);&#125;@end]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart 开发教程]]></title>
    <url>%2F2019%2F01%2F11%2Fdart-tutorial.html</url>
    <content type="text"><![CDATA[教程]]></content>
      <categories>
        <category>dart</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter 开发教程]]></title>
    <url>%2F2019%2F01%2F10%2Fflutter-tutorial.html</url>
    <content type="text"><![CDATA[常见问题Flutter：New ProjectWaiting for another flutter command to release the startup lock…解决办法：删除./flutter/bin/cache/lockfile]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode快速构建Flutter项目]]></title>
    <url>%2F2019%2F01%2F09%2Fflutter-vscode.html</url>
    <content type="text"><![CDATA[设置环境变量由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，在操作之前大家可以将如下环境变量加入到用户环境变量中：12$ export PUB_HOSTED_URL=https://pub.flutter-io.cn$ export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 安装 Flutter 插件插件中安装 Flutter 插件，安装完毕重新载入软件，安装 Flutter 插件的时候会默认的安装 Dart 插件（Dart是谷歌开发的计算机编程语言）: Flutter:new project打开vscode命令面板（comm+shift+p）选择Flutter:new project： 项目简介输入我们需要的项目名称选择对应存放的文件位置，等待依赖下载，我们会看到下图： 添加设备点击设备可以创建设备，开启已有设备，开启设备后选择到调试（虫子），添加调试配置，只管添加配置，然后保存就好了： 开启调试选择左上方的开启调试。项目开始打包构建安装到选择的选择的设备上： 编辑lib/main.dart中编辑插入Text(&#39;hello flutter&#39;)，保存文件，我们会发现效果会立马呈现到 App 上： 至此，教程就到这里了。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 ReactDom.render]]></title>
    <url>%2F2018%2F12%2F26%2Freact-dom-render.html</url>
    <content type="text"><![CDATA[参数有没有考虑过ReactDom.render的第一个参数到底是什么？render 函数的方法签名：1ReactDOM.render(element, container[, callback]) 既然讨论类型，那不如看看强类型的 ts 对这个函数的类型定义：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253export interface Renderer &#123; // Deprecated(render): The return value is deprecated. // In future releases the render function's return type will be void. &lt;T extends Element&gt;( element: DOMElement&lt;DOMAttributes&lt;T&gt;, T&gt;, container: Element | null, callback?: () =&gt; void ): T; ( element: Array&lt;DOMElement&lt;DOMAttributes&lt;any&gt;, any&gt;&gt;, container: Element | null, callback?: () =&gt; void ): Element; ( element: SFCElement&lt;any&gt; | Array&lt;SFCElement&lt;any&gt;&gt;, container: Element | null, callback?: () =&gt; void ): void; &lt;P, T extends Component&lt;P, ComponentState&gt;&gt;( element: CElement&lt;P, T&gt;, container: Element | null, callback?: () =&gt; void ): T; ( element: Array&lt;CElement&lt;any, Component&lt;any, ComponentState&gt;&gt;&gt;, container: Element | null, callback?: () =&gt; void ): Component&lt;any, ComponentState&gt;; &lt;P&gt;( element: ReactElement&lt;P&gt;, container: Element | null, callback?: () =&gt; void ): Component&lt;P, ComponentState&gt; | Element | void; ( element: Array&lt;ReactElement&lt;any&gt;&gt;, container: Element | null, callback?: () =&gt; void ): Component&lt;any, ComponentState&gt; | Element | void; ( parentComponent: Component&lt;any&gt; | Array&lt;Component&lt;any&gt;&gt;, element: SFCElement&lt;any&gt;, container: Element, callback?: () =&gt; void ): void;&#125; render 方法的返回值被废弃，在将来的版本中将返回 void。理由大概是将来可能会使用异步 render。 第一个参数的类型包括： DOMElement 或 DOMElement 数组，返回 Element SFCElement 或 SFCElement 数组，返回 void CElement 或 CElement 数组，返回 Component ReactElement 或 ReactElement 数组，返回 Component 或 Element 或 void 其中 SFCElement、CElement、DOMElement 都是 ReactElement 的子类，分别对应类组件和函数组件生成的 Element 以及 DOM 元素的包装。 还有最后一个，接收 4 个参数：123456( parentComponent: Component&lt;any&gt; | Array&lt;Component&lt;any&gt;&gt;, element: SFCElement&lt;any&gt;, container: Element, callback?: () =&gt; void): void; 从方法签名看，第一个参数接收的是一个 React 组件。 我试了一下，直接报错 Target container is not a DOM element. 查看 React 的源码也没有这个方法签名，和这个接近的方法是非正式的 unstable_renderSubtreeIntoContainer。 很多人误解了 React 的 Component 和 Element。12345const App = (&#123; name &#125;) =&gt; ( &lt;div&gt; Hello &#123;name&#125;! &lt;/div&gt;); App 就是 Component，而 是 Element。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>render</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Fiber]]></title>
    <url>%2F2018%2F12%2F24%2Freact-fiber.html</url>
    <content type="text"><![CDATA[React Fiber 是对 React 核心算法的重新实现，目标是提高其对动画，布局和手势等领域的适用性。它的最重要的特性是 incremental rendering（增量渲染）：它能够将渲染 work 拆分成多块并将这些任务块分散到多个帧执行。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>fiber</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决本地开发ajax跨域问题]]></title>
    <url>%2F2018%2F12%2F03%2Flocal-ajax-cross.html</url>
    <content type="text"><![CDATA[前后端分离，本地前端开发调用接口会有跨域问题，一般有以下几种解决方法： 后端接口打包到本地运行（缺点：每次后端更新都要去测试服下一个更新包，还要在本地搭建java运行环境，麻烦）。 CORS跨域：后端接口在返回的时候，在header中加入’Access-Control-Allow-origin’:* 之类的（有的时候后端不方便这样处理，前端就蛋疼了）。 用nodejs搭建本地http服务器，并且判断访问接口URL时进行转发，完美解决本地开发时候的跨域问题。 使用谷歌的插件allow-control-allow-origi解决，或者谷歌开启允许跨域，参考 http://camnpr.com/archives/chrome-args-disable-web-security.html]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript 教程]]></title>
    <url>%2F2018%2F11%2F30%2Ftypescript-tutorial.html</url>
    <content type="text"><![CDATA[TSLint 规则一套完整的 TSLint 规则，以及对每条规则的释义。 使用方法以tslint-config-alloy为例：安装： 1npm install --save-dev tslint typescript tslint-config-alloy 在你的项目根目录下创建 tslint.json，并将以下内容复制到文件中： 1234567891011121314&#123; &quot;extends&quot;: [&quot;tslint-config-alloy&quot;], &quot;linterOptions&quot;: &#123; &quot;exclude&quot;: [&quot;**/node_modules/**&quot;] &#125;, &quot;rules&quot;: &#123; // 这里填入你的项目需要的个性化配置，比如： // // // 一个缩进必须用两个空格替代 // // @has-fixer 可自动修复 // // @prettier 可交由 prettier 控制 // &quot;indent&quot;: [true, &quot;spaces&quot;, 2] &#125;&#125; CLI 中运行使用项目依赖中的 tslint 脚本，指定项目路径，检查所有 ts 后缀的文件： 1./node_modules/.bin/tslint --project . ./**/*.ts 将 tslint 作为 npm scripts 运行： package.json 的 scripts 字段添加一条 &quot;tslint&quot;: &quot;tslint --project . ./**/*.ts&quot; 运行 npm run tslint 与 VSCode 集成 在 VSCode 中安装 tslint 插件 按下 Cmd + , 或 Ctrl + ,，打开设置 将 tslint.autoFixOnSave，配置为 true 与 Prettier 集成Prettier 是一个专注于对代码风格进行统一格式化的工具，由于与 TSLint 的部分配置冲突，故需要使用 tslint-config-prettier 禁用掉 TSLint 的部分规则。 首先安装 prettier 和 tslint-config-prettier： 1npm install --save-dev prettier tslint-config-prettier 然后为 tslint.config 的 extends 添加 tslint-config-prettier 即可： 1234567891011121314&#123; &quot;extends&quot;: [&quot;tslint-config-alloy&quot;, &quot;tslint-config-prettier&quot;], &quot;linterOptions&quot;: &#123; &quot;exclude&quot;: [&quot;**/node_modules/**&quot;] &#125;, &quot;rules&quot;: &#123; // 这里填入你的项目需要的个性化配置，比如： // // // 一个缩进必须用两个空格替代 // // @has-fixer 可自动修复 // // @prettier 可交由 prettier 控制 // &quot;indent&quot;: [true, &quot;spaces&quot;, 2] &#125;&#125; 如果需要在 VSCode 中实现保存时修复 Prettier 的问题，则可以按照以下步骤配置： VSCode 安装 Prettier - Code formatter 插件 按下 Cmd + , 或 Ctrl + ,，打开设置 将 tslint.formatOnSave，配置为 true Prettier 的配置文件 prettier.config.js 可以参考这个： 123456789101112131415161718192021222324252627282930313233343536// prettier.config.js or .prettierrc.jsmodule.exports = &#123; // 一行最多 100 字符 printWidth: 100, // 使用 4 个空格缩进 tabWidth: 4, // 不使用缩进符，而使用空格 useTabs: false, // 行尾需要有分号 semi: true, // 使用单引号 singleQuote: true, // jsx 不使用单引号，而使用双引号 jsxSingleQuote: false, // 末尾不需要逗号 trailingComma: 'none', // 大括号内的首尾需要空格 bracketSpacing: true, // jsx 标签的反尖括号需要换行 jsxBracketSameLine: false, // 箭头函数，只有一个参数的时候，也需要括号 arrowParens: 'always', // 每个文件格式化的范围是文件的全部内容 rangeStart: 0, rangeEnd: Infinity, // 不需要写文件开头的 @prettier requirePragma: false, // 不需要自动在文件开头插入 @prettier insertPragma: false, // 使用默认的折行标准 proseWrap: 'preserve', // 根据显示样式决定 html 要不要折行 htmlWhitespaceSensitivity: 'css', // 换行符使用 lf endOfLine: 'lf'&#125;; 规则列表TypeScript 相关与 TypeScript 特性相关的规则。 名称 描述 adjacent-overload-signatures 重载的函数必须写在一起 ban-types 禁用特定的类型 member-access 必须指定类的成员的可访问性 member-ordering 指定类成员的排序规则 no-any 禁止使用any no-empty-interface 禁止定义空的接口 no-import-side-effect 禁止导入立即执行的模块，除了css、less、sass、scss no-inferrable-types 禁止给一个初始化时直接赋值为number、string或boolean的变量显式的指定类型 no-internal-module 禁止使用module来定义命名空间 no-magic-numbers 禁止使用魔法数字，仅允许使用一部分白名单中的数字 no-namespace 禁止使用namespace来定义命名空间 no-non-null-assertion 禁止使用 non-null 断言（感叹号） no-parameter-reassignment 禁止对函数的参数重新赋值 no-reference 禁止使用三斜线引入模块/// &lt;reference path=&quot;foo&quot; /&gt; no-unnecessary-type-assertion 禁止无用的类型断言 no-var-requires 禁止使用require来引入模块 only-arrow-functions 必须使用箭头函数，除非是单独的函数声明或是命名函数 prefer-for-of 使用for循环遍历数组时，如果index仅用于获取成员，则必须使用for of循环替代for循环 promise-function-async async函数的返回值必须是Promise typedef 变量、函数返回值、函数参数等必须要有类型定义 typedef-whitespace 类型定义的冒号前面必须没有空格，后面必须有一个空格 unified-signatures 函数重载时，若能通过联合类型将两个函数的类型声明合为一个，则使用联合类型而不是两个函数声明 功能性检查找出可能的错误，以及可能会产生 bug 的编码习惯。 名称 描述 await-promise await必须接受Promise ban 禁用指定的函数或全局方法 ban-comma-operator 禁止使用逗号操作符 curly if后面必须有{，除非是单行if forin for in内部必须有hasOwnProperty import-blacklist 禁用指定的模块 label-position 只允许在do, for, while 或 switch 中使用 label no-arg 禁止使用arguments.callee no-bitwise 禁止使用位运算 no-conditional-assignment 禁止在分支条件判断中有赋值操作 no-console 禁止使用console no-construct 禁止使用new来生成String,Number或Boolean no-debugger 禁止使用debugger no-duplicate-super 禁止super在一个构造函数中出现两次 no-duplicate-switch-case 禁止在switch语句中出现重复测试表达式的case no-duplicate-variable 禁止出现重复的变量定义或函数参数名 no-dynamic-delete 禁止delete动态的值 no-empty 禁止出现空代码块，允许catch是空代码块 no-eval 禁止使用eval no-floating-promises 函数返回值为Promise时，必须被处理 no-for-in-array 禁止对array使用for in循环 no-implicit-dependencies 禁止引入package.json中不存在的模块 no-inferred-empty-object-type 禁止推论出的类型是空对象类型 no-invalid-template-strings 禁止在非模版字符串中出现${} no-invalid-this 禁止在类外面使用this no-misused-new 禁止在接口中定义constructor，或在类中定义new no-null-keyword 禁止使用null no-object-literal-type-assertion 禁止对对象字面量进行类型断言（断言成any是允许的） no-return-await 禁止没必要的return await no-shadowed-variable 禁止变量名与上层作用域内的定义过的变量重复 no-sparse-arrays 禁止在数组中出现连续的逗号，如let foo = [,,] no-string-literal 禁止出现foo[&#39;bar&#39;]，必须写成foo.bar no-string-throw 禁止throw字符串，必须throw一个Error对象 no-submodule-imports 禁止import模块的子文件 no-switch-case-fall-through switch 的 case 必须 return 或 break no-this-assignment 禁止将this赋值给其他变量，除非是解构赋值 no-unbound-method 使用实例的方法时，必须bind到实例上 no-unnecessary-class 禁止定义没必要的类，比如只有静态方法的类 no-unsafe-any 禁止取用一个类型为any的对象的属性 no-unsafe-finally 禁止finally内出现return,continue,break,throw等 no-unused-expression 禁止无用的表达式 no-use-before-declare 变量必须先定义后使用 no-var-keyword 禁止使用var no-void-expression 禁止返回值为void类型 prefer-conditional-expression 可以用三元表达式时，就不用if else prefer-object-spread 使用{ ...foo, bar: 1 }代替Object.assign({}, foo, { bar: 1 }) radix parseInt必须传入第二个参数 restrict-plus-operands 使用加号时，两者必须同为数字或同为字符串 strict-boolean-expressions 在分支条件判断中必须传入布尔类型的值 strict-type-predicates 禁止出现永远为true或永远为false的条件判断（通过类型预测出一个表达式为true还是false） switch-default switch语句必须有default triple-equals 必须使用===或!==，禁止使用==或!= typeof-compare typeof表达式比较的对象必须是&#39;undefined&#39;,&#39;object&#39;,&#39;boolean&#39;,&#39;number&#39;,&#39;string&#39;,&#39;function&#39;或&#39;symbol&#39; use-default-type-parameter 传入的类型与默认类型一致时，必须省略传入的类型 use-isnan 必须使用isNaN(foo)而不是foo === NaN 可维护性增强代码可维护性的规则。 名称 描述 cyclomatic-complexity 禁止函数的循环复杂度超过 20，详见 https://en.wikipedia.org/wiki/Cyclomatic_complexity deprecation 禁止使用废弃（被标识了@deprecated）的API eofline 文件最后一行必须有一个空行 indent 一个缩进必须用四个空格替代 linebreak-style 限制换行符为 LF 或 CRLF max-classes-per-file 限制每个文件的类的数量 max-file-line-count 限制每个文件的行数 max-line-length 限制每行字符数 no-default-export 禁止使用default export no-duplicate-imports 禁止出现重复的import no-require-imports 禁止使用require object-literal-sort-keys 对象字面量必须按key排序 prefer-const 申明后不再被修改的变量必须使用const来申明 prefer-readonly 如果私有变量只在构造函数中被赋值，则必须使用readonly修饰符 trailing-comma 限制对象、数组、解构赋值等的最后一项末尾是否需要逗号 代码风格与代码风格相关的规则。 名称 描述 align 变量定义需要竖向对其 array-type 限制必须使用T[]或Array&lt;T&gt;之中的一种来定义数组的类型 arrow-parens 箭头函数的参数必须有小括号 arrow-return-shorthand 箭头函数的函数体只有return语句的时候，必须简写 binary-expression-operand-order 数字字面量必须在加号的右边，即禁止1 + x callable-types 可以简写为函数类型的接口或字面类似，必须简写 class-name 类名与接口名必须为驼峰式 comment-format 限制单行注释的规则 completed-docs 类、函数等必须写注释 encoding 文件类型必须是utf-8 file-header 文件的开头必须有指定的字符串 file-name-casing 约束文件命名规范 import-spacing import语句中，关键字之间的间距必须是一个空格 interface-name 接口名称必须已I开头 interface-over-type-literal 优先使用接口而不是字面类型 jsdoc-format 注释必须符合JSDoc规范 match-default-export-name import的名称必须和export default的名称一致 new-parens new后面只必须有一个空格 newline-before-return return语句前必须有空行 newline-per-chained-call 链式调用时，每次调用都必须占用一行 no-angle-bracket-type-assertion 类型断言必须使用as Type，禁止使用&lt;Type&gt; no-boolean-literal-compare 禁止变量与true或false比较 no-consecutive-blank-lines 禁止连续超过三行空行 no-irregular-whitespace 禁止使用特殊空白符（比如全角空格 no-parameter-properties 禁止给类的构造函数的参数添加修饰符 no-redundant-jsdoc 禁止JSDoc 中的冗余类型声明，因为 TypeScirpt 已经包含了大部分功能 no-reference-import 如果已经引入过库，则禁止使用三斜杠引入类型定义文件 no-trailing-whitespace 禁止行尾有空格 no-unnecessary-callback-wrapper 禁止没必要的函数调用，如x =&gt; f(x)应该简写为f no-unnecessary-initializer 禁止变量定义时赋值为undefined no-unnecessary-qualifier 在命名空间中，可以直接使用内部变量，不需要添加命名空间前缀 number-literal-format 小数必须以0.开头，禁止以.开头，并且不能以0结尾 object-literal-key-quotes 对象的key必须用引号包起来 object-literal-shorthand 必须使用a = {b}而不是a = {b: b} one-line if后的{禁止换行 one-variable-per-declaration 变量申明必须每行一个，for循环的初始条件中除外 ordered-imports import必须排序 prefer-function-over-method 类中没有使用this的方法应该提取成类外的函数 prefer-method-signature 必须使用foo(): void而不是foo: () =&gt; void prefer-switch 当if中只有===时，必须使用switch替换if prefer-template 必须使用模版字符串而不是字符串连接 prefer-while 当没有初始值的时候，必须使用while而不是for quotemark 必须使用单引号，jsx中必须使用双引号 return-undefined 使用return;而不是return undefined; semicolon 行尾必须有分号 space-before-function-paren 函数名前必须有空格 space-within-parens 括号内首尾禁止有空格 switch-final-break switch的最后一项禁止有break type-literal-delimiter 字面类型的每个成员都必须有分号 variable-name 限制变量命名规则 whitespace 限制空格的位置]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React refs 的前世今生]]></title>
    <url>%2F2018%2F11%2F30%2Freact-refs.html</url>
    <content type="text"><![CDATA[众所周知，React 通过声明式的渲染机制把复杂的 DOM 操作抽象成为简单的 state 与 props 操作，一时间将前端工程师从面条式的 DOM 操作中拯救出来。尽管我们一再强调在 React 开发中尽量避免 DOM 操作，但在一些场景中仍然无法避免。当然 React 并没有把路堵死，它提供了 ref 用于访问在 render 方法中创建的 DOM 元素或者是 React 组件实例。 React ref 使用在 React v16.3 之前，ref 通过字符串（string ref）或者回调函数（callback ref）的形式进行获取，在 v16.3 中，经0017-new-create-ref提案引入了新的 React.createRef API。1234567891011121314151617181920212223242526272829303132333435// string refclass MyComponent extends React.Component &#123; componentDidMount() &#123; this.refs.myRef.focus(); &#125; render() &#123; return &lt;input ref="myRef" /&gt;; &#125;&#125;// callback refclass MyComponent extends React.Component &#123; componentDidMount() &#123; this.myRef.focus(); &#125; render() &#123; return &lt;input ref=&#123;(ele) =&gt; &#123; this.myRef = ele; &#125;&#125; /&gt;; &#125;&#125;// React.createRefclass MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; componentDidMount() &#123; this.myRef.current.focus(); &#125; render() &#123; return &lt;input ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; string ref在 React.createRef 出现之前，string ref 就已被诟病已久，React 官方文档直接提出 string ref 将会在未来版本被移出，建议用户使用 callback ref 来代替，为何需要这么做呢？主要原因集中于以下几点： 当 ref 定义为 string 时，需要 React 追踪当前正在渲染的组件，在 reconciliation 阶段，React Element 创建和更新的过程中，ref 会被封装为一个闭包函数，等待 commit 阶段被执行，这会对 React 的性能产生一些影响。 1234567891011121314151617181920212223function coerceRef( returnFiber: Fiber, current: Fiber | null, element: ReactElement,) &#123; ... const stringRef = '' + element.ref; // 从 fiber 中得到实例 let inst = ownerFiber.stateNode; // ref 闭包函数 const ref = function(value) &#123; const refs = inst.refs === emptyObject ? (inst.refs = &#123;&#125;) : inst.refs; if (value === null) &#123; delete refs[stringRef]; &#125; else &#123; refs[stringRef] = value; &#125; &#125;; ref._stringRef = stringRef; return ref; ...&#125; 当使用 render callback 模式时，使用 string ref 会造成 ref 挂载位置产生歧义。 12345678910111213class MyComponent extends Component &#123; renderRow = (index) =&gt; &#123; // string ref 会挂载在 DataTable this 上 return &lt;input ref=&#123;'input-' + index&#125; /&gt;; // callback ref 会挂载在 MyComponent this 上 return &lt;input ref=&#123;input =&gt; this['input-' + index] = input&#125; /&gt;; &#125; render() &#123; return &lt;DataTable data=&#123;this.props.data&#125; renderRow=&#123;this.renderRow&#125; /&gt; &#125;&#125; string ref 无法被组合，例如一个第三方库的父组件已经给子组件传递了 ref，那么我们就无法再在子组件上添加 ref 了，而 callback ref 可完美解决此问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** string ref **/class Parent extends React.Component &#123; componentDidMount() &#123; // 可获取到 this.refs.childRef console.log(this.refs); &#125; render() &#123; const &#123; children &#125; = this.props; return React.cloneElement(children, &#123; ref: 'childRef', &#125;); &#125;&#125;class App extends React.Component &#123; componentDidMount() &#123; // this.refs.child 无法获取到 console.log(this.refs); &#125; render() &#123; return ( &lt;Parent&gt; &lt;Child ref="child" /&gt; &lt;/Parent&gt; ); &#125;&#125;/** callback ref **/class Parent extends React.Component &#123; componentDidMount() &#123; // 可以获取到 child ref console.log(this.childRef); &#125; render() &#123; const &#123; children &#125; = this.props; return React.cloneElement(children, &#123; ref: (child) =&gt; &#123; this.childRef = child; children.ref &amp;&amp; children.ref(child); &#125; &#125;); &#125;&#125;class App extends React.Component &#123; componentDidMount() &#123; // 可以获取到 child ref console.log(this.child); &#125; render() &#123; return ( &lt;Parent&gt; &lt;Child ref=&#123;(child) =&gt; &#123; this.child = child; &#125;&#125; /&gt; &lt;/Parent&gt; ); &#125;&#125; 在根组件上使用无法生效。 1ReactDOM.render(&lt;App ref="app" /&gt;, document.getElementById('main')); 对于静态类型较不友好，当使用 string ref 时，必须显式声明 refs 的类型，无法完成自动推导。 编译器无法将 string ref 与其 refs 上对应的属性进行混淆，而使用 callback ref，可被混淆。 12345678910/** string ref，无法混淆 */this.refs.myRef&lt;div ref="myRef"&gt;&lt;/div&gt;/** callback ref, 可以混淆 */this.myRef&lt;div ref=&#123;(dom) =&gt; &#123; this.myRef = dom; &#125;&#125;&gt;&lt;/div&gt;this.r&lt;div ref=&#123;(e) =&gt; &#123; this.r = e; &#125;&#125;&gt;&lt;/div&gt; createRef vs callback ref对比新的 createRef 与 callback ref，并没有压倒性的优势，只是希望成为一个便捷的特性，在性能上会会有微小的优势，callback ref 采用了组件 render 过程中在闭包函数中分配 ref 的模式，而 createRef 则采用了 object ref。 createRef 显得更加直观，类似于 string ref，避免了 callback ref 的一些理解问题，对于 callback ref 我们通常会使用内联函数的形式，那么每次渲染都会重新创建，由于 react 会清理旧的 ref 然后设置新的（见下图，commitDetachRef -&gt; commitAttachRef），因此更新期间会调用两次，第一次为 null，如果在 callback 中带有业务逻辑的话，可能会出错，当然可以通过将 callback 定义成类成员函数并进行绑定的方式避免。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class App extends React.Component &#123; state = &#123; a: 1, &#125;; componentDidMount() &#123; this.setState(&#123; a: 2, &#125;); &#125; render() &#123; return ( &lt;div ref=&#123;(dom) =&gt; &#123; // 输出 3 次 // &lt;div data-reactroot&gt;&lt;/div&gt; // null // &lt;div data-reactroot&gt;&lt;/div&gt; console.log(dom); &#125;&#125;&gt;&lt;/div&gt; ); &#125;&#125;class App extends React.Component &#123; state = &#123; a: 1, &#125;; constructor(props) &#123; super(props); this.refCallback = this.refCallback.bind(this); &#125; componentDidMount() &#123; this.setState(&#123; a: 2, &#125;); &#125; refCallback(dom) &#123; // 只输出 1 次 // &lt;div data-reactroot&gt;&lt;/div&gt; console.log(dom); &#125; render() &#123; return ( &lt;div ref=&#123;this.refCallback&#125;&gt;&lt;/div&gt; ); &#125;&#125; 不过不得不承认，createRef 在能力上仍逊色于 callback ref，例如上一节提到的组合问题，createRef 也是无能为力的。在 React v16.3 中，string ref/callback ref 与 createRef 的处理略有差别，让我们来看一下 ref 整个构建流程。1234567891011121314151617181920212223242526272829303132333435363738// markRef 前会进行新旧 ref 的引用比较if (current.ref !== workInProgress.ref) &#123; markRef(workInProgress);&#125;// effectTag 基于位操作，其中有 ref 的变更标志位function markRef(workInProgress: Fiber) &#123; workInProgress.effectTag |= Ref;&#125; // effectTag 与 Ref 的 &amp; 操作表示当前 fiber 有 ref 变更if (effectTag &amp; Ref) &#123; commitAttachRef(nextEffect);&#125;function commitAttachRef(finishedWork: Fiber) &#123; const ref = finishedWork.ref; if (ref !== null) &#123; const instance = finishedWork.stateNode; let instanceToUse; switch (finishedWork.tag) &#123; // 当前 Host 环境为 DOM 环境，HostComponent 即为 DOM 元素，需要借助实例获取原生 DOM 元素 case HostComponent: instanceToUse = getPublicInstance(instance); break; // 对于 ClassComponent 等而言，直接返回实例即可 default: instanceToUse = instance; &#125; // string ref 与 callback 都会去执行 ref 闭包函数 // createRef 会直接挂在 object ref 的 current 上 if (typeof ref === 'function') &#123; ref(instanceToUse); &#125; else &#123; ref.current = instanceToUse; &#125; &#125;&#125; 以上会涉及 react fiber 的一些概念与细节，比如：fiber 对象含义，fiber tree 构建更新过程，effectTag 的含义与收集过程等等，如果读者对上述细节不熟悉，可暂时跳过此段内容，不影响对于 ref 的掌握与理解。 React.forwardRef除了 createRef 以外，React16 还另外提供了一个关于 ref 的 API React.forwardRef，主要用于穿过父元素直接获取子元素的 ref。在提到 forwardRef 的使用场景之前，我们先来回顾一下，HOC（higher-order component）在 ref 使用上的问题，HOC 的 ref 是无法通过 props 进行传递的，因此无法直接获取被包裹组件（WrappedComponent），需要进行中转。1234567891011121314151617181920212223242526272829303132function HOCProps(WrappedComponent) &#123; class HOCComponent extends React.Component &#123; constructor(props) &#123; super(props); this.setWrappedInstance = this.setWrappedInstance.bind(this); &#125; getWrappedInstance() &#123; return this.wrappedInstance; &#125; // 实现 ref 的访问 setWrappedInstance(ref) &#123; this.wrappedInstance = ref; &#125; render() &#123; return &lt;WrappedComponent ref=&#123;this.setWrappedInstance&#125; &#123;...this.props&#125; /&gt;; &#125; &#125; return HOCComponent;&#125;const App = HOCProps(Wrap);&lt;App ref=&#123;(dom) =&gt; &#123; // 只能获取到 HOCComponent console.log(dom); // 通过中转后可以获取到 WrappedComponent console.log(dom.getWrappedInstance());&#125;&#125; /&gt; React.forwardRef 的原理其实非常简单，forwardRef 会生成 react 内部一种较为特殊的 Component。当进行创建更新操作时，会将 forwardRef 组件上的 props 与 ref 直接传递给提前注入的 render 函数，来生成 children。1const nextChildren = render(workInProgress.pendingProps, workInProgress.ref); React refs 到此就全部介绍完了，在 React16 新版本中，新引入了 React.createRef 与 React.forwardRef 两个 API，有计划移除老的 string ref，使 ref 的使用更加便捷与明确。如果你的应用已经升级到 React16.3+ 版本，那就放心大胆使用 React.createRef 吧，如果暂时没有的话，建议使用 callback ref 来代替 string ref。 参考：React ref 的前世今生]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>refs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npx—npm 5.2.0 内置的包执行器]]></title>
    <url>%2F2018%2F11%2F29%2Fnpm-npx.html</url>
    <content type="text"><![CDATA[最近在更新 npm 5.2.0 的时候，我发现除了可以使用npm命令，还有一个命令可以使用，这就是npx。 npm使得安装和管理依赖包变得非常简单，和npm的类似，npx这款工具旨在提供给用户更方便的包操作体验。当我们使用一些工具命令或者可执行文件时，相对于npm，npx把这个过程变得更加简单了。 根据zkat/npx 的描述，npx 会帮我们执行依赖包里的二进制文件。举例来说，之前我们可能会写这样的命令：12npm i -D webpack./node_modules/.bin/webpack -v 如果你对 bash 比较熟，可能会写成这样：12npm i -D webpack`npm bin`/webpack -v 有了 npx，我们只需要这样：1$ npx webpack -v 也就是说 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！npx 甚至支持运行远程仓库的可执行文件，如12345678910$ npx github:piuccio/cowsay hellonpx: 1 安装成功，用时 1.663 秒 _______&lt; hello &gt; ------- \ ^__^ \ (oo)\_______ (__)\ )\/\ ||----w | || || 再比如 npx http-server 可以一句话帮你开启一个静态服务器！（第一次运行会稍微慢一些）1234567$ npx http-servernpx: 23 安装成功，用时 48.633 秒Starting up http-server, serving ./Available on: http://127.0.0.1:8080 http://192.168.5.14:8080Hit CTRL-C to stop the server]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node 定时器详解]]></title>
    <url>%2F2018%2F11%2F24%2Fnode-timer.html</url>
    <content type="text"><![CDATA[JavaScript 是单线程运行，异步操作特别重要。 只要用到引擎之外的功能，就需要跟外部交互，从而形成异步操作。由于异步操作实在太多，JavaScript 不得不提供很多异步语法。这就好比，有些人老是受打击， 他的抗打击能力必须变得很强，否则他就完蛋了。 Node 的异步语法比浏览器更复杂，因为它可以跟内核对话，不得不搞了一个专门的库 libuv 做这件事。这个库负责各种回调函数的执行时间，毕竟异步任务最后还是要回到主线程，一个个排队执行。 为了协调异步任务，Node 居然提供了四个定时器，让任务可以在指定的时间运行。1234setTimeout()setInterval()setImmediate()process.nextTick() 前两个是语言的标准，后两个是 Node 独有的。它们的写法差不多，作用也差不多，不太容易区别。 你能说出下面代码的运行结果吗？123456// test.jssetTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));(() =&gt; console.log(5))(); 运行结果如下：123456$ node test.js53412 同步任务和异步任务首先，同步任务总是比异步任务更早执行。 前面的那段代码，只有最后一行是同步任务，因此最早执行。1(() =&gt; console.log(5))(); 本轮循环和次轮循环异步任务可以分成两种：12追加在本轮循环的异步任务追加在次轮循环的异步任务 所谓”循环”，指的是事件循环（event loop）。这是 JavaScript 引擎处理异步任务的方式，后文会详细解释。这里只要理解，本轮循环一定早于次轮循环执行即可。 Node 规定，process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环。 这就是说，文首那段代码的第三行和第四行，一定比第一行和第二行更早执行。123456// 下面两行，次轮循环执行setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));// 下面两行，本轮循环执行process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4)); process.nextTick()process.nextTick这个名字有点误导，它是在本轮循环执行的，而且是所有异步任务里面最快执行的。 Node 执行完所有同步任务，接下来就会执行process.nextTick的任务队列。所以，下面这行代码是第二个输出结果。1process.nextTick(() =&gt; console.log(3)); 基本上，如果你希望异步任务尽可能快地执行，那就使用process.nextTick。 微任务根据语言规格，Promise对象的回调函数，会进入异步任务里面的”微任务”（microtask）队列。 微任务队列追加在process.nextTick队列的后面，也属于本轮循环。所以，下面的代码总是先输出3，再输出4。1234process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));// 3// 4 注意，只有前一个队列全部清空以后，才会执行下一个队列。12345678process.nextTick(() =&gt; console.log(1));Promise.resolve().then(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));// 1// 3// 2// 4 上面代码中，全部process.nextTick的回调函数，执行都会早于Promise的。 至此，本轮循环的执行顺序就讲完了。123同步任务process.nextTick()微任务 事件循环的概念下面开始介绍次轮循环的执行顺序，这就必须理解什么是事件循环（event loop）了。 首先，有些人以为，除了主线程，还存在一个单独的事件循环线程。不是这样的，只有一个主线程，事件循环是在主线程上完成的。 其次，Node 开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情。1234同步任务发出异步请求规划定时器生效的时间执行process.nextTick()等等 最后，上面这些事情都干完了，事件循环就正式开始了。 事件循环的六个阶段事件循环会无限次地执行，一轮又一轮。只有异步任务的回调函数队列清空了，才会停止执行。 每一轮的事件循环，分成六个阶段。这些阶段会依次执行。123456timersI/O callbacksidle, preparepollcheckclose callbacks 每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。 下面简单介绍一下每个阶段的含义： timers这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。 I/O callbacks除了以下操作的回调函数，其他的回调函数都在这个阶段执行。123setTimeout()和setInterval()的回调函数setImmediate()的回调函数用于关闭请求的回调函数，比如socket.on('close', ...) idle, prepare该阶段只供 libuv 内部调用，这里可以忽略。 Poll这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。 这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。 check该阶段执行setImmediate()的回调函数。 close callbacks该阶段执行关闭请求的回调函数，比如socket.on(‘close’, …)。 事件循环的示例下面是来自官方文档的一个示例：1234567891011121314151617const fs = require('fs');const timeoutScheduled = Date.now();// 异步任务一：100ms 后执行的定时器setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms`);&#125;, 100);// 异步任务二：文件读取后，有一个 200ms 的回调函数fs.readFile('test.js', () =&gt; &#123; const startCallback = Date.now(); while (Date.now() - startCallback &lt; 200) &#123; // 什么也不做 &#125;&#125;); 上面代码有两个异步任务，一个是 100ms 后执行的定时器，一个是文件读取，它的回调函数需要 200ms。请问运行结果是什么？ 脚本进入第一轮事件循环以后，没有到期的定时器，也没有已经可以执行的 I/O 回调函数，所以会进入 Poll 阶段，等待内核返回文件读取的结果。由于读取小文件一般不会超过 100ms，所以在定时器到期之前，Poll 阶段就会得到结果，因此就会继续往下执行。 第二轮事件循环，依然没有到期的定时器，但是已经有了可以执行的 I/O 回调函数，所以会进入 I/O callbacks 阶段，执行fs.readFile的回调函数。这个回调函数需要 200ms，也就是说，在它执行到一半的时候，100ms 的定时器就会到期。但是，必须等到这个回调函数执行完，才会离开这个阶段。 第三轮事件循环，已经有了到期的定时器，所以会在 timers 阶段执行定时器。最后输出结果大概是200多毫秒。 setTimeout 和 setImmediate由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。12setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2)); 上面代码应该先输出1，再输出2，但是实际执行的时候，结果却是不确定，有时还会先输出2，再输出1。 这是因为setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，根据官方文档，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。 实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。 但是，下面的代码一定是先输出2，再输出1。123456const fs = require('fs');fs.readFile('test.js', () =&gt; &#123; setTimeout(() =&gt; console.log(1)); setImmediate(() =&gt; console.log(2));&#125;); 上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript函数柯里化]]></title>
    <url>%2F2018%2F11%2F23%2Fjavascript-currying.html</url>
    <content type="text"><![CDATA[什么是柯里化？官方的说法在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由克里斯托弗·斯特雷奇以逻辑学家哈斯凯尔·加里命名的，尽管它是Moses Schönfinkel和戈特洛布·弗雷格发明的。 在直觉上，柯里化声称如果你固定某些参数，你将得到接受余下参数的一个函数。在理论计算机科学中，柯里化提供了在简单的理论模型中，比如：只接受一个单一参数的lambda演算中，研究带有多个参数的函数的方式。函数柯里化的对偶是Uncurrying，一种使用匿名单参数函数来实现多参数函数的方法。 高阶函数 高阶函数定义：将函数作为参数或者返回值是函数的函数。 所以高阶函数分两种： 我们常见的 sort,reduce 等函数。 返回值是函数的函数。 一般而言，我们要理解常见的高阶函数还是很容易的。比如：12345678function add(a) &#123; return function(b) &#123; return a + b &#125;&#125;var add3 = add(3)add3(4) === 3 + 4 //true add 函数 在 es6 里的写法等价为：1let add = a =&gt; b =&gt; a + b 其实以上就是 柯里化函数 只不过用 es6 写，变了一个样子，后面详细介绍它的原理和特点。 柯里化或偏函数有什么用？无论是柯里化还是偏应用，我们都能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。 另一个最能体现柯里化应用的的是，当函数只有一个形参时，我们能够比较容易地组合它们（单一职责原则（Single responsibility principle））。因此，如果一个函数最终需要三个实参，那么它被柯里化以后会变成需要三次调用，每次调用需要一个实参的函数。当我们组合函数时，这种单元函数的形式会让我们处理起来更简单。 归纳下来，主要为以下常见的三个用途： 延迟计算 参数复用 动态生成函数]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>currying</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6 教程]]></title>
    <url>%2F2018%2F11%2F23%2Fes6-tutorial.html</url>
    <content type="text"><![CDATA[基本用法SymbolSymbol 是EC6规格所支持的一种新的数据类型 作用 作为属性名避免属性名冲突 替代代码中多次使用的字符串（例如：abc），多次使用的字符串在代码中不易维护，而这时候定义一个对象的属性（属性名用Symbol格式），值为abc，就可以作为全局变量来使用了。 由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 这个有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。 Set 和 Map 数据结构WeakMap概念按照MDN上的说明： WeakMap 对象是键/值对的集合，且其中的键是弱引用的。其键只能是对象，而值则可以是任意的。 从这段描述来看，我们可以大致推断出，WeakMap与Map的主要区别在于两点： WeakMap对key的引用是弱引用 WeakMap的key只能是对象null除外），不接受其他类型的值作为键名 123456789101112// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = &#123;foo: 1&#125;;wm1.set(key, 2);wm1.get(key) // 2// WeakMap 也可以接受一个数组，// 作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);wm2.get(k2) // "bar" 特性具体而言，WeakMap大致有如下一些明显的特性：1、WeakMap的key只能是对象（null除外），不接受其他类型的值作为键名例如：12345678910111213var m = new WeakMap();var k = &#123;&#125;;// 设置键值对m.set(k, 1);// 取值m.get(k); //1// 非对象的key会报错m.set(1, 2)// TypeError: 1 is not an object!m.set(Symbol(), 2)// TypeError: Invalid value used as weak map keym.set(null, 2)// TypeError: Invalid value used as weak map key 在上例中，我们使用了对象k作为WeakMap的key，设置了value为1。到下面取值的时候，只能使用同一个对象k去取。也就是说WeakMap是按照key的引用来对value进行存取的。如果将数值1和Symbol值作为 WeakMap 的键名，都会报错。 关于“key只能使用对象”和“value的查找是通过比较key的引用”这两个命题，其实是互为因果的，本质上是一个先有鸡还是先有蛋的问题：正因为WeakMap只能使用对象作为key，所以取值的时候对key进行查找也只能按对象引用进行查找。正因为WeakMap在查找的时候只能按对象引用进行查找，所以只能使用对象作为key，否则存进去的值根本无法查找取出。 2、key中的对象保持弱引用，不计入垃圾回收机制弱引用正是WeakMap中“Weak”的含义。熟悉JavaScript的朋友都知道引用是怎么回事，简单地说，当一个对象被引用的时候，往往意味着它正在被使用，或者在将来有可能会被使用。此时对象不会被垃圾回收机制回收掉。WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。123456const e1 = document.getElementById('foo');const e2 = document.getElementById('bar');const arr = [ [e1, 'foo 元素'], [e2, 'bar 元素'],]; 上面代码中，e1和e2是两个对象，我们通过arr数组对这两个对象添加一些文字说明。这就形成了arr对e1和e2的引用。 一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存。1234// 不需要 e1 和 e2 的时候// 必须手动删除引用arr [0] = null;arr [1] = null; 上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。 WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。123456const wm = new WeakMap();const element = document.getElementById('example');wm.set(element, 'some information');wm.get(element) // "some information" 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，上面的 DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。12345678const wm = new WeakMap();let key = &#123;&#125;;let obj = &#123;foo: 1&#125;;wm.set(key, obj);obj = null;wm.get(key)// Object &#123;foo: 1&#125; 上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。 语法WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。123456const wm = new WeakMap();// size、forEach、clear 方法都不存在wm.size // undefinedwm.forEach // undefinedwm.clear // undefined 用途WeakMap 应用的典型场合就是 DOM 节点作为键名。 Module 的语法export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。12345export &#123; foo, bar &#125; from 'my_module';// 可以简单理解为import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;; 上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。 模块的接口改名和整体输出，也可以采用这种写法。12345// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出export * from 'my_module'; 默认接口的写法如下。1export &#123; default &#125; from 'foo'; 具名接口改为默认接口的写法如下。12345export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6; 同样地，默认接口也可以改名为具名接口。1export &#123; default as es6 &#125; from './someModule'; 下面三种import语句，没有对应的复合写法。123import * as someIdentifier from "someModule";import someIdentifier from "someModule";import someIdentifier, &#123; namedIdentifier &#125; from "someModule"; 为了做到形式的对称，现在有提案，提出补上这三种复合写法。123export * as someIdentifier from "someModule";export someIdentifier from "someModule";export someIdentifier, &#123; namedIdentifier &#125; from "someModule";]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Hooks — 新一代 React API]]></title>
    <url>%2F2018%2F11%2F14%2Freact-hooks.html</url>
    <content type="text"><![CDATA[前言不得不说 React 等优秀框架的出现为前端开发带来了极大的便利，但是在React v16.7提出Hooks之前我们依旧不得不面对一些很恶心的问题： 组件逻辑复用麻烦且很有可能造成嵌套黑洞（Wrapper Hell）我们都知道react的核心思想是：将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来，但如果我们在大型项目中用react，我们便会发现项目中很多react组件冗长且难以复用，尤其是那些写成class的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。在 hooks 之前官方推荐的解决方式：渲染属性（Render Props）和高阶组件（Higher-Order Components），我们现在简单看一下这两种模式： 渲染属性（Render Props）渲染属性（Render Props）是一个组件间共享代码逻辑的小技巧, 通过props传递函数来实现。组件中有一个叫做render的prop, 值是一个返回React元素的函数, 在组件内部调用这个函数渲染组件。语言描述不够直观, 我们来看一个例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Cat extends React.Component &#123; render() &#123; const mouse = this.props.mouse; return ( &lt;img src="/cat.jpg" style=&#123;&#123; position: 'absolute', left: mouse.x, top: mouse.y &#125;&#125; /&gt; ); &#125;&#125;class Mouse extends React.Component &#123; constructor(props) &#123; super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = &#123; x: 0, y: 0 &#125;; &#125; handleMouseMove(event) &#123; this.setState(&#123; x: event.clientX, y: event.clientY &#125;); &#125; render() &#123; return ( &lt;div style=&#123;&#123; height: '100%' &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt; &#123;/* 使用传入函数的逻辑动态渲染 而不是硬编码地渲染固定内容 */&#125; &#123;this.props.render(this.state)&#125; &lt;/div&gt; ); &#125;&#125;class MouseTracker extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; &lt;Mouse render=&#123;mouse =&gt; ( &lt;Cat mouse=&#123;mouse&#125; /&gt; )&#125;/&gt; &lt;/div&gt; ); &#125;&#125; 可以看到我们的Mouse组件包含了所有跟状态相关的代码，而Cat组件则只是一个单纯的展示型组件，这样一来我们可以随处复用Mouse组件了。 虽然这个技巧或者说模式(Pattern)叫Render Props, 但不是说非用一个叫render的props来传递渲染函数, 习惯上我们更常写成下面这种：12345&lt;Mouse&gt; &#123;mouse =&gt; ( &lt;p&gt;The mouse position is &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt; )&#125;&lt;/Mouse&gt; 高阶组件简单说高阶组件就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，withUser函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。123456789101112const withUser = WrappedComponent =&gt; &#123; const user = sessionStorage.getItem("user"); return props =&gt; &lt;WrappedComponent user=&#123;user&#125; &#123;...props&#125; /&gt;;&#125;;const UserPage = props =&gt; ( &lt;div class="user-container"&gt; &lt;p&gt;My name is &#123;props.user&#125;!&lt;/p&gt; &lt;/div&gt;);export default withUser(UserPage); 以上这两种模式看上去都挺不错的，有许多库(比如React Router, React Motion)都有使用这些模式。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开devtool看看我们的组件层级嵌套是不是很夸张吧。如果我们采用 hooks 方式，把各种想要的功能写成一个一个可复用的自定义hook，当我们的组件想用什么功能时，直接在组件里调用这个hook即可，这样就简洁了许多，也没有多余的层级嵌套。 组件生命周期混乱由于React生命周期的存在，我们常常将一些逻辑强相关的代码分散地放置在组件的不同位置，造成我们的组件中出现了许多零散的、重复的代码，比如我们在 componentDidMount 中绑定事件、添加定时器，然后在 componentWillUnmount 中移除他们；又或者频繁地在 componentDidUpdate 中比较变化前和变化后的state来决定是否执行某些逻辑。 无状态组件（Function）和有状态组件（Class）选择问题回想我们在刚开始学习React的时候常常会疑惑该使用Functional Component(那个时候我们叫Stateless Component)还是有状态组件（Class Component），虽然两者得到的结果大致相同，但是书写方式却迥然不同。有些组件可能最开始的时候使用Functional，后来发现需要加入生命周期和state的支持又不得不大费周折地改成Class。这样不清不楚的定位对许多初学者来说，无疑造成了很大的困扰。更有些开发者便无脑的都使用 Class Component。 Class Component 的 this 指向问题我们用class创建react组件时，还有一件很麻烦的事情，就是this的指向问题。为了保证this的指向正确，我们要经常写这样的代码：this.handleClick = this.handleClick.bind(this)，或者是这样的代码：&lt;button onClick={() =&gt; this.handleClick(e)}&gt;。一旦我们不小心忘了绑定this，各种bug就随之而来，很麻烦。 Class Component 无法 prepack 优化在 class 里，类的属性即便内部没用到，对外部还是可访问的，所以类的属性在Uglify的时候是不会被编译的，同时如果一个类的方法没有被使用，编译器也无法将它识别出来并精简掉。 在这样的背景下，Hooks便横空出世了！ 什么是 HooksHooks是 React 提供的一系列新的方法（习惯上以useXXX命名）。这些方法将state、context和Class组件中的生命周期，统统抽象成了函数，使得我们在Functional组件中也能使用它们，甚至我们还可以将它们彼此进行组合，从而将特定的逻辑进一步进行抽象和封装，进一步作为npm包的形式进行发布！ 接下来我们一起认识一下新增的几个方法： State Hook: 为组件提供访问state的能力 Effect Hook: 监听state的变动，并在合适的时候调用 Custom Hooks: 用户自定义的钩子，是以上两者的组合。方便用户对操作state的逻辑进行封装 Other Hooks: 主要包括访问Context的钩子和管理复杂state的钩子 State Hook: React.useStateuseState: (any) =&gt; [state: , (newState) =&gt; null]useState 方法比较简单，基本就是一个简化版的 setState 。每次调用会生成一个新的state，并将状态与组件绑定。来看一个简单的例子：123456789101112131415import &#123; useState &#125; from 'react';function Example() &#123; // Declare a new state variable, which we'll call "count" const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 我们再来看一下使用class component后的版本：12345678910111213141516171819class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 可以看出，使用hooks后，代码简单了许多。我们分解来看到底state hooks做了什么： 声明状态变量1234import &#123; useState &#125; from 'react';function Example() &#123; const [count, setCount] = useState(0); useState是react自带的一个hook函数，它的作用就是用来声明状态变量。useState这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第[0]项是当前的状态值，第[1]项是可以改变状态值的函数，所以其实useState做的事情就是：声明了一个状态变量count，把它的初始值设为0，同时提供了一个可以更改count的函数setCount。上面这种表达形式，是借用了es6的数组解构（array destructuring），让我们的代码看起来更简洁。实际上数组解构是一件开销很大的事情，用下面这种写法，或者改用对象解构，性能会有很大的提升。如果不用数组解构的话，也可以写成下面这样：123let _useState = useState(0);let count = _useState[0];let setCount = _useState[1]; 使用状态值1&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; 是不是超简单？因为我们的状态count就是一个单纯的变量而已，我们再也不需要写成{this.state.count}这样了。 修改状态123&lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me&lt;/button&gt; 当用户点击按钮时，我们调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给react了，react将会重新渲染我们的Example组件，并且使用的是更新后的新状态，即count=1。这里我们要停下来思考一下，Example本质上也是一个普通的函数，为什么它可以记住之前的状态？ React 帮忙记住之前的状态通常来说我们在一个函数中声明的变量，当函数运行完成后，这个变量也就销毁了（这里我们先不考虑闭包等情况），比如考虑下面的例子：1234567function add(n) &#123; const result = 0; return result + 1;&#125;add(1); //1add(1); //1 不管我们反复调用add函数多少次，结果都是1。因为每一次我们调用add时，result变量都是从初始值0开始的。那为什么上面的Example函数每次执行的时候，都是拿的上一次执行完的状态值作为初始值？答案是：是react帮我们记住的。至于react是用什么机制记住的，我们可以再思考一下。 React 记住状态的关键点首先，useState是可以多次调用的，所以我们完全可以这样写：1234function ExampleWithManyStates() &#123; const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([&#123; text: 'Learn Hooks' &#125;]); 其次，useState接收的初始值没有规定一定要是string/number/boolean这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的this.setState做的是合并状态后返回一个新状态，而useState是直接替换老状态后返回新状态。最后，react也给我们提供了一个useReducer的hook，如果我们更喜欢redux式的状态管理方案的话。 从ExampleWithManyStates函数我们可以看到，useState无论调用多少次，相互之间是独立的。这一点至关重要。为什么这么说呢？ 其实我们看hook的“形态”，有点类似之前被官方否定掉的Mixins这种方案，都是提供一种“插拔式的功能注入”的能力。而mixins之所以被否定，是因为Mixins机制是让多个Mixins共享一个对象的数据空间，这样就很难确保不同Mixins依赖的状态不发生冲突。 而现在我们的hook，一方面它是直接用在function当中，而不是class；另一方面每一个hook都是相互独立的，不同组件调用同一个hook也能保证各自状态的独立性，这就是两者的本质区别。 react是根据useState出现的顺序记住状态还是看上面给出的ExampleWithManyStates例子，我们调用了三次useState，每次我们传的参数只是一个值（如42，‘banana’），我们根本没有告诉react这些值对应的key是哪个，那react是怎么保证这三个useState找到它对应的state呢？ 答案是，react是根据useState出现的顺序来定的。我们具体来看一下：123456789//第一次渲染useState(42); //将age初始化为42useState('banana'); //将fruit初始化为bananauseState([&#123; text: 'Learn Hooks' &#125;]); //...//第二次渲染useState(42); //读取状态变量age的值（这时候传的参数42直接被忽略）useState('banana'); //读取状态变量fruit的值（这时候传的参数banana直接被忽略）useState([&#123; text: 'Learn Hooks' &#125;]); //... 假如我们改一下代码：12345678910let showFruit = true;function ExampleWithManyStates() &#123; const [age, setAge] = useState(42); if(showFruit) &#123; const [fruit, setFruit] = useState('banana'); showFruit = false; &#125; const [todos, setTodos] = useState([&#123; text: 'Learn Hooks' &#125;]); 这样一来，123456789//第一次渲染useState(42); //将age初始化为42useState('banana'); //将fruit初始化为bananauseState([&#123; text: 'Learn Hooks' &#125;]); //...//第二次渲染useState(42); //读取状态变量age的值（这时候传的参数42直接被忽略）// useState('banana'); useState([&#123; text: 'Learn Hooks' &#125;]); //读取到的却是状态变量fruit的值，导致报错 鉴于此，react规定我们必须把hooks写在函数的最外层，不能写在ifelse等条件语句当中，来确保hooks的执行顺序一致。 Effect Hook: React.useEffectuseEffect: (() =&gt; {do sth…; return () =&gt; null}, []) =&gt; null因为通过useEffect，我们可以完成对Class Component所有关键生命周期的访问。 我们详细来看一下： 首先 useEffect 方法接收两个参数： 第一个参数是一个函数这个函数会在每次组件重新update后被调用（我们也可以理解为每次render之后会调用一遍这个方法）。只使用这个方法的作用和 componentDidUpdate 差不多，比如要实现输入和document.title的双向绑定： 12345678910import React, &#123; useState, useEffect &#125; from 'react'export default function Example() &#123; const [value, setValue] = useState('') useEffect(() =&gt; &#123; document.title = value &#125;) return &lt;input value=&#123;value&#125; onChange=&#123;e =&gt; &#123;setValue(e.target.value)&#125;&#125; /&gt;&#125; 这个函数的返回值也是一个函数回想一下，在使用class组件时， componentDidMount 其实是一类特殊的 componentDidUpdate —— 前者只会在第一次update时调用。所以在functional组件中，我们也可以使用useEffect来模拟 componentDidUpdate，只要区分函数的调用时机就可以。 不过在useEffect里不是这样做的。useEffect的做法更简单粗暴一些：在state更新时调用，在下一次render之前清理。useEffect方法接收一个函数作为返回值，返回的函数会在下一次render之前被调用。 (总觉得这样会不会太粗暴了一点，因为每次重新render都会绑定一次事件。1234567891011121314import React, &#123; useState, useEffect &#125; from 'react'export default function Example() &#123; const handleClick = () =&gt; &#123; // do something &#125; useEffect(() =&gt; &#123; document.querySelector('#example).addEventListener('click', handleClick) return () =&gt; &#123; document.querySelector('#example).removeEventListener('click', handleClick) &#125; &#125;) return &lt;div id="example"&gt;Lorem&lt;/div&gt;&#125; 第三个知识点是这个函数的第二个参数是一个数组这个数组里的值可以等同于我们在写 componentDidUpdate 里的条件判断。只有当数组中包含的值变化的时候才会触发当前的useEffect。 我们在上一节的例子中增加一个新功能：1234567891011121314151617181920import &#123; useState, useEffect &#125; from 'react';function Example() &#123; const [count, setCount] = useState(0); // 类似于componentDidMount 和 componentDidUpdate: useEffect(() =&gt; &#123; // 更新文档的标题 document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 我们对比看一下，如果没有hooks，我们会怎么写？123456789101112131415161718192021222324252627class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起ajax请求获取数据，添加一些监听的注册和取消注册，手动修改dom等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如componentDidMount，componentDidUpdate和componentWillUnmount。而现在的useEffect就相当与这些声明周期函数钩子的集合体。它以一抵三。 同时，由于前文所说hooks可以反复多次使用，相互独立。所以我们合理的做法是，给每一个副作用一个单独的useEffect钩子。这样一来，这些副作用不再一股脑堆在生命周期钩子里，代码变得更加清晰。 useEffect做了什么？我们再梳理一遍下面代码的逻辑：123456function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); 首先，我们声明了一个状态变量count，将它的初始值设为0。然后我们告诉react，我们的这个组件有一个副作用。我们给useEffecthook传了一个匿名函数，这个匿名函数就是我们的副作用。在这个例子里，我们的副作用是调用browser API来修改文档标题。当react要渲染我们的组件时，它会先记住我们用到的副作用。等react更新了DOM之后，它再依次执行我们定义的副作用函数。 这里要注意几点： 第一，react首次渲染和之后的每次渲染都会调用一遍传给useEffect的函数。而之前我们要用两个声明周期函数来分别表示首次渲染（componentDidMount）和之后的更新导致的重新渲染（componentDidUpdate）。 第二，useEffect中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的componentDidMount或componentDidUpdate中的代码则是同步执行的。这种安排对大多数副作用说都是合理的，但有的情况除外，比如我们有时候需要先根据DOM计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生。 useEffect怎么解绑一些副作用这种场景很常见，当我们在componentDidMount里添加了一个注册，我们得马上在componentWillUnmount中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。 怎么清除呢？让我们传给useEffect的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。这种模式在一些pubsub模式的实现中很常见。看下面的例子：12345678910111213141516171819202122import &#123; useState, useEffect &#125; from 'react';function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup return function cleanup() &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125; 这里有一个点需要重视！这种解绑的模式跟componentWillUnmount不一样。componentWillUnmount只会在组件被销毁前执行一次而已，而useEffect里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。所以我们一起来看一下下面这个问题。 为什么要让副作用函数每次组件更新都执行一遍？我们先看以前的模式：12345678910111213componentDidMount() &#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );&#125;componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );&#125; 很清除，我们在componentDidMount注册，再在componentWillUnmount清除注册。但假如这时候props.friend.id变了怎么办？我们不得不再添加一个componentDidUpdate来处理这种情况：1234567891011121314... componentDidUpdate(prevProps) &#123; // 先把上一个friend.id解绑 ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // 再重新注册新但friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125;... 看到了吗？很繁琐，而我们但useEffect则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的：123456781.页面首次渲染2.替friend.id=1的朋友注册3.突然friend.id变成了24.页面重新渲染5.清除friend.id=1的绑定6.替friend.id=2的朋友注册... 怎么跳过一些不必要的副作用函数按照上一节的思路，每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给useEffect传第二个参数即可。用第二个参数来告诉react只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 只有当count的值发生变化时，才会重新执行`document.title`这一句 当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。也就是componentDidMount加componentWillUnmount的模式。不过这种用法可能带来bug，少用。 还有哪些自带的Effect Hooks?除了上文重点介绍的useState和useEffect，react还给我们提供来很多有用的hooks：useContextuseReduceruseCallbackuseMemouseRefuseImperativeMethodsuseMutationEffectuseLayoutEffect 怎么写自定义的Effect Hooks?为什么要自己去写一个Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。 比如我们可以把上面写的FriendStatus组件中判断朋友是否在线的功能抽出来，新建一个useFriendStatus的hook专门用来判断某个id是否在线。123456789101112131415161718import &#123; useState, useEffect &#125; from 'react';function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125; 这时候FriendStatus组件就可以简写为：12345678function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125; 简直Perfect！假如这个时候我们又有一个朋友列表也需要显示是否在线的信息：123456789function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123;&#123; color: isOnline ? 'green' : 'black' &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 简直Fabulous！]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nuxtjs 开发笔记]]></title>
    <url>%2F2018%2F11%2F03%2Fnuxt-tutorial.html</url>
    <content type="text"><![CDATA[开发用法按需引入UI组件库这边以 element-ui 组件库为例： 使用 babel-plugin-importbabel-plugin-import是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式12# 安装 babel-plugin-import 插件npm i babel-plugin-import -D 配置nuxt.config.js：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980module.exports = &#123; mode: 'universal', /* ** Headers of the page */ head: &#123; title: pkg.name, meta: [ &#123; charset: 'utf-8' &#125;, &#123; name: 'viewport', content: 'width=device-width, initial-scale=1' &#125;, &#123; hid: 'description', name: 'description', content: pkg.description &#125; ], link: [ &#123; rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' &#125; ] &#125;, /* ** Customize the progress-bar color */ loading: &#123; color: '#fff' &#125;, /* ** Global CSS */ css: [ // 自定义公共 CSS 文件 '@/assets/css/common.css' // 全部引用的时候需要用到 // 'element-ui/lib/theme-chalk/index.css' ], /* ** Plugins to load before mounting the App */ plugins: [ &#123; src: '@/plugins/element-ui', ssr: true &#125; ], /* ** Nuxt.js modules */ modules: [ ], /* ** Build configuration */ build: &#123; analyze: true, vendor: ['element-ui'], maxChunkSize: 300000, babel: &#123; plugins: [ [ 'component', &#123; 'libraryName': 'element-ui', 'styleLibraryName': 'theme-chalk' &#125; ] ] &#125;, /* ** You can extend webpack config here */ extend(config, ctx) &#123; // Run ESLint on save if (ctx.isDev &amp;&amp; ctx.isClient) &#123; config.module.rules.push(&#123; enforce: 'pre', test: /\.(js|vue)$/, loader: 'eslint-loader', exclude: /(node_modules)/ &#125;) &#125; &#125; &#125;&#125; 修改plugins/element-ui.js：123import Vue from 'vue'import &#123; Button &#125; from 'element-ui'Vue.component(Button.name, Button) 最后使用组件1&lt;el-button type="primary"&gt;主要按钮&lt;/el-button&gt; 常见问题]]></content>
      <categories>
        <category>Nuxtjs</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库自增主键归零的几种方法]]></title>
    <url>%2F2018%2F11%2F02%2Fmysql-rzero.html</url>
    <content type="text"><![CDATA[MySQL自增主键归零的方法： 一、如果曾经的数据都不需要的话，可以直接清空所有数据，并将自增字段恢复从1开始计数：1truncate table table_name; 二、当用户没有truncate的权限时且曾经的数据不需要时： 1、删除原有主键： 1alter table 'table_name' drop 'id'; 2、添加新主键： 1alter table 'table_name' add 'id' int(11) not null first; 3、设置新主键： 1alter table 'table_name' modify column 'id' int(11) not null auto_increment, add primary key(id); 三、当用户没有权限时： 1、可以直接设置数据表的 AUTO_INCREMENT 值为想要的初始值，比如10000：1alter table 'table_name' auto_increment = 10000;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>rzero</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[参与一个 GitHub 开源项目]]></title>
    <url>%2F2018%2F11%2F01%2Fpart-github-open-project.html</url>
    <content type="text"><![CDATA[gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。gitHub作为开源项目的著名托管地，可谓无人不知，越来越多的个人和公司纷纷加入到Github的大家族里来，好多人都想为开源尽一份绵薄之力。对于个人来讲，我们把自己的项目托管到gitHub上并不表示我们参与了gitHub开源项目，只能说我们开源了自己的项目，可以任别人自由下载。那么该如何参与gitHub的开源项目呢？相信很多人都有这方面的疑问，网上也有一些参差不齐的教程教大家如何“pull request”、如何“commit”等等。但这些教程往往不够全面或不够完全正确，搞不好可能让我们陷入一个误区。下面将涵盖我们在一个典型的项目中可能出现的事情以及如何为开源项目作出贡献。 找项目我们推荐从已正在使用的或感兴趣的项目开始。这里有几个很棒的地方供参考： GitHub Explore：受欢迎和热门的项目。GitHub Stars：被其他人star过的项目（指的是我们自己库的项目）。GitHub Showcases：一个能搜索相关库的方法。LayerVault News：前端和设计相关的项目。 Github开源项目中可能遇到的因素Community（社区）项目通常会有一个社区维护，由不同角色（正规或非正规）的其他用户组成：所有者（Owner）：即创建该项目且在他们Github账户上有该项目的用户或组织。维护者和协作者（Maintainers and Collaborators）：致力于一个项目并促进该项目发展的用户。通常所有者和维护者是同一个用户或组织，他们对项目库都有写的权限。贡献者（Contributors）：每一个对该项目发出过pull request并合并到项目中的用户都是贡献者。社区成员（Community Members）：即那些经常使用且非常关心该项目的用户，他们在讨论功能特征和pull request上非常活跃。 Docs（文档）一般项目中都有的文件。 Readme几乎所有的Github项目都包含一个README.md文件。readme提供了该项目的一个概览及关于如何使用、构建甚至如何贡献于一个项目的相关细节。 Contributing项目和项目维护者不同，所以每个项目所期望的作贡献的最佳方法也会有所不同。一定要注意一个标注为CONTRIBUTING的文档，Contributing文档详细描述了一个项目的维护者希望看到贡献的补丁或功能应该符合怎样的规格。这可能包含要写什么测试，代码语法规范或补丁集中的区域。 License一个LICENSE文件当然就是该项目的许可证了。一个开源项目的license会告诉用户他们能做和不能做的（例如使用、修改、重新发布），及告诉贡献者他们允许其他人做的。有许多的办法对开源项目加上许可证，我们可以在choosealicense.com读到更多的关于每个许可证的含义。 Documentation and Wikis许多大型项目有的不只有一个readme来指导人么如何使用他们的项目。在这种情况下我们通常能够发现一个指向库中名为“docs”的另一个文件或文件夹的链接。另外，该库也可能使用Github wiki来代替文档。 参与项目既然我们已经找到了理解该项目的相关资料，下面我们就可以采取一些行动了。 创建话题如果我们发现了正在使用的项目中的一个bug（但是我们不知道怎么去修复它），或对文档有不解或对项目有疑问 — 那么创建一个话题吧！这非常容易且一般我们不管创建什么话题，我们都可能不是唯一一个出现该问题的人，所以其他人可能会发现我们的话题很有帮助。关于更多的话题介绍，请查看我们的Issues guide。 话题专业提示在建话题之前检查已有的话题：话题重复对双方都无利，所以搜索整个正开放和已关闭的话题以检查我们遇到的问题是否已经有人解决了。务必对自己的问题有清晰的认识：期望的结果是什么？然而却发生了什么？ 详细描述其他人如何重现该问题。在像JSFiddle或CodePen类似的平台上重现该问题并给出问题demo的链接。包含一些系统相关的细节，比如用的什么浏览器、库或操作系统及版本号。在我们的话题或在Gist里贴出我们的错误输出或日志。如果在话题里贴出来，请用三个反引号 ```，包围起来使得能够良好的呈现给大家。 Pull Request如果我们能够修复bug或自己添加功能 — 太棒了，请发一个pull request 吧！确保我们已经读过任何关于contributing的文档，且需要理解license以及已经签过CLA（如果需要的话）。一旦我们提交了一个pull request，维护者就会将我们的分支与已有的分支作比较来决定是否要合并（即pull in）我们作的改动。 Pull Request专业提示 Fork该项目库及将它clone到本地。通过添加为远程的方式在本地连接到原来的‘upstream’库。经常从‘upstream’库pull in改动以保持库最新，这样当我们提交pull request时，就不大可能发生合并冲突了。点这里看更多的指导细节。 为我们的编辑单独建立一个分支。 务必清楚所出现的问题以及如何重现该问题或为什么我们的功能有帮助。然后同样的要清楚做一些改变有哪些步骤。 最好测试一下。在任何已有的测试（如果存在）上运行我们所做的改动并在必要时创建新的测试。不管测试存不存在，都要确保我们的改动不会破坏已有的项目。 如果我们的改动包含了HTML/CSS方面的不同，那么请包含改动前和改动后的截图。将我们的图片拖放到我们pull request的正文里。 尽我们所能的在项目的风格上多做努力。这可能意味着使用不同于我们自己Github库中采用的缩进，分号或注释，但是这让维护者更容易合并，也让其他人更容易理解和以后的维护。 开放的Pull Requests一旦我们打开一个pull request，就会有一个讨论，围绕我们提出的改变作出探讨。其他的贡献者和用户可能会参与进来，但最终由维护者做决定。我们可能会被要求对我们的pull request做一些改变，如果这样，请给我们的分支添加更多的commit并push它们 — 它们将自动的加入到已有的pull request里。 如果我们的pull request被合并了 — 太好了！如果没被合并的话，也没什么大不了的，也许这不是项目维护者所期望看到的改动，亦或者他们已经致力于该bug或功能。这种情况有可能发生，所以我们的建议是：对收到的结果做出反馈，进一步努力然后再次pull request出去— 或者创建我们自己的开源项目。 大致流程首先需要在github上注册账号并登陆，这个不多说了安装git，到github官网下载安装包。为账号添加添加ssh keyfork我们想参与的开源项目浏览github上的开源项目，然后点击fork，这时就跳转到了我们的账号下，此项目就是我们账号下的一个项目了。fork就相当于把别人的项目克隆到自己的账号下一份，以后我们的修改都应是提交到我们自己github账号下的这个项目中，我们是没有权限直接push到原作者账号下的项目中的。 clone项目到本地复制项目clone地址注意是clone自己账号下的项目地址，不是原作者的，原作者的我们虽然也可以clone到本地，但是我们是没push权限的。还要注意这里咱们使用ssh协议，所以要选择ssh类型的地址。 将项目原地址添加为远程仓库复制原作者的项目地址，添加为自己的一个远程仓库，用来实时将原项目的修改更新到咱们本地并合并。注意也是复制ssh协议类型的地址哦。1$ git remote add upstream 原作者的远程仓库 使用 git remote -v可以看到我们有两个仓库一个origin，咱们自己的github仓库；一个upstream，原作者的远程仓库。当然也可以不用upstream这个名字。 创建branch，用于添加自己的修改这只是一个约定成俗的方式，当然我们也可以在master上添加修改，创建新的branch添加自己的修改的好处是，我们可以同时添加多个修改，在一个修改还没有被原作者merge时，我们可以用master创建新的branch继续我们的其它修改。在这里我们在新添加的分支上修改：执行如下命令123$ git branch test # 创建test分支$ git checkout test # 切换到test分支 然后就可以添加我们的修改了。 将修改push到我们的github上由于我们的github上还没有test分支，所以我们得把命令写全了：1$ git push origin test:test 我们的修改已经push到了我们的github下了，但是我们要向原作者请求合并到原项目中，如果原作者合并了，也就意味着我们是此项目的贡献者了。到我们的github上点击pull request按钮，创建一个pull request。提交完pull request，原作者就会看到我们的合并请求，我们就等待原作者是否采纳了。 注意事项1、clone时一定要注意选择ssh协议的链接。否则可能导致clone失败，或者后续push失败。 2、将公钥添加到github后，一定要更新自己当前的私钥（命令：ssh-add ~/.ssh/id_rsa），否则会push失败。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>open</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 开发汇总]]></title>
    <url>%2F2018%2F10%2F31%2Fshell-tutorial.html</url>
    <content type="text"><![CDATA[Shell 教程Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。 Shell 脚本Shell 脚本（shell script），是一种为 shell 编写的脚本程序。业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。 Shell 环境Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。Linux 的 Shell 种类众多，常见的有： 常见问题bash: /usr/local/bin: Permission denied原因：数据权限问题 解决办法：123$ sudo chmod 755 /usr/local/bin$ sudo chmod -R 755 /usr/local/bin # 递归下面]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[揭秘 http]]></title>
    <url>%2F2018%2F10%2F30%2Fhttp-tutorial.html</url>
    <content type="text"><![CDATA[options 请求当我们的 ajax 的请求为非简单请求时，浏览器会进行预检，即发送 OPTIONS 请求到服务器，询问是否允许跨域。如果响应中允许我们预检请求的跨域行为，则浏览器会进行真正的请求。否则，会报 405 错误。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊es7的decorator修饰器]]></title>
    <url>%2F2018%2F10%2F21%2Fes7-decorator.html</url>
    <content type="text"><![CDATA[类的修饰许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。目前，有一个提案将这项功能，引入了ECMAScript 123456789@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; target.isTestable = true;&#125;MyTestableClass.isTestable; // true 上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。testable函数的参数target是MyTestableClass类本身。 基本上，修饰器的行为就是下面这样。 1234567@decoratorclass A &#123;&#125;等同于class A &#123;&#125;A = decorator(A) || A; 也就是说，修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。 123function testable(target) &#123; // ...&#125; 上面代码中，testable函数的参数target，就是会被修饰的类。 如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。 12345678910111213function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false 上面代码中，修饰器testable可以接受参数，这就等于可以修改修饰器的行为。 注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。 前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作。 123456789function testable(target) &#123; target.prototype.isTestable = true;&#125;@testableclass MyTestableClass &#123;&#125;let obj = new MyTestableClass();obj.isTestable // true 上面代码中，修饰器函数testable是在目标类的prototype对象上添加属性，因此就可以在实例上调用。 下面是另外一个例子。 12345678910111213141516171819// mixins.jsexport function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list) &#125;&#125;// main.jsimport &#123; mixins &#125; from './mixins'const Foo = &#123; foo() &#123; console.log('foo') &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // 'foo' 上面代码通过修饰器mixins，把Foo类的方法添加到了MyClass的实例上面。可以用Object.assign()模拟这个功能。 12345678910const Foo = &#123; foo() &#123; console.log('foo') &#125;&#125;;class MyClass &#123;&#125;Object.assign(MyClass.prototype, Foo);let obj = new MyClass();obj.foo() // 'foo' 实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。 123class MyReactComponent extends React.Component &#123;&#125;export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent); 有了装饰器，就可以改写上面的代码。 12@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component &#123;&#125; staticstatic涉及到了ES6的class，我们定义一个组件的时候通常是定义了一个类，而static则是创建了一个属于这个类的属性或者方法。 组件则是这个类的一个实例，component的props和state是属于这个实例的，所以实例还未创建，我们又怎么可能读得到props和state呢？ 总结来说static并不是react定义的，而加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用]]></content>
      <categories>
        <category>es7</category>
      </categories>
      <tags>
        <tag>decorator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sketch 使用汇总]]></title>
    <url>%2F2018%2F10%2F19%2Fsketch-tutorial.html</url>
    <content type="text"><![CDATA[下载与安装Sketch 50 for Mac汉化破解版 Sketch 50 Mac安装教程 从本站下载完软件资源包之后，将其解压出来，您将会得到一个名为“Sketch_50_[TNT].dmg”的可运行程序文件，我们双击将它打开运行。 然后会出现一个弹窗示意我们将“Sketch.app”拖入到应用程序的文件夹中 之后我们便可以在MacOS自带的文件管理器的“应用程序”栏目中找到我们的Sketch Mac 破解版，找到它之后我们就可以双击打开将它运行了 打开可能会提示损坏 反正我是这样 看教程第三步 Sketch 50 Mac使用教程1、为了能够顺利让您安装上小梁为您准备的Sketch Mac 破解版，小梁介意您将Mac打开未知来源软件安装2、如果您的Mac系统是10.12以下，请直接在“安全与隐私”模块中勾选“开启未知来源安装”3、如果您的Mac系统是10.12以上，请将“sudo spctl –master-disable”粘贴至“终端.app”运行代码，即可解决“安装文件已损坏”、“无法安装”等一系列问题 Sketch 50 Mac汉化教程方法一、(前提是安装过上一个汉化版本)1、双击安装SketchI18N.sketchplugin （前提你装好了 Sketch） 2、然后点击replace 3、然后再点击Sketch 50 Mac右下角的choose，后重启Sketch 50 Mac即可，安装汉化破解完成。 方法二1.双击安装SketchI18N.sketchplugin （前提你装好了 Sketch） 2.提示安装成功后点 OK 进入sketch 3.在 Sketch 中按快捷键 control command + x 实现（也可以在菜单栏中 Plugins 中找到 Sketchl18N） 4.汉化成功]]></content>
      <categories>
        <category>sketch</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧用 JS 位运算]]></title>
    <url>%2F2018%2F10%2F09%2Fjavascript-bits-op.html</url>
    <content type="text"><![CDATA[位运算是直接对二进制位进行计算，它直接处理每一个比特位，是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能够使用。位运算只对整数起作用，如果一个运算数不是整数，会自动转为整数后再运行。在JavaScript内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。 运算符 用法 描述 按位与（AND） a &amp; b 对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。 按位或（OR） a &#124; b 对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。 按位异或（XOR） a ^ b 对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。 按位非（NOT） ~ a 反转操作数的比特位，即0变成1，1变成0。 左移（Left shift） a &lt;&lt; b 将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用0填充。 有符号右移 a &gt;&gt; b 将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。 无符号右移 a &gt;&gt;&gt; b 对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。 位运算是非常底层的运算，由于速度极快，借助位运算的特性还能实现一些算法，因此恰当地使用运算有很多好处。下面搜集了比较常用的例子： 类型转化1234let myVar = "3.14";str = "" + myVar; // 转化为 字符串int = ~~myVar; // 转化为整数bool = !!myVar; // 转化为布尔 使用~, &gt;&gt;, &lt;&lt;, &gt;&gt;&gt;, |来取整123456console.log(~~8.88) // 8console.log(8.88 &gt;&gt; 0) // 8console.log(8.88 &lt;&lt; 0) // 8console.log(8.88 | 0) // 8// &gt;&gt;&gt;不可对负数取整console.log(8.88 &gt;&gt;&gt; 0) // 8 切换变量 0 或 1123456789101112/ 一般方法：if (toggle) &#123; toggle = 0;&#125; else &#123; toggle = 1;&#125;// 一般方法的简写：togle = toggle ? 0 : 1;// 使用位运算的方法：toggle ^= 1; 使用&amp;运算符判断一个数的奇偶1234// 偶数 &amp; 1 = 0// 奇数 &amp; 1 = 1console.log(2 &amp; 1) // 0console.log(3 &amp; 1) // 1 使用按位非 ~ 判断索引存在这是一个很常用的技巧，如判断一个数是否在数组里面：12// 如果url含有?号，则后面拼上&amp;符号，否则加上?号url += ~url.indexOf("?") ? "&amp;" : "?"; 其中 ~ 满足-(X+1)这个规律。 使用 异或^ 交换两个数交换两个整数的值，最直观的做法是借助一个临时变量：123456let a = 5, b = 6;// 交换a, b的值 let c = a;a = b;b = c; 现在要求不能使用额外的变量或内容空间来交换两个整数的值。这个时候就得借助位运算，使用异或可以达到这个目的：123456let a = 5, b = 6;a = a ^ b; // 1 式b = a ^ b; // 2 式 b 等于 5a = a ^ b; // 3 式 a 等于 6 这个是为什么呢？很简单，把1、2式：12a = a ^ b;b = a ^ b; 连起来就等价于：1b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a; 同理连同第3式可得：12a = (a ^ b) ^ a // 在执行第3式的时候b已经变成a了，而a是第1式的a ^ b = a ^ a ^ b = 0 ^ b = b; 异或还经常被用于加密。 使用按位与&amp;去掉高位按位与有很多作用，其中一个就是去操作数的高位，只保留低位，例如有a, b两个数：12let a = 0b01000110; // 十进制为70let b = 0b10000101; // 十进制为133 现在认为他们的高位是没用的，只有低4位是有用的，即最后面4位，为了比较a，b后4位的大小，可以这样比较：1a &amp; 0b00001111 &lt; b &amp; 0b00001111 // true a, b的前4位和0000与一下之后就都变成0了，而后四位和1111与一下之后还是原来的数。这个实际的作用是有一个数字它的前几位被当作A用途，而后几位被用当B用途，为了去掉前几位对B用途的影响，就可以这样与一下。 另外一个例子是子网掩码，假设现在我是网络管理员，我能够管理的IP地址是从192.168.1.0到192.168.1.255，即只能调配最后面8位。现在把这些IP地址分成6个子网，通过IP地址进行区分，由于6等于二进制的110，所以最后面8位的前3位用来表示子网，而后5位用来表示主机（即总的主机数的范围为00001 ~ 11111， 共30个）。当前网络的子网掩码取为255.255.255.111 00000即255.255.255.224，假设某台主机的IP地址为192.168.1.120，现在要知道它处于哪个子网，可以用它IP地址与子网掩码与一下：120 &amp; 224 = 96 = 0b 011 00000，就知道它所在的子网为011即3号子网。 这个是保留高位去掉低位的例子，刚好与上面的例子相反。 使用&amp;, &gt;&gt;, |来完成rgb值和16进制颜色值之间的转换1234567891011121314151617181920212223242526/** * 16进制颜色值转RGB * @param &#123;String&#125; hex 16进制颜色字符串 * @return &#123;String&#125; RGB颜色字符串 */ function hexToRGB(hex) &#123; var hexx = hex.replace('#', '0x') var r = hexx &gt;&gt; 16 var g = hexx &gt;&gt; 8 &amp; 0xff var b = hexx &amp; 0xff return `rgb($&#123;r&#125;, $&#123;g&#125;, $&#123;b&#125;)`&#125;/** * RGB颜色转16进制颜色 * @param &#123;String&#125; rgb RGB进制颜色字符串 * @return &#123;String&#125; 16进制颜色字符串 */function RGBToHex(rgb) &#123; var rgbArr = rgb.split(/[^\d]+/) var color = rgbArr[1]&lt;&lt;16 | rgbArr[2]&lt;&lt;8 | rgbArr[3] return '#'+ color.toString(16)&#125;// -------------------------------------------------hexToRGB('#ffffff') // 'rgb(255,255,255)'RGBToHex('rgb(255,255,255)') // '#ffffff 使用按位与&amp;进行标志位判断现在有个后台管理系统，操作权限分为一级、二级、三级管理员，其中一级管理员拥有最高的权限，二、三级较低，有些操作只允许一、二级管理员操作，有些操作只允许一、三级管理员操作。现在已经登陆的某权限的用户要进行某个操作，要用怎样的数据结构能很方便地判断他能不能进行这个操作呢？ 我们用位来表示管理权限，一级用第3位，二级用第2位，三级用第1位，即一级的权限表示为0b100 = 4，二级权限表示为0b010 = 2，三级权限表示为0b001 = 1。如果A操作只能由一级和二级操作，那么这个权限值表示为6 = 0b110，它和一级权限与一下：6 &amp; 4 = 0b110 &amp; 0b100 = 4，得到的值不为0，所以认为有权限，同理和二级权限与一下6 &amp; 2 = 2也不为0，而与三级权限与一下6 &amp; 1 = 0，所以三级没有权限。这里标志位的1表示打开，0表示关闭。 这样的好处在于，我们可以用一个数字，而不是一个数组来表示某个操作的权限集，同时在进行权限判断的时候也很方便。 使用按位|构造属性集上面构造了一个权限的属性集，属性集的例子还有很多，例如我在《Google地图开发总结》里面就提到一个边界判断的例子——要在当前鼠标的位置往上弹一个悬浮框，但是当鼠标比较靠边的时候就会导致悬浮框超出边界了。 为此，需要做边界判断，总共有3种超出情况：右、上、左，并且可能会叠加，如鼠标在左上角的时候会导致左边和上面同时超出。需要记录超出的情况进行调整，用001表示右边超出，010表示上方超出，100表示左边超出，如下代码计算：123456789101112131415let postFlag = 0;//右边超出if(pos.right &lt; maxLen) posFlag |= 1;//上面超出if(pos.top &lt; maxLen) posFlag |= 2;//左边超出if(pos.left &lt; maxLeftLen) posFlag |= 4;//对超出的情况进行处理，代码略switch(posFlag)&#123; case 1: //右 case 2: //上 case 3: //右上 case 4: //左 case 6: //左上&#125; 如果左边和上面同时超出，那么通过或运算2 | 4 = 6，得到6 = 0b110. 就知道了超出的情况，这样的代码相对于在if里面写两个判断要好一些。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 教程]]></title>
    <url>%2F2018%2F10%2F04%2Fgit-tutorial.html</url>
    <content type="text"><![CDATA[常见问题使用.gitkeep来追踪空的文件夹Git会忽略空的文件夹。如果你想版本控制包括空文件夹，根据惯例会在空文件夹下放置.gitkeep文件。其实对文件名没有特定的要求。一旦一个空文件夹下有文件后，这个文件夹就会在版本控制范围内。 当用git命令拉取最新代码时，有时会遇到如下的提示， Found a swap file by the name “.git/.MERGE_MSG.swp”在项目根目录（如/StudioProjects/demo/Leave）下，找到.git/.MERGE_MSG.swp这个文件删除即可。注：mac 删除命令rm -rf .MERGE_MSG.swp pre-commit/hook: No such file or directory提交时发生如下错误：1.git/hooks/pre-commit: line 2: ./node_modules/pre-commit/hook: No such file or directory 解决办法：方法一：进入.git/hooks目录，并删除pre-commit文件。 方法二：在命令上加上--no-verify。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jest 开发笔记]]></title>
    <url>%2F2018%2F10%2F01%2Fjest-tutorial.html</url>
    <content type="text"><![CDATA[Jest 基本教程前言随着互联网日新月异的发展，用户对于页面的美观度，流畅度以及各方面的体验有了更高的要求，我们的网页不再是简单的承载文字，图片等简单的信息传递给用户，我们需要的是更加美观的页面展示，更快的浏览速度，更加的丰富的用户交互效果。好的用户体验必要需要优秀的前端技术支撑，这使得我们的前端技术发生了翻天覆地的变化，前端的项目架构也越来越复杂，已经逐渐的演变成重量级的前端。从软件开发的角度来说项目技术的复杂度会带来开发，测试，交付流程等的复杂度的成倍提升，而我们知道测试是整个软件交付流程中非常重要的一个环节，在重前端的形势下，前端的测试的构建也显示尤为重要，特别是针对于前后端分离的项目来说。本次将给大家介绍一个JavaScript的测试框架：Jest。 什么是JestJest是由Facebook发布的开源的、基于Jasmine的JavaScript单元测试框架。Jest源于Facebook两年前的构想，用于快速、可靠地测试Web聊天应用。它吸引了公司内部的兴趣，Facebook的一名软件工程师Jeff Morrison半年前又重拾这个项目，改善它的性能，并将其开源。Jest的目标是减少开始测试一个项目所要花费的时间和认知负荷，因此它提供了大部分我们需要的现成工具：快速的命令行接口、Mock工具集以及它的自动模块Mock系统。此外，如果我们在寻找隔离工具例如Mock库，大部分其它工具将让我们在测试中（甚至经常在我们的主代码中）写一些不尽如人意的样板代码，以使其生效。Jest与Jasmine框架的区别是在后者之上增加了一些层。最值得注意的是，运行测试时，Jest会自动模拟依赖。Jest自动为每个依赖的模块生成Mock，并默认提供这些Mock，这样就可以很容易地隔离模块的依赖。 Jest优点 Jest 可以利用其特有的快照测试功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。 安装配置简单，非常容易上手，几乎是零配置的，通过npm 命令安装就可以直接运行了。 Jest 内置了测试覆盖率工具istanbul，可以通过命令开启或者在 package.json 文件进行更详细的配置。运行 istanbul 除了会再终端展示测试覆盖率情况，还会在项目下生产一个 coverage 目录，内附一个测试覆盖率的报告，让我们可以清晰看到分支的代码的测试情况。 集成了断言库，不需要再引入第三方的断言库，并且非常完美的支持React组件化测试。 命令行参数]]></content>
      <categories>
        <category>jest</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有史以来最小的编译器源码解析]]></title>
    <url>%2F2018%2F09%2F14%2Fthe-super-tiny-compiler.html</url>
    <content type="text"><![CDATA[the-super-tiny-compiler详细中文注释 the-super-tiny-compiler 前言稍微接触一点前端，我们都知道现在前端“ES6即正义”，然而浏览器的支持还处于进行阶段，所以我们常常会用一个神奇的工具将 ES6 语法转换为目前支持比较广泛的 ES5 语法，这里我们所说的神奇的工具就是编译器。编译器功能非常纯粹，将字符串形式的输入语言编译成目标语言的代码字符串（以及sourcemap），常用的编译器除了我们熟知的 Babel 之外，还有 gcc。不过我们今天的主角是号称可能是有史以来最小的编译器the-super-tiny-compiler，去掉注释也就200多行代码，作者 James Kyle 更是 Babel 的活跃维护者之一。这个编译器的功能很简单，主要把 Lisp 风格的函数调用转换成 C 风格的，例如： Lisp 风格（转化前） C 风格（转化后） 2 + 2 (add 2 2) add(2, 2) 4 - 2 (subtract 4 2) subtract(4, 2) 2 + (4 - 2) (add 2 (subtract 4 2)) add(2, subtract(4, 2)) 编译器工作的三个阶段绝大多数编译器的编译过程都差不多，主要分为三个阶段：解析：将代码字符串解析成抽象语法树。转换：对抽象语法树进行转换操作。代码生成：根据转换后的抽象语法树生成目标代码字符串。 解析解析过程主要分为两部分：词法分析和语法分析。1、词法分析是由词法分析器把原始代码字符串转换成一系列词法单元（token），词法单元是一个数组，由一系列描述独立语法的对象组成，它们可以是数值、标签、标点符号、运算符、括号等。2、语法分析是由语法分析器将词法分析器生成的词法单元转化为能够描述语法结构（包括语法成分及其关系）的中间表示形式（Intermediate Representation）或抽象语法树（Abstract Syntax Tree），其中抽象语法树（简称AST）是个深层嵌套的对象。 我们简单看一下 the-super-tiny-compiler 的整个解析过程：1234567891011121314151617181920212223242526272829303132333435363738// 原始代码字符串(add 2 (subtract 4 2))// 词法分析转化后生成的词法单元[ &#123; type: 'paren', value: '(' &#125;, &#123; type: 'name', value: 'add' &#125;, &#123; type: 'number', value: '2' &#125;, &#123; type: 'paren', value: '(' &#125;, &#123; type: 'name', value: 'subtract' &#125;, &#123; type: 'number', value: '4' &#125;, &#123; type: 'number', value: '2' &#125;, &#123; type: 'paren', value: ')' &#125;, &#123; type: 'paren', value: ')' &#125;,]// 语法分析转化后生成的抽象语法树（AST）&#123; type: 'Program', body: [&#123; type: 'CallExpression', name: 'add', params: [&#123; type: 'NumberLiteral', value: '2', &#125;, &#123; type: 'CallExpression', name: 'subtract', params: [&#123; type: 'NumberLiteral', value: '4', &#125;, &#123; type: 'NumberLiteral', value: '2', &#125;] &#125;] &#125;]&#125; 转换转换过程主要任务是修改 AST，即遍历解析过程生成的 AST，同时进行一系列操作，比如增/删/改节点、增/删/改属性、创建新树等，我们简单看一下 the-super-tiny-compiler 的整个转换过程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 原始代码字符串(add 2 (subtract 4 2))// 解析过程生成的 AST&#123; type: 'Program', body: [&#123; type: 'CallExpression', name: 'add', params: [&#123; type: 'NumberLiteral', value: '2', &#125;, &#123; type: 'CallExpression', name: 'subtract', params: [&#123; type: 'NumberLiteral', value: '4', &#125;, &#123; type: 'NumberLiteral', value: '2', &#125;] &#125;] &#125;]&#125;// 转换过程生成的 AST&#123; type: 'Program', body: [&#123; type: 'ExpressionStatement', expression: &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: 'add' &#125;, arguments: [&#123; type: 'NumberLiteral', value: '2' &#125;, &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: 'subtract' &#125;, arguments: [&#123; type: 'NumberLiteral', value: '4' &#125;, &#123; type: 'NumberLiteral', value: '2' &#125;] &#125; &#125; &#125;]&#125; 代码生成根据转换过程生成的抽象语法树生成目标代码字符串。 源码实现接下来我们根据编译器工作的三个阶段逐一分析一下 the-super-tiny-compiler 源码实现。 词法分析词法分析器主要任务把原始代码字符串转换成一系列词法单元（token）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 词法分析器 参数：代码字符串inputfunction tokenizer(input) &#123; // 当前正在处理的字符索引 let current = 0; // 词法单元数组 let tokens = []; // 遍历字符串，获得词法单元数组 while (current &lt; input.length) &#123; let char = input[current]; // 匹配左括号 if (char === '(') &#123; // type 为 'paren'，value 为左圆括号的对象 tokens.push(&#123; type: 'paren', value: '(' &#125;); // current 自增 current++; // 结束本次循环，进入下一次循环 continue; &#125; // 匹配右括号 if (char === ')') &#123; tokens.push(&#123; type: 'paren', value: ')' &#125;); current++; continue; &#125; // \s：匹配任何空白字符，包括空格、制表符、换页符、换行符、垂直制表符等 let WHITESPACE = /\s/; // 跳过空白字符 if (WHITESPACE.test(char)) &#123; current++; continue; &#125; // [0-9]：匹配一个数字字符 let NUMBERS = /[0-9]/; // 匹配数值 if (NUMBERS.test(char)) &#123; let value = ''; // 匹配连续数字，作为数值 while (NUMBERS.test(char)) &#123; value += char; char = input[++current]; &#125; tokens.push(&#123; type: 'number', value &#125;); continue; &#125; // 匹配形如"abc"的字符串 if (char === '"') &#123; let value = ''; // 跳跃左双引号 char = input[++current]; // 获取两个双引号之间的所有字符 while (char !== '"') &#123; value += char; char = input[++current]; &#125; // 跳跃右双引号 char = input[++current]; tokens.push(&#123; type: 'string', value &#125;); continue; &#125; // [a-z]：匹配1个小写字符 i 模式中的字符将同时匹配大小写字母 let LETTERS = /[a-z]/i; // 匹配函数名，要求只含大小写字母 if (LETTERS.test(char)) &#123; let value = ''; // 获取连续字符 while (LETTERS.test(char)) &#123; value += char; char = input[++current]; &#125; tokens.push(&#123; type: 'name', value &#125;); continue; &#125; // 无法识别的字符，抛出错误提示 throw new TypeError('I dont know what this character is: ' + char); &#125; // 词法分析器的最后返回词法单元数组 return tokens;&#125; 通过遍历代码字符串，分拣出各个词素，然后构成由一系列描述独立语法的对象组成的数组的词法单元。 语法分析语法分析器主要任务是将词法分析器生成的词法单元转化为能够描述语法结构（包括语法成分及其关系）的中间表示形式（Intermediate Representation）或抽象语法树（Abstract Syntax Tree）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 语法分析器 参数：词法单元数组function parser(tokens) &#123; // 当前正在处理的 token 索引 let current = 0; // 递归遍历（因为函数调用允许嵌套），将 token 转成 AST 节点 function walk() &#123; // 获取当前 token let token = tokens[current]; // 数值 if (token.type === 'number') &#123; // current 自增 current++; // 生成一个 AST节点 'NumberLiteral'，用来表示数值字面量 return &#123; type: 'NumberLiteral', value: token.value, &#125;; &#125; // 字符串 if (token.type === 'string') &#123; current++; // 生成一个 AST节点 'StringLiteral'，用来表示字符串字面量 return &#123; type: 'StringLiteral', value: token.value, &#125;; &#125; // 函数 if (token.type === 'paren' &amp;&amp; token.value === '(') &#123; // 跳过左括号，获取下一个 token 作为函数名 token = tokens[++current]; let node = &#123; type: 'CallExpression', name: token.value, params: [] &#125;; // 再次自增 `current` 变量，获取参数 token token = tokens[++current]; // 右括号之前的所有token都属于参数 while ((token.type !== 'paren') || (token.type === 'paren' &amp;&amp; token.value !== ')')) &#123; node.params.push(walk()); token = tokens[current]; &#125; // 跳过右括号 current++; return node; &#125; // 无法识别的字符，抛出错误提示 throw new TypeError(token.type); &#125; // AST的根节点 let ast = &#123; type: 'Program', body: [], &#125;; // 填充ast.body while (current &lt; tokens.length) &#123; ast.body.push(walk()); &#125; // 最后返回ast return ast;&#125; 通过递归来将词法分析器生成的词法单元转化为能够描述语法结构的 ast。 遍历12345678910111213141516171819202122232425262728293031323334353637383940414243// 遍历器function traverser(ast, visitor) &#123; // 遍历 AST节点数组 对数组中的每一个元素调用 `traverseNode` 函数。 function traverseArray(array, parent) &#123; array.forEach(child =&gt; &#123; traverseNode(child, parent); &#125;); &#125; // 接受一个 `node` 和它的父节点 `parent` 作为参数 function traverseNode(node, parent) &#123; // 从 visitor 获取对应方法的对象 let methods = visitor[node.type]; // 通过 visitor 对应方法操作当前 node if (methods &amp;&amp; methods.enter) &#123; methods.enter(node, parent); &#125; switch (node.type) &#123; // 根节点 case 'Program': traverseArray(node.body, node); break; // 函数调用 case 'CallExpression': traverseArray(node.params, node); break; // 数值和字符串，不用处理 case 'NumberLiteral': case 'StringLiteral': break; // 无法识别的字符，抛出错误提示 default: throw new TypeError(node.type); &#125; if (methods &amp;&amp; methods.exit) &#123; methods.exit(node, parent); &#125; &#125; // 开始遍历 traverseNode(ast, null);&#125; 通过递归遍历 AST，在遍历过程中通过 visitor 对应方法操作当前 node，这里和切面差不多。 转换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 转化器，参数：ASTfunction transformer(ast) &#123; // 创建 `newAST`，它与之前的 AST 类似，Program：新AST的根节点 let newAst = &#123; type: 'Program', body: [], &#125;; // 通过 _context 维护新旧 AST，注意 _context 是一个引用，从旧的 AST 到新的 AST。 ast._context = newAst.body; // 通过遍历器遍历 参数：AST 和 visitor traverser(ast, &#123; // 数值，直接原样插入新AST NumberLiteral: &#123; enter(node, parent) &#123; parent._context.push(&#123; type: 'NumberLiteral', value: node.value, &#125;); &#125;, &#125;, // 字符串，直接原样插入新AST StringLiteral: &#123; enter(node, parent) &#123; parent._context.push(&#123; type: 'StringLiteral', value: node.value, &#125;); &#125;, &#125;, // 函数调用 CallExpression: &#123; enter(node, parent) &#123; // 创建不同的AST节点 let expression = &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: node.name, &#125;, arguments: [], &#125;; // 函数调用有子类，建立节点对应关系，供子节点使用 node._context = expression.arguments; // 顶层函数调用算是语句，包装成特殊的AST节点 if (parent.type !== 'CallExpression') &#123; expression = &#123; type: 'ExpressionStatement', expression: expression, &#125;; &#125; parent._context.push(expression); &#125;, &#125; &#125;); // 最后返回新 AST return newAst;&#125; 这里通过 _context 引用维护新旧 AST，简单方便，但会污染旧AST。 代码生成1234567891011121314151617181920212223242526272829303132333435363738394041// 代码生成器 参数：新 ASTfunction codeGenerator(node) &#123; switch (node.type) &#123; // 遍历 body 属性中的节点，且递归调用 codeGenerator，结果按行输出 case 'Program': return node.body.map(codeGenerator) .join('\n'); // 表达式，处理表达式内容，并用分号结尾 case 'ExpressionStatement': return ( codeGenerator(node.expression) + ';' ); // 函数调用，添加左右括号，参数用逗号隔开 case 'CallExpression': return ( codeGenerator(node.callee) + '(' + node.arguments.map(codeGenerator) .join(', ') + ')' ); // 标识符，数值，原样输出 case 'Identifier': return node.name; case 'NumberLiteral': return node.value; // 字符串，用双引号包起来再输出 case 'StringLiteral': return '"' + node.value + '"'; // 无法识别的字符，抛出错误提示 default: throw new TypeError(node.type); &#125;&#125; 根据转换后的新AST生成目标代码字符串。 编译器12345678function compiler(input) &#123; let tokens = tokenizer(input); let ast = parser(tokens); let newAst = transformer(ast); let output = codeGenerator(newAst); return output;&#125; 编译器整个工作流程：1、input =&gt; tokenizer =&gt; tokens2、tokens =&gt; parser =&gt; ast3、ast =&gt; transformer =&gt; newAst4、newAst =&gt; generator =&gt; output将上面流程串起来，就构成了简单的编译器。]]></content>
      <categories>
        <category>the-super-tiny-compiler</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-thunk 源码全方位剖析]]></title>
    <url>%2F2018%2F09%2F09%2Fredux-thunk-source-analysis.html</url>
    <content type="text"><![CDATA[前言redux 的核心概念很简单：将需要修改的 state 都储存在 store 里，发起一个 action 用来描述发生了什么，用 reducers 描述 action 如何改变 state tree，创建 store 的时候需要传入 reducer，真正能改变 store 中数据的是 API store.dispatch。纯粹使用 redux 时，我们需要 dispatch 的是一个 action 对象。当我们使用 redux-thunk 后，我们 dispatch 的是一个 function，redux-thunk 中间件会自动调用这个 function，并且传递 dispatch 方法作为其第一个参数，于是我们就能在这个 function 内根据我们的请求状态：开始，请求中，请求成功／失败，dispatch 我们期望的任何 action 了，这也是为什么它能支持异步 dispatch action，自然的请求的逻辑就需要放到这里面调用了。换言之，redux-thunk 改写了 dispatch API，使其具备接受一个函数作为参数的能力，从而达到 middleware 的效果，即在 redux 的 dispatch action =&gt; reducer =&gt; store 这个流程中，在 action 被发起之后，到达 reducer 之前的扩展点，加入相关操作，比如发生请求、log信息等。一句话：redux-thunk 就是对 store.dispatch() 的增强。 示例以动态收藏功能为例:纯粹使用 redux：12345678// action.jsconst addFavor = (id) =&gt; (&#123; type: 'FAVOR', id:id&#125;)// componentfetchFavor(&#123;id: id&#125;).then(res =&gt; &#123; dispatch(addFavor(id)) &#125;) 可以看到，我们在请求以后的回调函数中 dispatch action 去同步 redux store 中的状态。 使用 redux-thunk：1234567891011121314151617181920212223242526// store.jsimport &#123;createStore, combineReducers, applyMiddleware&#125; from 'redux';import * as reducers from './reducers';import thunk from 'redux-thunk';var store = createStore( combineReducers(reducers), applyMiddleware(thunk));export default store;// action.jsconst addFavor = (id) =&gt; &#123; return function (dispatch, getState) &#123; reqFavor(&#123;id: id&#125;).then(res =&gt; &#123; dispatch(&#123; type: "FAVOR", id:id &#125;) &#125;) &#125;&#125;// componentdispatch(addFavor(id)) 改变以后，从功能层面上来说，两者并无差别，都可以满足业务场景需求。但除此之外我们可以发现:一：dispatch 接受的参数由一个 PlainObject 变为一个函数二：我们把请求的异步操作从 dispatch action 这个 redux 流程外塞到的流程里，这看起来将异步操作内聚到这个流程中，无论是从逻辑上理解（这很 middleware！）还是项目代码开发维护（区分异步与同步状态管理流程进行维护管理）上都是很大的改进三：如果项目中有多处需要实现收藏功能，我们可以节省很多冗余代码，不用到处在 dispatch 外层套上 reqLike(id).then。。。 直接将 thunk 中间件引入，作为 applyMiddleware 参数，然后传入 createStore 方法，就完成了 store.dispatch() 的功能增强，这样就可以进行一些异步的操作了。其中 applyMiddleware 是 Redux 的一个原生方法，将所有中间件组成一个数组，依次执行，中间件多了可以当做参数依次传进去。1234const store = createStore( reducers, applyMiddleware(thunk, logger)); 源码了解了 redux-thunk 的基本概念以及应用后，我们一起看看源码加深下理解，源码十分精巧。在了解 redux-thunk 源码之前，我们很有必要先看看 redux 源码中 applyMiddleware 的部分：1234567891011121314151617181920212223export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 我们将 thunk 作为参数传入之后，直接返回了一个函数，这个函数作为 enhancer 传入 redux 源码中的 createStore 函数中：1234567891011121314export default function createStore(reducer, preloadedState, enhancer) &#123; if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125;&#125; 在 redux 源码中的 createStore 函数中，enhancer 被执行，传入参数 createStore，又紧接着执行其返回的函数，传入 reducer 和 preloadedState。接下来，我们进入 applyMiddleware 和 thunk 的关键部分，上面 applyMiddleware 接受的最初的 (…middlewares) 参数其实就是 thunk，thunk 会被执行，并且传入参数 getState 和 dispatch：123456789//传入到 thunk 的参数const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action)&#125;//在 map 中执行 thunkchain = middlewares.map(middleware =&gt; middleware(middlewareAPI))//重新改写 dispatchdispatch = compose(...chain)(store.dispatch) 那么上面的chain是什么呢，我们现在就可以去看 redux-thunk 的源码了：1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; redux-thunk 中间件 export default 的就是 createThunkMiddleware() 过的 thunk，再看 createThunkMiddleware 这个函数，返回的是一个柯里化过的函数。我们将上述代码编译成ES5的代码看一看：123456789101112131415function createThunkMiddleware(extraArgument) &#123; return function(&#123; dispatch, getState &#125;) &#123; // 这里返回的函数就是chain return function(next) &#123; // 这里返回的函数就是改写的dispatch return function(action) &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;; &#125; &#125;&#125; 从源码我们可以看出，chain 就是以 next 作为形参的匿名函数，至于 compose 只是不断传递每个函数的返回值给下一个执行函数，然后依次去执行它所有传入的函数而已，它源码中的注释说的很清楚：For example, compose(f, g, h) is identical to doing (...args) =&gt; f(g(h(...args)))。我们这里的 chain 只是一个函数而已，所以很简单，就是执行 chain，并且传入 store.dispatch 作为 next 就行。 接下来，进入最后一步，改写了 dispatch，最终变为:1234567function (action) &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; // next为之前传入的store.dispatch,即改写前的dispatch return next(action);&#125;; 如果传入的参数是函数，则执行函数，否则还是跟之前一样 dispatch(PlainObject)。 总结redux-thunk 实现了相关异步流程内聚到 redux 的流程中，实现 middleware 的功能，也便于项目的开发与维护，避免冗余代码。而实现的方式便是改写 redux 中的 dispatch API，使其可以除 PlainObject 外，接受一个函数作为参数。]]></content>
      <categories>
        <category>redux-thunk</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端加密JS库--CryptoJS 使用指南]]></title>
    <url>%2F2018%2F09%2F05%2Fcryptojs-tutorial.html</url>
    <content type="text"><![CDATA[有时候项目涉及到的敏感数据比较多，为了信息安全，我们常常需要对一些数据进行接口加密处理，如编码、将明文转化为暗文、加密比对、AES + BASE64 算法加密等。接下来我们就分别说一下 CryptoJS 常用的一些方法。 CryptoJS文档 Base64 编码为什么要编码？ 由于一些网络通讯协议的限制, 又或者是出于信息加密的目的, 我们就需要将原信息转换为base64编码,然后才能进行传输.例如，发送某些含有 ASCII 码表中0到31之间的控制字符的数据。 window.btoa 对字符串进行 base64编码（注意不能编码中文）;winodw.atob 对 base64字符串 进行解码（对于包含中文的 base64编码，不能正确解码）; 通常的方法是通过 window.btoa() 方法对源数据进行编码, 然后接收方使用 window.atob() 方法对其进行解码, 从而得到原数据。但是这种方法存在的问题是：window.btoa() 不支持中文, window.atob() 转换含有中文的 base64编码 的时候中文部分会变为乱码。另一个存在的问题是解码github的readme数据的时候也是乱码。经过查找相关资料发现了 Base64的编码与解码转的最优方案: 12345678910111213141516171819202122// 编码function utf8_to_b64(str) &#123; return window.btoa(unescape(encodeURIComponent(str)));&#125;// 解码function b64_to_utf8(str) &#123; return decodeURIComponent(escape(window.atob(str)));&#125;// Usage:utf8_to_b64('✓ à la mode'); // 4pyTIMOgIGxhIG1vZGU=b64_to_utf8('4pyTIMOgIGxhIG1vZGU='); // "✓ à la mode"utf8_to_b64('I \u2661 Unicode!'); // SSDimaEgVW5pY29kZSE=b64_to_utf8('SSDimaEgVW5pY29kZSE='); // "I ♡ Unicode!"utf8_to_b64('我爱中国'); // 5oiR54ix5Lit5Zu9b64_to_utf8('SSDimaEgVW5pY29kZSE='); // "我爱中国"utf8_to_b64(123456); // MTIzNDU2b64_to_utf8("MTIzNDU2"); // 123456 AES 加密安装 1$ npm install crypto-js aes加密: crypto.js1234567891011121314151617181920212223242526272829303132333435363738394041import CryptoJS from "crypto-js";const key = CryptoJS.enc.Utf8.parse("1234567890000000"); //16位const iv = CryptoJS.enc.Utf8.parse("1234567890000000");export default &#123; //aes加密 encrypt(word) &#123; let encrypted = ""; if (typeof word == "string") &#123; const srcs = CryptoJS.enc.Utf8.parse(word); encrypted = CryptoJS.AES.encrypt(srcs, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); &#125; else if (typeof word == "object") &#123; //对象格式的转成json字符串 const data = JSON.stringify(word); const srcs = CryptoJS.enc.Utf8.parse(data); encrypted = CryptoJS.AES.encrypt(srcs, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); &#125; return encrypted.ciphertext.toString(); &#125;, // aes解密 decrypt(word) &#123; const encryptedHexStr = CryptoJS.enc.Hex.parse(word); const srcs = CryptoJS.enc.Base64.stringify(encryptedHexStr); const decrypt = CryptoJS.AES.decrypt(srcs, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); const decryptedStr = decrypt.toString(CryptoJS.enc.Utf8); return decryptedStr.toString(); &#125;&#125;; 使用12345678910111213import Crypto from "@/utils/crypto";Crypto.encrypt("✓ à la mode"); // b915bf40c4795227488da86978f55fceCrypto.decrypt(userPwd); // "✓ à la mode"Crypto.encrypt("✓ à la mode"); // 6317313288b32bf1909f165ec530d60aCrypto.decrypt(userPwd); // "I ♡ Unicode!"Crypto.encrypt("我爱中国"); // 1898a34273855f55255437aa22f87504Crypto.decrypt(userPwd); // "我爱中国"Crypto.encrypt("123456"); // dd7a6c4edc68e683b700a7a2846a2bc6Crypto.decrypt(userPwd); // "123456" 前后端数据通信参数加密加密代码实现: 项目中需要将所有传到后台的参数分5个步骤处理： 第一步：排序 第二步：将排序好的参数进行MD5加密作为接口的签名 第三步：将排序好的参数和接口签名拼接上进行AES加密 第四部：将AES加密后的密文Base64加密 第五步：将最终的密文encodeURIComponent； 代码如下： 1234567891011121314151617function encryption(data) &#123; let strs=[]; for(let i in data)&#123; strs.push(i+'='+data[i]); &#125; strs.sort(); // 数组排序 strs=strs.join('&amp;'); // 数组变字符串 let endData=strs+'&amp;sign='+CryptoJS.MD5(strs+'ADfj3kcadc2349akvm1CPFFCD84f').toString(); // MD5加密 let key = CryptoJS.enc.Utf8.parse("0880076B18D7EE81"); // 加密秘钥 let iv = CryptoJS.enc.Utf8.parse("CB3EC842D7C69578"); // 矢量 let encryptResult = CryptoJS.AES.encrypt(endData,key, &#123; // AES加密 iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 // 后台用的是pad.Pkcs5,前台对应为Pkcs7 &#125;); return encodeURIComponent(CryptoJS.enc.Base64.stringify(encryptResult.ciphertext)); // Base64加密encode;&#125; 加密最终的密文拼接在接口地址后面，请求接口。后台返回的数据也是密文；解密方法如下： 1234567891011121314function decryption(data) &#123; let key = CryptoJS.enc.Utf8.parse("0880076B18D7EE81"); // 加密秘钥 let iv = CryptoJS.enc.Utf8.parse("CB3EC842D7C69578"); // 矢量 let baseResult=CryptoJS.enc.Base64.parse(data); // Base64解密 let ciphertext=CryptoJS.enc.Base64.stringify(baseResult); // Base64解密 let decryptResult = CryptoJS.AES.decrypt(ciphertext,key, &#123; // AES解密 iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); let resData=decryptResult.toString(CryptoJS.enc.Utf8).toString(); return JSON.parse(resData);&#125; 备注：因为后台返回的数据是json格式；所以做种return的时候使用JSON.parse();如果解密的目标为字符串，比如说需要解密的是一个加密的token值。那就要做相应的改动：123456789101112function decryption(data) &#123; let key = CryptoJS.enc.Utf8.parse("0880076B18D7EE81"); // 加密秘钥 let iv = CryptoJS.enc.Utf8.parse("CB3EC842D7C69578"); // 矢量 let baseResult=CryptoJS.enc.Base64.parse(data); // Base64解密 let ciphertext=CryptoJS.enc.Base64.stringify(baseResult); // Base64解密 let decryptResult = CryptoJS.AES.decrypt(ciphertext,key, &#123; // AES解密 iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); return CryptoJS.enc.Utf8.stringify(decryptResult);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>cryptojs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Fire——现代化的React DOM]]></title>
    <url>%2F2018%2F09%2F03%2Freact-fire.html</url>
    <content type="text"><![CDATA[昨天，React 开发者、Redux 和 Create React App 作者之一的 Dan Abramov gaearon 在 GitHub 上的 React issue 上宣布了一个名为 React Fire 的规划，他表示这个项目旨在使 React DOM 更现代化，目标是让 React 可以更好地与 DOM 的工作方式保持一致，React 团队会重新审视之前做出的一些有争议的决策，并让 React 变得更小更快。 他表示，今年以来，React团队的主要着力点是改进React，目前这项工作已经接近尾声。接下来，他们开始考虑React DOM 的下一个主要版本应该是什么样子的。 由于现在存在相当多的问题，如果不对内部做一些大的更改，有些问题就很难进行修复了，所以他们希望能够弥补过去的错误，这些错误导致了无穷无尽的后续修复和大量的技术债务。他们还希望删除事件系统中的一些代码，这些代码实际上从React的第一天起就一直没有被执行过，它们也是造成复杂性和臃肿的库文件的罪恶之源。他们把这项任务称为“React Fire”。 React FireReact Fire是React DOM的现代化版本。我们的目标是使React更好地与DOM的工作方式保持一致，重新考虑过去导致问题的一些有争议的决策，并使React更小、更快。 我们希望在将来的React major版本中发布这组更改，因为有些更改是不向前兼容的。但即便是这样，我们认为这些代价也是值得的。我们在Facebook上有超过5万个组件来检验我们的迁移策略。除了一些有针对性的修复或自动化的代码之外，我们不能重写产品代码。 React Fire 的具体规划React 团队可能会在当前的计划中添加或删除一些内容，但总体是这样考虑的： 停止在 value 属性上反映输入值：这个特性最初是在 React 15.2.0 中添加的。这是一个非常普遍的需求，因为人们对 DOM 模型的理解就是在 DOM 检查器中看到的 value 应该与值 JSX 的 value 属性相匹配。但 DOM 其实不是这样的，在输入字段时，浏览器并不会更新 value 属性，所以 React 也不应该这样做。事实证明，这个变化虽然可能对依赖 CSS 选择器的一些代码有点用处，但却导致了一系列错误——其中一些仍未得到修复。从这一点上说，显然不值得继续与浏览器作斗争，所以应该回退。 将事件附加到 React root，而不是 document：在将 React 应用程序嵌入到更大的系统时，将事件处理器附加到 document 会成为一个问题。Atom 编辑器是最早遇到这种情况的案例之一。大型网站通常会出现非常复杂的边缘案例，通过 stopPropagation 与非 React 代码发生交互或进行跨 React root 交互。他们还希望能够尽早将事件附加到每个 root，这样就可以在更新期间减少运行时检查。 从 onChange 切换到 onInput，并且不需要为不受控组件进行 polyfill：React 在 DOM 中使用了一个不同的事件名来表示 input 事件，这无疑让人感到有些困惑。虽然通常应该避免在没有得到显著好处的情况下做出这样的大变更，但我们还是希望能够因此消除一些复杂性。因此，将这两个变更结合在一起是有意义的，并借此机会让 onInput 和 onChange 与 DOM 事件在不受控组件上的行为保持一致。 大幅简化事件系统：当前的事件系统自 2013 年初始实现以来，几乎没有发生任何变化。它在 React DOM 和 React Native 中被重复使用，因此它没有必要是抽象的。它提供的很多 polyfill 对于现代浏览器来说是不必要的，并且其中一些产生的问题比它们解决的问题还要多。它也占了 React DOM 包大小的很大一部分。Dan 表示，现在还没有非常具体的计划，但有可能会完全将事件系统 fork 出去。完全摆脱合成事件似乎是合理的，我们应该停止使用冒泡事件（比如媒体事件，它们不会在 DOM 中冒泡，而且也没有充分的理由进行冒泡）。React 团队希望保留一些特定于 React 的功能，例如跨门户的冒泡，但他们将尝试通过更简单的方法（例如重新分配事件）来实现。 className 改为 class：这个提案已经被提了无数次了。在 React 16 中， 允许将 class 传给 DOM 节点。但避免语法限制所带来的好处无法抵消它所造成的混乱，他们不会单独做出这个变更，需要与上述的结合在一起才有意义。不能在没有给出警告的前提下让二者同时存在，因为组件生态系统很难处理好它们。每个组件都需要学会如何正确处理它们，还要冒着出现冲突的风险。 权衡利弊Dan 表示，如果继续为 React Native Web 等项目公开当前的私有 React 事件系统 API，他们就无法做出这些变更。不过，React Native Web 需要一个不同的策略，因为 React Fabric 可能会将更多的响应者系统移到 Native 端。 所以，React 团队可能需要放弃与某些旧版浏览器的兼容性，或者需要提供更多独立的 polyfill。不过，他们仍希望能够支持 IE11，但可能不会试图消除现有浏览器的一些差异——这也是很多现代 UI 库所采取的立场。 未来计划在这个阶段，这个项目非常具有探索性。他们不确定上述的所有事情是否能够奏效。他们会在 Facebook 内部进行实验，并以渐进的方式逐步实现。可能还需要引入一个功能标志，fork 出一些代码，并让 Facebook 的一小部分人先试用新功能。16.x 开源版本将保留旧有的行为，但在 master 上，可以通过功能标志开启新功能。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React Fire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 背后的工具体系]]></title>
    <url>%2F2018%2F08%2F30%2Freact-source-tools.html</url>
    <content type="text"><![CDATA[北京时间2017年9月27日，Facebook 官方发布了 React v16.0。相较于之前的 v15.x 版本，v16 发生了很大的变化。 React v16.0 API 变化1.render 函数支持返回数组和字符串：我们终于不需要再将多个同级元素包裹在一个冗余的 DOM 元素中了，但每个同级元素还是需要唯一的 key 值以便 React 进行更新，而且在未来版本，React 可能还会提供一个特殊的 jsx 片段来支持无 key 值的 DOM 元素。 2.更好的异常处理：在之前版本的 React 中，某个组件在 Render 阶段的运行错误可能会 break 掉整个应用，而且抛出的异常信息含义也非常模糊，难以确定错误的发生位置。在 v16.0 中，如果某个组件在执行 render 或其他生命周期函数时出错，整个组件将被从根节点上移除掉，方便开发者快速定位异常组件。在定位到异常组件后，开发者可以为该组件添加 componentDidCatch 方法，并在这个方法中为组件定义一个备用视图用于渲染异常状态下的组件。当然，在这个新的生命周期函数中，开发者也可以获得更加有帮助的错误信息进行 debug。这被称作组件的错误边界，大家可以理解为组件层面的 try catch 声明。 3.新的组件类型 portals：ReactDOM.createPortal(child, container) 可以将子组件直接渲染到当前容器组件 DOM 结构之外的任意 DOM 节点中，这将使得开发对话框，浮层，提示信息等需要打破当前 DOM 结构的组件更为方便。 4.更好的服务端渲染：与之前 renderToString 方法不同，新版本提供的 renderToNodeStream 将返回 Readable，可以持续产生字节流（a stream of bytes）并在下一部分的 document 生成之前将之前已生成的部分 document 传回给客户端。通常来讲，新的服务端渲染将比老的快3倍以上。在 document 到达客户端之后，新版本的 react 也将不会再去将客户端的初次渲染结果与服务端的渲染结果进行比较，而是尽可能地去重用相同的 DOM 元素。 5.支持自定义 DOM 元素：新版本将不会再抛出不支持的 DOM 元素错误，而是将所有开发者自定义的 DOM 元素都传递到相应的 DOM 节点上。 6.更小的打包大小：总体体积减少 30% react is 5.3 kb (2.2 kb gzipped), 老版本 20.7 kb (6.9 kb gzipped)react-dom is 103.7 kb (32.6 kb gzipped), 老版本 141 kb (42.9 kb gzipped)react + react-dom is 109 kb (34.8 kb gzipped), 老版本 161.7 kb (49.8 kb gzipped) 7.MIT 许可：除了最新的 16.0 版本外，Facebook 还发布了使用 MIT 许可的 15.6.2 版本，以方便无法立刻升级的使用者。 8.新的核心架构 Fiber：React v16.0 使用了 Fiber 作为底层架构。正是得益于 Fiber，返回数组和字符串及错误边界等功能才变得可能。Fiber 相较于之前最大的不同是它支持异步渲染（async rendering），这意味着 React 可以在更细的粒度上控制组件的绘制过程，从最终的用户体验来讲，用户可以体验到更流畅交互及动画体验。而因为异步渲染涉及到 React 的方方面面甚至未来，在 16.0 版本中 React 还暂时没有启用，并将在未来几个月陆续推出。 其实，以上种种变化都离不开背后构建工具的变化。 React 构建工具1234567891011# 开发工具ES Module, Flow, ESLint, Prettier, Yarn workspace, HUBOT(GitHub Bot), [x]Haste, [x]CommonJS Module# 构建工具Rollup, Closure Compiler, Error Code System, React DevTools, [x]Gulp/Grunt+Browserify# 测试工具Jest, Prettier# 发布工具npm 以上前面带[x]的表示之前在用，React v16.0 已不再使用。简单说一下上面的工具都有什么作用？ 开发时，按照 ES Module 机制编写源码，用 flow 进行类型检查、ESLint 语法规则和代码风格的检查、Prettier 来统一代码风格，借助 Yarn workspace 处理模块依赖，HUBOT(GitHub Bot) 检查PR； 开发过程中，用 Jest 单元测试，Prettier 来统一代码风格 开发完成，用 Rollup + Closure Compiler 构建，利用 Error Code System 机制实现生产环境错误追踪，React DevTools 侧面辅助 bundle 检查； 最后通过 npm 发布新 package。 开发工具ES ModuleReact 16 之前的版本都用 CommonJS Module 定义，例如：123'use strict';module.exports = require('./lib/React'); React 16 为什么选择使用 ES Module，有以下几个原因： 1.编译期发现模块导入/导出问题：我们都知道使用 CommonJS Module 的 require 一个未定义的方法时，不调用我们是发现不了错误的。而 ES Module 由于静态的模块机制，import 与 export 必须按名匹配，否则编译构建就会出错。 2.更小的打包大小： 众所周知 module.exports 是对象级别导出，而ES Module 支持更细粒度的原子级导出，我们把这个特性叫做 tree-shaking，这个特性可以帮助你将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。 这里只是把源码切换到了 ES Module，单元测试用例并未切换，主要原因是 CommonJS Module 对 Jest 的一些特性（resetModules）更友好，即便切换到 ES Module，在需要模块状态隔离的场景，仍然要用 require，所以切换意义不是很大。 还有 Haste，则是 React 团队自定义的模块处理工具，用来解决长相对路径的问题，例如：123456// ref: react-15.5.4var ReactCurrentOwner = require('ReactCurrentOwner');var warning = require('warning');var canDefineProperty = require('canDefineProperty');var hasOwnProperty = Object.prototype.hasOwnProperty;var REACT_ELEMENT_TYPE = require('ReactElementSymbol'); Haste 模块机制下模块引用不需要给出明确的相对路径，而是通过项目级唯一的模块名来自动查找，例如：1234567// 声明/** * @providesModule ReactClass */// 引用var ReactClass = require('ReactClass'); 从表面上解决了长路径引用的问题（并没有解决项目结构深层嵌套的根本问题），使用非标准模块机制有几个典型的坏处： 1.与标准不和，接入标准生态中的工具时会面临适配问题 2.源码难读，不容易弄明白模块依赖关系 React 16 去掉了大部分自定义的模块机制（ReactNative 里还有一小部分），采用 Node 标准的相对路径引用，长路径的问题通过重构项目结构来彻底解决，采用扁平化目录结构（同 package 下最深2级引用，跨 package 的经 Yarn 处理以顶层绝对路径引用） Flow + ESLintFlow 是 facebook 出品的 JavaScript 静态类型检查工具，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。我们看一下 React 使用实例： 12345678910111213141516export type ReactElement = &#123; $$typeof: any, type: any, key: any, ref: any, props: any, _owner: any, // ReactInstance or ReactFiber // __DEV__ _store: &#123; validated: boolean, &#125;, _self: React$Element&lt;any&gt;, _shadowChildren: any, _source: Source,&#125;; 除了静态类型声明及检查外，Flow 最大的特点是对React组件及JSX的深度支持：123456789101112131415type Props = &#123; foo: number,&#125;;type State = &#123; bar: number,&#125;;class MyComponent extends React.Component&lt;Props, State&gt; &#123; state = &#123; bar: 42, &#125;; render() &#123; return this.props.foo + this.state.bar; &#125;&#125; 另外还有导出类型检查的 Flow “魔法”，用来校验 mock 模块的导出类型是否与源模块一致：12type Check&lt;_X, Y: _X, X: Y = _X&gt; = null;(null: Check&lt;FeatureFlagsShimType, FeatureFlagsType&gt;); Eslint 解决了代码格式检查的问题，同时，一些有用的提示能让我们发现 bug 和无用代码（如 no-unused-vars, no-extra-bind, no-implicit-globals），例如： 12345678rules: &#123; 'no-unused-expressions': ERROR, 'no-unused-vars': [ERROR, &#123;args: 'none'&#125;], // React &amp; JSX // Our transforms set this automatically 'react/jsx-boolean-value': [ERROR, 'always'], 'react/jsx-no-undef': ERROR,&#125; PrettierPrettier 可以制定想要的代码风格，然后通过脚本或编辑器插件来一键格式化/美化代码，我发现使用 Prettier 有很多益处： 1.代码格式化成统一风格 2.提交之前对有改动的部分进行格式化，也可以保存文件的时候自动统一风格。 3.配合持续集成，保证PR代码风格完全一致（否则build失败，并输出风格存在差异的部分） 4.对构建结果进行格式化，一方面提升dev bundle可读性，另外还有助于发现prod bundle中的冗余代码 5.开源代码开发者不需要去学习项目的代码风格。 Yarn workspaceYarn 的 workspace 特性用来解决 monorepo 的 package 依赖（作用类似于 lerna bootstrap），通过在 node_modules 下建立软链接“骗过”Node模块机制。 通过 package.json/workspaces 配置 Yarn workspaces： 1234567&#123; // ... "workspaces": [ "packages/*" ], // ...&#125; 注意：Yarn 的实际处理与 Lerna 类似，都通过软链接来实现，只是在包管理器这一层提供 monorepo package 支持更合理一些，具体原因见Workspaces in Yarn | Yarn Blog 1234import &#123;enableUserTimingAPI&#125; from 'shared/ReactFeatureFlags';import getComponentName from 'shared/getComponentName';import invariant from 'fbjs/lib/invariant';import warning from 'fbjs/lib/warning'; 另外，Yarn 与 Lerna 可以无缝结合，通过 useWorkspaces 选项把依赖处理部分交由 Yarn 来做，详细见Integrating with Lerna HUBOTHUBOT 是指 Github 机器人，通常用于： 1. 持续集成、PR 触发构建/检查2. 管理 Issue，关掉不活跃的讨论帖 主要围绕 PR 与 Issue 做一些自动化的事情，比如 React 团队计划（目前还没这么做）机器人回复 PR 对 bundle size 的影响，以此督促持续优化 bundle size。 目前每次构建把 bundle size 变化输出到文件，并交由 Git 追踪变化（提交上去），例如： 123456789101112131415161718&#123; "bundleSizes": [ &#123; "filename": "react.development.js", "bundleType": "UMD_DEV", "packageName": "react", "size": 59086, "gzip": 16296 &#125;, &#123; "filename": "react.production.min.js", "bundleType": "UMD_PROD", "packageName": "react", "size": 7217, "gzip": 3050 &#125;, // ...&#125; 缺点可想而知，这个json文件经常冲突，要么需要浪费精力 merge 冲突，要么就懒得提交这个自动生成的麻烦文件，导致版本滞后，所以计划通过 GitHub Bot 把这个麻烦抽离出去。 构建工具bundle形式React16 之前提供了两种 bundle 形式： 第一种：UMD 单文件，用作外部依赖。 第二种：CJS 散文件，用于支持自行构建 bundle（把 React 作为源码依赖）。 存在一些问题： 一：自行构建的版本不一致：不同的 build 环境/配置构建出的 bundle 都不一样。 二：bundle 性能有优化空间：用打包 App 的方式构建类库不太合适，性能上有提升余地 三：不利于实验性优化尝试：无法对散文件模块应用打包、压缩等优化手段 React 16 调整了 bundle 形式： 一：不再提供 CJS 散文件，从 npm 拿到的就是构建好的，统一优化过的 bundle。 二：提供 UMD 单文件与 CJS 单文件，分别用于 Web 环境与 Node 环境（SSR）。 以不可再分的类库姿态，把优化环节都收进来，摆脱 bundle 形式带来的限制。 Rollup之前的构建系统是基于 Gulp/Grunt+Browserify 手搓的一套工具，后来在扩展方面受限于工具，例如： Node 环境下性能不好：频繁的 process.env.NODE_ENV 访问拖慢了 SSR 性能，但又没办法从类库角度解决，因为 Uglify 依靠这个去除无用代码，所以 React SSR 性能最佳实践一般都有一条“重新打包 React，在构建时去掉 process.env.NODE_ENV”（当然，React 16 不需要再这样做了，原因见上面提到的bundle形式变化） 丢弃了过于复杂（overly-complicated）的自定义构建工具，改用更合适的 Rollup： It solves one problem well: how to combine multiple modules into a flat file with minimal junk code in between. 无论 Haste -&gt; ES Module 还是 Gulp/Grunt+Browserify -&gt; Rollup 的切换都是从非标准的定制化方案切换到标准的开放的方案，应该在“手搓”方面吸取教训，为什么业界规范的东西在我们的场景不适用，非要自己造吗？ mock module构建时可能面临动态依赖的场景：不同的 bundle 依赖功能相似但实现存在差异的 module，例如 ReactNative 的错误提醒机制是显示个红框，而 Web 环境就是输出到 Console。 一般解法有2种： 第一种：运行时动态依赖（注入）：把两份都放进bundle，运行时根据配置或环境选择。 第二种：构建时处理依赖：多构建几份，不同的bundle含有各自需要的依赖模块。 显然构建时处理更干净一些，即 mock module，开发中不用关心这种差异，构建时根据环境自动选择具体依赖，通过手写简单的 Rollup 插件来实现：动态依赖配置 + 构建时依赖替换。 Closure Compilergoogle/closure-compiler是个非常强大的 minifier，有3种优化模式（compilation_level）： 第一种：WHITESPACE_ONLY：去除注释，多余的标点符号和空白字符，逻辑功能上与源码完全等价。 第二种：SIMPLE_OPTIMIZATIONS：默认模式，在 WHITESPACE_ONLY 的基础上进一步缩短变量名（局部变量和函数形参），逻辑功能基本等价，特殊情况（如 eval(‘localVar’)按名访问局部变量和解析 fn.toString() ）除外 第三种：ADVANCED_OPTIMIZATIONS：在 SIMPLE_OPTIMIZATIONS 的基础上进行更强力的重命名（全局变量名，函数名和属性），去除无用代码（走不到的，用不着的），内联方法调用和常量（划算的话，把函数调用换成函数体内容，常量换成其值） 关于compilation_level的详细信息见Closure Compiler Compilation Levels ADVANCED 模式过于强大：12345678// 输入function hello(name) &#123; alert('Hello, ' + name);&#125;hello('New user');// 输出alert("Hello, New user"); 也可以在Closure Compiler Service在线试玩。 迁移切换有一定风险，因此 React 用的还是 SIMPLE 模式，但后续可能有计划开启 ADVANCED 模式，充分利用 Closure Compiler 优化 bundle size。 Error Code System In order to make debugging in production easier, we’re introducing an Error Code System in 15.2.0. We developed a gulp script that collects all of our invariant error messages and folds them to a JSON file, and at build-time Babel uses the JSON to rewrite our invariant calls in production to reference the corresponding error IDs. 简言之，在 prod bundle 中把详细的报错信息替换成对应错误码，生产环境捕获到运行时错误就把错误码与上下文信息抛出来，再丢给错误码转换服务还原出完整错误信息。这样既保证了 prod bundle 尽量干净，还保留了与开发环境一样的详细报错能力。 例如生产环境下的非法 React Element 报错： Minified React error #109; visit https://reactjs.org/docs/error-decoder.html?invariant=109&amp;args[]=Foo for the full message or use the non-minified dev environment for full errors and additional helpful warnings. 很有意思的技巧，确实在提升开发体验上花了不少心思。 envification所谓 envification 就是分环境 build，例如：123456// ref: react-16.2.0/build/packages/react/index.jsif (process.env.NODE_ENV === 'production') &#123; module.exports = require('./cjs/react.production.min.js');&#125; else &#123; module.exports = require('./cjs/react.development.js');&#125; 常用手段，构建时把 process.env.NODE_ENV 替换成目标环境对应的字符串常量，在后续构建过程中（打包工具/压缩工具）会把多余代码剔除掉。 除了 package 入口文件外，还在里面做了同样的判断作为双保险：123456// ref: react-16.2.0/build/packages/react/cjs/react.development.jsif (process.env.NODE_ENV !== "production") &#123; (function() &#123; module.exports = react; &#125;)();&#125; 此外，还担心开发者误用 dev bundle 上线，所以在 React DevTools 也加了一点提醒： This page is using the development build of React. DCE checkDCE(dead code eliminated) check 是指检查无用代码是否被正常去除。 考虑了一种特殊情况：process.env.NODE_ENV 如果是在运行时设置的话也不合理（可能存在另一环境的多余代码），所以还通过 React DevTools 做了 bundle 环境检查： 123456789101112131415161718192021222324252627282930313233// ref: react-16.2.0/packages/react-dom/npm/index.jsfunction checkDCE() &#123; if (process.env.NODE_ENV !== 'production') &#123; throw new Error('^_^'); &#125; try &#123; __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE); &#125; catch (err) &#123; console.error(err); &#125;&#125;if (process.env.NODE_ENV === 'production') &#123; checkDCE();&#125;// DevTools 即__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE声明checkDCE: function(fn) &#123; try &#123; var toString = Function.prototype.toString; var code = toString.call(fn); if (code.indexOf('^_^') &gt; -1) &#123; hasDetectedBadDCE = true; setTimeout(function() &#123; throw new Error( 'React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://fb.me/react-perf-use-the-production-build' ); &#125;); &#125; &#125; catch (err) &#123; &#125;&#125; 原理类似于 Redux 的 minified 检测，先声明一个含有 dev 环境判断的方法，在判断中包含一个标识字符串，然后运行时（通过 DevTools ）检查 fn.toString() 源码，如果含有该标识字符串就说明 DCE 失败（无用代码没在 build 过程中去除），异步 throw 出来。 关于 DCE check 的详细信息，可以参考Detecting Misconfigured Dead Code Elimination 测试工具JestJest 是由 Facebook 发布的开源的、基于Jasmine的 JavaScript 单元测试框架。 为什么选择Jest？ 第一点：Jest 可以利用其特有的快照测试功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。 第二点：安装配置简单，非常容易上手，几乎是零配置的，通过 npm 命令安装就可以直接运行了。 第三点：Jest 内置了测试覆盖率工具 istanbul，可以通过命令开启或者在 package.json 文件进行更详细的配置。运行 istanbul 除了会再终端展示测试覆盖率情况，还会在项目下生产一个 coverage 目录，内附一个测试覆盖率的报告，让我们可以清晰看到分支的代码的测试情况。 第四点：集成了断言库，不需要再引入第三方的断言库，并且非常完美的支持 React 组件化测试。 Snapshot Testing 与 UI 自动化测试的一般做法类似，对正确结果截屏作为基准（这个基准需要持续更新，所以快照文件一般随源码提交上去），后续每次改动后与之前的截图做像素级对比，存在差异则说明有问题。 另外，提到 React App 测试，还有一个更狠的：Enzyme，可以采用Jest + Enzyme对React组件进行深度测试，更多信息请查看Unit Testing React Components: Jest or Enzyme? 关于前端UI自动化测试的一般方法，可参考如何进行前端自动化测试？ – 张云龙的回答 – 知乎，当然也可以在repl.it – try-jest by @amasad在线试玩。 preventing Infinite Loops即死循环检查，Facebook 团队不希望测试过程被死循环阻塞（React 16 递归改循环之后有很多while (true)，他们不太放心）。处理方式与死递归检查类似：限制最大深度（TTL）。通过 Babel 插件来做，在测试环境构建时注入检查： 12345678910111213141516// ref: https://github.com/facebook/react/blob/master/scripts/jest/preprocessor.js#L38require.resolve('../babel/transform-prevent-infinite-loops'),// ref: https://github.com/facebook/react/blob/master/scripts/babel/transform-prevent-infinite-loops.js#L37'WhileStatement|ForStatement|DoWhileStatement': (path, file) =&gt; &#123; const guard = buildGuard(&#123; ITERATOR: iterator, MAX_ITERATIONS: t.numericLiteral(MAX_ITERATIONS), &#125;); if (!path.get('body').isBlockStatement()) &#123; const statement = path.get('body').node; path.get('body').replaceWith(t.blockStatement([guard, statement])); &#125; else &#123; path.get('body').unshiftContainer('body', guard); &#125;&#125; 用来防护的 buildGuard 如下： 12345678910const buildGuard = template(` if (ITERATOR++ &gt; MAX_ITERATIONS) &#123; global.infiniteLoopError = new RangeError( 'Potential infinite loop: exceeded ' + MAX_ITERATIONS + ' iterations.' ); throw global.infiniteLoopError; &#125;`); 注意这里使用了一个全局错误变量 global.infiniteLoopError，用来中断后续测试流程：12345678// ref: https://github.com/facebook/react/blob/master/scripts/jest/setupTests.js#L56 env.afterEach(() =&gt; &#123; const error = global.infiniteLoopError; global.infiniteLoopError = null; if (error) &#123; throw error; &#125;&#125;); 在每个 case 结束都看一眼是否发生死循环，防止 guard 中 throw 的错误被外层 catch 住后，测试流程仍然正常进行。 发布工具npm publish为了规范/简化发布流程，Facebook 团队做了以下几件事情： 1.采用 master + feature flag 的分支策略2.统一的工具化发布流程 之前采用 stable 分支策略，发版时需要手动cherry-pick，发个版要花很长时间。后来调整为直接从 master 发布，对于不想要的 breaking change，通过 feature flag 在构建时去掉，免去了手动 cherry-pick 的繁琐。 统一了工具发布流程，自动的按顺序自动执行，人工的就提示保存退出，人工处理完成后恢复之前的进度继续向下执行，大致经过以下流程： 1234567891011121314# 自动$ npm run test$ npm run build# 人工changelog # 更新日志smoke test # 冒烟测试# 自动$ git commit # 提交更新日志$ npm publish # 发布新包# 人工GitHub release # Github 发布update site version # 更新版本test new release # 测试新版notify involved team # 发布通知 这样通过工具化可以减少很多人为失误，保证统一的发布流程。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由 let 和 for 引起的血案]]></title>
    <url>%2F2018%2F08%2F16%2Flet-for-together-used.html</url>
    <content type="text"><![CDATA[这是一道出自 HTTP 203 的 JS 题目。HTTP 203 是 Youtube 上的一个栏目，主要讲一些有趣的知识。 原题目是这样的： 123456789for( let i = (setTimeout(()=&gt;console.log(i), 2333), 0); i &lt; 2; i++) &#123; &#125;// 问 2333 毫秒之后打印出什么 答案是 2333 毫秒后打印出 0。 为什么呢？ 在开始分析题目之前，我们先来回顾几个知识点： for 语法123for (语句 1; 语句 2; 语句 3) &#123; 被执行的代码块&#125; 语句 1（代码块）开始前执行；语句 2 定义运行循环（代码块）的条件；语句 3 在循环（代码块）已被执行之后执行； 执行的顺序为：1.第一次循环，即初始化循环。首先执行语句1（一般为初始化语句），再执行语句2（一般为条件判断语句），判断语句1是否符合语句2的条件，如果符合，则执行代码块，否则，停止执行，最后执行语句3。2.其他循环：首先判断前一次语句3的执行结果是否符合执行语句2的条件，如果符合，继续执行代码块，否则停止执行，最后执行语句3。如此往复，直到前一次语句3的执行结果不满足符合执行语句2的条件。 总的来说，执行顺序是一致的，先执行条件判断（语句2），再执行代码块，最后执行语句3。如此往复，区别在于条件判断的对象，在第一次判断时，是执行语句1，初始化的对象，后续的判断对象是执行语句3的结果。 逗号表达式逗号表达式，因为原题目中就有使用逗号表达式let i = (setTimeout(()=&gt;console.log(i), 2333), 0);。 逗号表达式的一般形式是：表达式1,表达式2,表达式3……表达式n。逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值。 看下面几个例子： 1234567x=8*2, x*4 // 整个表达式的值为64，x的值为16(x=8*2, x*4), x*2 // 整个表达式的值为32，x的值为16x=(z=5, 5*2) // 整个表达式为赋值表达式，它的值为10，z的值为5，x的值为10x=z=5, 5*2 // 整个表达式为逗号表达式，它的值为10，x和z的值都为5 逗号表达式用的地方不太多，一般情况是在给循环变量赋初值时才用得到。所以程序中并不是所有的逗号都要看成逗号运算符，尤其是在函数调用时，各个参数是用逗号隔开的，这时逗号就不是逗号运算符。 基础知识回顾完毕，我们通过几个简单示例一步一步地逼近原题目： 示例一：基础知识 for 循环12345for (var i = 0; i &lt; 2; i++) &#123; console.log(i);&#125;// 打印什么 这个无需多说，答案输出 0 1。 示例二：我们稍微改造下，将 log 放入 setTimeout 中12345for (var i = 0; i &lt; 2; i++) &#123; setTimeout(() =&gt; console.log(i));&#125;// 打印什么 答案输出 2 2。分析下：上述代码中，变量 i 是 var 命令声明的，在全局范围内都有效，所以全局只有一个变量 i。每一次循环，变量 i 的值都会发生改变，而循环内被赋给 setTimeout 内部的 console.log(i)，里面的 i 指向的就是全局的 i。也就是说，这里面所有的 i 指向的都是同一个 i，导致运行时输出的是最后一轮的 i 的值，也就是 2。 示例三：我再稍微改造下，将上述 var 改为 let。12345for (let i = 0; i &lt; 2; i++) &#123; setTimeout(() =&gt; console.log(i));&#125;// 打印什么 答案输出 0 1。分析下：上述代码中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是0 1。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 原题目123456789for( let i = (setTimeout(()=&gt;console.log(i), 2333), 0); // 语句1 i &lt; 2; // 语句2 i++ // 语句3) &#123; &#125;// 问 2333 毫秒之后打印出什么 答案是 2333 毫秒后打印出 0。分析下：上述题目中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，后面的表达式是逗号表达式，取最后一个值，即 i = 0，settimeout 在语句1，由于语句1只在第一次循环执行，因此 settimeout 的作用域是第一次迭代的作用域，且只执行一次。第一次迭代时 i = 0，所以答案是 2333 毫秒后打印出 0。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 表达式后应不应该加分号？]]></title>
    <url>%2F2018%2F08%2F14%2Fjavascript-expression-semicolon.html</url>
    <content type="text"><![CDATA[我们在看源代码时，我们经常会发现有的源代码 Javascript 表达式后面加了分号，有的却没有加，难免心中产生疑惑：Javascript 表达式后面到底该不该加分号呢？ 其实 Javascript 表达式没有应不应该加分号明确规定，全凭个人习惯，也就是说你加也可以不加也不会出错。Javascript 语法长得有点像 C-like， 但不代表它本质上和 C 是一类语言，不过《JavaScript高级程序设计》一书提到：虽然语句结尾的分号不是必须的，但我们建议任何时候都不要省略它。因为加上这个分号可以避免很多错误（例如不完整的输入），开发人员也可以放心地通过删除多余的空格来压缩 ECMAScript 代码（代码行结尾处没有分号会导致压缩错误）。另外，加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必要再花时间推测应该在哪里插入分号。后来新设计的语言里可选分号的多得去了，光是 “可以加分号但是大家都不加” 的语言就有：Go, Scala, Ruby, Python, Swift, Groovy… 至于说“什么时候该加什么时候该不加”，其实真的很简单。真正会导致上下行解析出问题的 token 有 5 个：括号，方括号，正则开头的斜杠，加号，减号。实际代码中用正则、加号、减号作为行首的情况极少，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。其实即使是这两种情况，在实际代码中也颇为少见。 eslint –fix 已经支持自动添加删除分号，另外 prettier 1.0 现在也支持无分号选项，在不同 style 之间迁移的成本已经接近 0 了。 上面提到加上分号会在某些情况下会增进代码的性能。那么问题来了：加或不加分号是否影响JS执行性能？ 我们都清楚无论是解释执行还是编译执行，代码先要被 parse 成 AST（抽象语法树），在 AST 中是没有分号这个东西的，也就是说单纯执行本身，是不可能因为有无分号而造成性能差异的，所以唯一会有差异的是在 parsing 代码的阶段。而 parsing 本身是一次性的，因此通常不可能是性能问题的重点，何况 ASI（自动分号插入）只是整个 parsing 的很小一点。有人实际测试过相同代码在依赖 ASI 或不依赖 ASI 下的性能差异，据说较早版本的 V8 下，依赖 ASI（即不加分号）略慢，但较新版本则反之。也有人认为性能测试结果在统计上没有差异。无论如何，实测结果都表明即使有差异，也小到完全可忽略。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Semicolon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown表格中转义 " | "符号]]></title>
    <url>%2F2018%2F08%2F13%2Fmarkdown-table-transfer.html</url>
    <content type="text"><![CDATA[今天用 markdown 语法写文档时，用到了 table 标签。文档中有一项用到|符号，发现|无法使用反斜杠转义。google一番找到了一个方法：使用ASCII 字符集。举个简单的例子： 姓名 爱好 Weich1 篮球 &#124; 游泳 Weich2 足球 &#124; 音乐 Weich3 爬山 注：「篮球 &amp;#124; 游泳&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;足球 &amp;#124; 音乐」]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 源码全方位剖析]]></title>
    <url>%2F2018%2F08%2F12%2Fvue-source-analysis.html</url>
    <content type="text"><![CDATA[版本：v2.5.17-beta.0 前言随着这几年前端的快速发展，页面中需要实现的功能越来越复杂，DOM操作频繁，使用传统的jQuery库去频繁操作DOM时不仅消耗性能，而且各种DOM绑定后期维护时简直是一场噩梦，在开发大型项目时，模块间的依赖问题也变得十分复杂，在这个大背景下，以数据驱动和组件化思想开发的 Vue、React等JavaScript MVVM库应运而生。相比于其他库，Vue.js 提供了更加简洁、更易于理解的 API，使得我们能够快速上手，一经推出，便迅速走红。现在 Vue.js 更是火得一塌糊涂，github star 数更是超越 React。既然 Vue 如此火，我们是不是很有必要了解一下 Vue.js 背后的实现原理。 目前社区有很多 Vue.js 的源码剖析文章，当下质量比较好的有Vue技术内幕–逐行级别的 Vue 源码分析、Vue.js 技术揭秘，更是得到 Vue 作者本人的推荐。通过通读这两本电子书，我相信大家都能全方位了解 Vue.js 的实现原理。有人可能会有疑问，比如：既然人家写得这么好你为什么还写，直接看人家的不就好了吗，谁会看你的等等？我要说的是源码分析并不是为了彰显个人技术，更多的是为了学习，不管当下想法是否足够成熟，只要我们坚持，我们都会有收获。在开始之前我们先做以下几点约定： 第一：目前分析的版本是 Vue.js 的最新版本 Vue.js 2.5.17-beta.0；第二：Vue web应用是最常见的，也是最易于理解的，所以该源码均围绕 Vue web应用剖析；第三：我尽可能站在我自己的角度去剖析，当然我会借鉴社区比较优秀的文章，面对大家的拍砖，我无条件接受，也很乐意与大家一起交换意见，努力写好该 Vue 源码系列；第四：如果有幸您读到该 Vue 源码系列，感觉写得还行，还望收藏、分享或打赏。 前置知识我们从这一章开始即将分析 Vue 的源码，在分析源码之前我们很有必要介绍一些前置知识如flow、Rollup等。除此之外，我们最好已经用过 Vue 做过实际项目，对 Vue 的思想有了一定的了解，对绝大部分的 API 都已经有使用，同时，我们应该有一定的HTML、CSS、JavaScript、ES6+、node &amp; npm等功底，并对代码调试有一定的了解。 如果具备了以上条件，并且对 Vue 的实现原理很感兴趣，那么就可以开始 Vue 的底层学习了，对它的实现细节一探究竟。 Flow - JavaScript静态类型检查工具Flow 是 facebook 出品的 JavaScript 静态类型检查工具，它与 Typescript 不同的是，它可以部分引入，不需要完全重构整个项目，所以对于一个已有一定规模的项目来说，迁移成本更小，也更加可行。除此之外，Flow 可以提供实时增量的反馈，通过运行 Flow server 不需要在每次更改项目的时候完全从头运行类型检查，提高运行效率。可以简单总结为：对于新项目，可以考虑使用 TypeScript 或者 Flow，对于已有一定规模的项目则建议使用 Flow 进行较小成本的逐步迁移来引入类型检查。Vue 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。 为什么用静态类型检查工具 FlowJavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用就是很容易就写出非常隐蔽的隐患代码，在编译期甚至运行时看上去都不会报错，但是可能会发生各种各样奇怪的和难以解决的bug。 类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。 项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。Vue.js 在做2.0重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，最根本原因作者在知乎提及过，还是在于工程上成本和收益的考量。 大致体现在以下几点： 第一点：使用 Flow 可以一个一个文件地迁移，如果使用 TypeScript，则需要全部替换，成本极高，短期内并不现实；第二点：Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力；第三点：更贴近 ES 规范。除了 Flow 的类型声明之外，其他都是标准的 ES。万一哪天不想用 Flow 了，用babel-plugin-transform-flow-strip-types转一下，就得到符合规范的 ES；第四点：在需要的地方保留 ES 的灵活性，并且对于生成的代码尺寸有更好的控制力 (rollup / 自定义 babel 插件）。 如何用静态类型检查工具 Flow在这里我们就简单说一说 Flow 的用法，其他用法可以参考Flow官网（可能需要 VPN，非常不稳定），有时间我会详细写一篇 Flow 使用指南。 Flow 仅仅是一个用于检查的工具，安装使用都很方便，使用时注意以下3点即可： 1.将 Flow 安装到我们的项目中。2.确保编译之后的代码移除了 Flow 相关的语法。3.在需要检查的地方增加了 Flow 相关的类型注解。 第一点：将Flow增加到我们的项目中 安装最新版本的 Flow：1$ npm install --save-dev flow-bin 安装完成之后在 package.json 文件中增加执行脚本： 12345678&#123; // ... "scripts": &#123; "your-script-name": "flow", // ... &#125;, // ...&#125; 然后初始化 Flow： 1$ npm run flow init 执行完成后，Flow 会在终端输出以下内容： 12&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot; 然后在根目录下生成一个名为 .flowconfig 的文件，打开之后是这样的： 1234567891011[ignore][include][libs][lints][options][strict] 基本上，配置文件没有什么特殊需求是不用去配置的，Flow 默认涵盖了当前目录之后的所有文件。[include] 用于引入项目之外的文件。例如： 12345[include]../otherProject/a.js[libs] 它会将和当前项目平级的 otherProject/a.js 文件纳入进来。详细配置文件请看官网。 第二点：编译之后的代码移除 Flow 相关的语法 Flow 在 JavaScript 语法的基础上使用了一些注解（annotation）进行了扩展。因此浏览器无法正确的解读这些 Flow 相关的语法，我们必须在编译之后的代码中（最终发布的代码）将增加的 Flow 注解移除掉。具体方法需要看我们使用了什么样的编译工具。下面将说明一些 Vue 开发常用的编译工具： 方式一：Babel 如果使用 Babel 我们需要安装一个 Babel 对于 Flow 的 preset：1$ npm install --save-dev babel-preset-flow 然后，我们需要在项目根目录Babel 的配置文件 .babelrc中添加一个 Flow 相关的 preset： 123456&#123; "presets": [ "flow", //other config ]&#125; 方式二：flow-remove-types 如果我们既没有使用 Babel 作为语法糖编译器，那么可以使用 flow-remove-types 这个工具在发布之前移除 Flow 代码。 第三点：在需要检查的地方增加 Flow 相关的类型注解 如果我们了解 C++/C# 的元编程或者 Java 的 Annotation，那么理解 Flow 的 Annotation 就会非常轻松。大概就是在文件、方法、代码块之前增加一个注解（Annotation）用来告知 Flow 的执行行为。 首先，Flow 只检查包含// @flow注解的文件，所以如果需要检查，我们需要这样编写我们的文件，首先我们写一个正确的示例： 1234567/* @flow */function add(x: number, y: number): number &#123; return x + y&#125;add(22, 11) 运行 Flow 终端会打印出以下内容： 1234&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot;Found 0 errors 承接上面代码，我们把代码修改成带有检查错误的例子： 1234567/* @flow */function add(x: number, y: number): number &#123; return x + y&#125;add("Hello", 11) 运行 Flow 终端会打印出以下内容： 12345678910111213141516171819&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot;Error ------------------------------------------------------------------------------------- src/platforms/web/mnr.js:8:5Cannot call `add` with `&quot;Hello&quot;` bound to `x` because string [1] is incompatible with number [2]. src/platforms/web/mnr.js:8:5 8| add(&quot;Hello&quot;, 11) ^^^^^^^ [1]References: src/platforms/web/mnr.js:4:17 4| function add(x: number, y: number): number &#123; ^^^^^^ [2]Found 1 error 到这里，Flow 已经算是安装成功了，接下来的事是要增加各种注解以加强类型限定或者参数检测。之后的内容将简要介绍 flow 的类型检查方式。 Flow 的类型检查方式现在我们就说说 Flow 常用的2种类型检查方式：类型推断：通过变量的执行上下文来推断出变量类型，然后根据这些推断来检查类型。类型注释：事先注释好我们期望的类型，Flow 会基于这些注释来检查。 第一种方式：类型推断 此方式不需要编写任何代码即可进行类型检查，最小化开发者的工作量，它也不会强制我们改变开发习惯，因为它会自动推断出变量的类型，这就是所谓的类型推断，Flow 最重要的特性之一。 通过一个简单例子说明一下：1234567/*@flow*/function split(str) &#123; return str.split(' ')&#125;split(11) Flow 检查上述代码后会报错，因为函数 split 期待的参数是字符串，而我们输入的是数字。 第二种方式：类型注释 如上所述，类型推断是 Flow 最有用的特性之一，不需要编写任何代码就能进行类型检查。但在某些特定的场景下，使用类型注释可以提供更好更明确的检查依据。 看看以下代码：1234567/*@flow*/function add(x, y)&#123; return x + y&#125;add('Hello', 11) Flow 根据类型推断检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 add() 的参数必须为数字。在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以冒号 : 开头，可以在函数参数，返回值，变量声明中使用。如果我们在上段代码中使用类型注释，就会变成如下：1234567/*@flow*/function add(x: number, y: number): number &#123; return x + y&#125;add('Hello', 11) 现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。上面的例子是针对函数的类型注释。接下来我们来看看 Flow 能支持的一些常见的类型注释: 第一种：数组12345/*@flow*/var arr: Array&lt;number&gt; = [1, 2, 3]arr.push('Hello') 数组类型注释的格式是 Array，T 表示数组中每项的数据类型。在上述代码中，arr 是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow 能检查出错误。 第二种：类和对象 12345678910111213141516171819202122/*@flow*/class Bar &#123; x: string; // x 是字符串 y: string | number; // y 可以是字符串或者数字 z: boolean; constructor(x: string, y: string | number) &#123; this.x = x this.y = y this.z = false &#125;&#125;var bar: Bar = new Bar('hello', 4)var obj: &#123; a: string, b: number, c: Array&lt;string&gt;, d: Bar &#125; = &#123; a: 'hello', b: 11, c: ['hello', 'world'], d: new Bar('hello', 3)&#125; 类的类型注释格式如上，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。这里需要注意的是：属性 y 的类型中间用 | 做间隔，表示 y 的类型即可以是字符串也可以是数字。 对象的注释类型类似于类，需要指定对象属性的类型。 第三种：Null/undefined Flow 会检查所有的 JavaScript 基础类型—— Boolean、String、Number、null、undefined（在Flow中用void代替）。除此之外还提供了一些操作符号，例如 text : ?string，它表示参数存在“没有值”的情况，除了传递 string 类型之外，还可以是 null 或 undefined。需要特别注意的是，这里的没有值和 JavaScript 的表达式的“非”是两个概念，Flow 的“没有值”只有 null、void（undefined），而 JavaScript 表达式的“非”包含：null、undefined、0、false。 如果想任意类型 T 可以为 null 或者 undefined，只需写成如下 ?T 的格式即可： 123/*@flow*/var foo: ?string = null 此时，foo 可以为字符串，也可以为 null。 Flow 在 Vue.js 源码中的应用有时候我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。 在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。 这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下：12345678flow├── compiler.js # 编译相关├── component.js # 组件数据结构├── global-api.js # Global API 结构├── modules.js # 第三方库定义├── options.js # 选项相关├── ssr.js # 服务端渲染相关├── vnode.js # 虚拟 node 相关 可以看到，Vue.js 有很多自定义类型的定义，在阅读源码的时候，如果遇到某个类型并想了解它完整的数据结构的时候，可以回来翻阅这些数据结构的定义。 小结通过对 Flow 的认识，有助于我们阅读 Vue 的源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。此外，通过 Vue 重构，我们发现项目重构要么依赖规范，要么就得自己有绝对控制权，同时还要考量开发成本、项目收益以及整个团队的技术水平，并不是一味的什么火就用什么。 Rollup - 另一个前端模块化的打包工具Rollup 是前端模块化的一个打包工具，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。简单地说，它可以从一个入口文件开始，将所有使用的模块根据命令或者根据 Rollup 配置文件打包成一个目标文件，并且 Rollup 会自动过滤掉那些没有被使用过的函数或变量，从而使代码最小化，如果想使用直接导入这一个目标文件即可，因此 Rollup 极其适合构建一个工具库。 这里提到 Rollup 的两个特别重要的特性，第一个就是它使用了 ES2015 的模板标准，这意味着我们可以直接使用 import 和 export 而不需要引入 babel。另一个重要特性叫做 tree-shaking，这个特性可以帮助我们将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。举个简单的例子，我们在 foo.js 文件定义了 f1 和 f2 两个方法，然后在入口文件 index.js 只引入了 foo.js 文件中的 f1 方法，那么在最后打包 index.js 文件时，Rollup 就不会将 f2 方法打包到最终文件中（这个特性是基于 ES6 模块的静态分析的，也就是说，只有 export 而没有 import 的变量是不会被打包到最终代码中的）。 为什么用前端模块化的打包工具 Rollup之前 Vue 用 webpack 打包，还是会自带一个小型的动态 module 加载机制，并且每个文件是包在一个模块函数里的。Rollup 打包通过重命名 import binding 直接把所有文件的函数都放在同一个函数体里面… 所以最终出来的文件会小一些，并且初始化快个十几毫秒的样子。 如何用前端模块化的打包工具 Rollup关于如何使用前端模块化的打包工具 Rollup，这里就不做过多介绍了，可参考我之前写的一篇文章：Rollup使用指南，更详细的使用文档可参考：官网。 Webpack 和 Rollup 有什么不同Vue 从 1.0.10 开始就改用 Rollup 来打包。作者尤雨溪在知乎上也曾说过 使用 Rollup 只是用于 Vue 发布文件的构建，对用户使用没有直接影响。在这之前用 webpack 打包，还是会自带一个小型的动态 module 加载机制，并且每个文件是包在一个模块函数里的。Rollup 打包通过重命名 import binding 直接把所有文件的函数都放在同一个函数体里面… 所以最终出来的文件会小一些，并且初始化快个十几毫秒的样子。 Webpack 是目前使用最为火热的打包工具，没有之一，每月有数百万的下载量，为成千上万的网站和应用提供支持。相比之下，Rollup 并不起眼。但 Vue 并不孤单 – React，Ember，Preact，D3，Three.js，Moment 以及其他许多知名的库也使用 Rollup 。世界到底怎么了？为什么我们不能只有一个大众认可的 JavaScript 模块化打包工具？ Webpack 始于2012年，由 Tobias Koppers 发起，用于解决当时现有工具未解决的的一个难题：构建复杂的单页应用程序(SPA)。特别是 webpack 的两个特性改变了一切： 第一个特性：代码拆分(Code Splitting) 代码拆分也就是说我们可以将应用程序分解成可管理的代码块，可以按需加载，这意味着用户可以快速获取网站内容，而不必等到整个应用程序下载和解析完成。 第二个特性：各式各样的加载器（loader） 不管是图像，css，还是 html ，在 Webpack 看来一切都可作为模块，然后通过不同的加载器 loader 来加载它们。 ES6 发布之后，其中引入的模块机制使得静态分析成为了可能，于是 Rollup 发布了：其中 Rollup 有两个特别重要的特性，第一个就是它利用 ES2015 巧妙的模块设计，尽可能高效的构建出能够直接被其他 Javascript 库的。另一个重要特性叫做 tree-shaking，这个特性可以帮助我们将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。 紧接着 Webpack2 发布，仿照 Rollup 增加了 tree-shaking。 在之后， Webpack3 发布，仿照 Rollup 又增加了 Scope Hoisting。在在之后， Parcel 发布了一个快速、零配置的打包工具。于是，Webpack4 仿照 Parcel 发布了。 说了这么多，工作中我们到底该用哪个工具？ 对于应用使用 webpack，对于类库使用 Rollup。如果我们需要代码拆分(Code Splitting)，或者我们有很多静态资源需要处理，再或者我们构建的项目需要引入很多 CommonJS 模块的依赖，那么 webpack 是个很不错的选择。如果您的代码库是基于 ES2015 模块的，而且希望我们写的代码能够被其他人直接使用，我们需要的打包工具可能是 Rollup。 小结通过对 Rollup 的认识，有助于我们了解 Vue 的构建以及源码目录结构。 项目介绍上一章我们简单介绍了下 flow、Rollup 等前置知识，有兴趣的可以有针对性的学习它们。这一章我们真正的开始分析 Vue 源码，激动不激动？该章主要包括三小节：项目目录、源码构建、源码入口。 项目目录Vue.js 的源码都在 src 目录下，其详细目录结构如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344├── dist ---------------------------------------- 构建后的输出目录├── examples ------------------------------------ Vue 开发的应用案例├── flow ---------------------------------------- Flow 类型声明├── packages ------------------------------------ 独立发布包的目录├── scripts ------------------------------------- 构建相关的文件│ ├── git-hooks ------------------------------- git钩子的目录│ ├── alias.js -------------------------------- 别名配置文件│ ├── build.js -------------------------------- Rollup 构建文件│ ├── config.js ------------------------------- Rollup 构建配置的文件│ ├── gen-release-note.js --------------------- 生成发布通知│ ├── get-weex-version.js --------------------- 获取 weex 版本│ ├── release-weex.sh ------------------------- 自动发布新版本weex脚本│ ├── ci.sh ----------------------------------- 持续集成运行的脚本│ ├── release.sh ------------------------------ 自动发布新版本脚本├── src ----------------------------------------- 源码目录，我们主要剖析目录│ ├── compiler -------------------------------- 编译相关，主要将 template 编译为 render 函数 │ ├── core ------------------------------------ 核心代码，与平台无关的代码│ │ ├── components -------------------------- 抽象出来的通用组件│ │ ├── instance ---------------------------- Vue 构造函数设计相关的代码│ │ ├── global-api -------------------------- Vue 构造函数挂载全局方法(静态方法)或属性的代码│ │ ├── observer ---------------------------- 响应系统，包含数据观测的核心代码│ │ ├── vdom -------------------------------- 虚拟DOM创建(creation)和打补丁(patching)的代码├── ├── platforms ------------------------------- 平台特有的相关代码，不同平台的构建入口文件│ │ ├── web --------------------------------- web平台│ │ │ ├── entry-runtime.js ---------------- 不带编译器构建的入口│ │ │ ├── entry-runtime-with-compiler.js -- 自带编译器构建的入口│ │ │ ├── entry-compiler.js --------------- vue-template-compiler 包的入口文件│ │ │ ├── entry-server-renderer.js -------- vue-server-renderer 包的入口文件│ │ │ ├── entry-server-basic-renderer.js -- 输出 packages/vue-server-renderer/basic.js│ │ ├── weex -------------------------------- 混合应用├── ├── server ---------------------------------- 服务端渲染│ ├── sfc ------------------------------------- .vue 文件解析│ ├── shared ---------------------------------- 整个项目通用代码├── test ---------------------------------------- 测试文件├── .babelrc ------------------------------------ babel 配置文件├── .editorconfig ------------------------------- 编辑器语法规范配置├── .eslintignore ------------------------------- eslint 忽略配置├── .eslintrc ----------------------------------- eslint 配置文件├── .flowconfig --------------------------------- flow 的配置文件├── .gitignore ---------------------------------- git 忽略配置├── package-lock.json --------------------------- npm 加锁文件├── package.json -------------------------------- 项目管理文件├── README.md ----------------------------------- 项目文档├── yarn.lock ----------------------------------- yarn 加锁文件 上述目录很是熟悉，根目录下 src 存放源码，test 存放单元测试，examples 作为应用案例等等，后续 Vue 团队会不会也采用 monorepo 项目组织方式这个目前不好说，但有可能。接下来我们对重点剖析的源码目录做一个简要分析： compilercompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 Runtime Only 版本的还是 Runtime + Compiler 版本。下面我们来对比这两个版本： Runtime Only 版本：我们在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。 Runtime + Compiler 版本：我们如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板，如下所示：1234567891011// 需要编译器的版本new Vue(&#123; template: '&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;'&#125;)// 这种情况不需要new Vue(&#123; render (h) &#123; return h('div', this.hi) &#125;&#125;) 因为在 Vue.js 2.0 中，最终渲染都是通过 render 函数，如果写 template 属性，则需要编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。很显然，这个编译过程对性能会有一定损耗，所以通常我们更推荐使用 Runtime-Only 的 Vue.js。 corecore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。 platformplatform 目录是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和配合 weex 运行在 native 客户端上的 Vue.js。 serverserver 目录主要用于服务端渲染。这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。Vue.js 从 2.0 开始支持了服务端渲染，服务端渲染的主要工作是把组件渲染为服务器端的 HTML 字符串，然后将它们直接发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。 sfcsfc 目录主要用于把 .vue 文件内容解析成一个 JavaScript 对象，实际开发中我们一般用 webpack 完成该工作。 sharedshared 目录主要定义了一些共享的工具方法，这些工具方法不但适用于浏览器端的 Vue.js，同时也适用于服务端的 Vue.js。 小结从 Vue.js 的目录设计可以看到，作者把功能模块拆分的非常清楚，相关的逻辑放在一个独立的目录下维护，并且把复用的代码也抽成一个独立目录。 源码构建Vue 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。 构建命令通常一个基于 NPM 托管的项目都会有一个 package.json 文件，实际上它是对项目的描述文件，它的内容是一个标准的 JSON 对象。我们通常会配置 script 字段作为 NPM 的构建命令，Vue 源码构建的脚本如下：1234567891011121314151617181920212223242526272829303132&#123; // ... "main": "dist/vue.runtime.common.js", "module": "dist/vue.runtime.esm.js", "unpkg": "dist/vue.js", "jsdelivr": "dist/vue.js", "typings": "types/index.d.ts", "files": [ "src", "dist/*.js", "types/*.d.ts" ], "sideEffects": false, "scripts": &#123; // 构建完整版 umd 模块的 Vue "dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev", // 构建运行时 cjs 模块的 Vue "dev:cjs": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs", // 构建运行时 es 模块的 Vue "dev:esm": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-esm", // 构建 web-server-renderer 包 "dev:ssr": "rollup -w -c scripts/config.js --environment TARGET:web-server-renderer", // 构建 Compiler 包 "dev:compiler": "rollup -w -c scripts/config.js --environment TARGET:web-compiler ", // ... "build": "node scripts/build.js", "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer", "build:weex": "npm run build -- weex", // ... &#125;, // ...&#125; 这里总共有 3 条命令，作用都是构建 Vue，后面 2 条是在第一条命令的基础上，添加一些环境参数。当在命令行运行npm run build的时候，实际上会执行node scripts/build.js，接下来我们就来看看它实际上是如何构建的。 构建过程我们首先打开构建命令对应的构建 JS 脚本，在scripts/build.js中：12345678910111213141516171819// ...let builds = require('./config').getAllBuilds()// filter builds via command line argif (process.argv[2]) &#123; const filters = process.argv[2].split(',') builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf('weex') === -1 &#125;)&#125;build(builds)// ... 这段代码逻辑非常简单，先从配置文件读取配置，再通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。稍后我们再来看构建函数 build，我们先来看看配置文件，在scripts/config.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const builds = &#123; // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify 'web-runtime-cjs': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.common.js'), format: 'cjs', banner &#125;, // Runtime+compiler CommonJS build (CommonJS) 'web-full-cjs': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.common.js'), format: 'cjs', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // Runtime only (ES Modules). Used by bundlers that support ES Modules, // e.g. Rollup &amp; Webpack 2 'web-runtime-esm': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.esm.js'), format: 'es', banner &#125;, // Runtime+compiler CommonJS build (ES Modules) 'web-full-esm': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.esm.js'), format: 'es', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // runtime-only build (Browser) 'web-runtime-dev': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.js'), format: 'umd', env: 'development', banner &#125;, // runtime-only production build (Browser) 'web-runtime-prod': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.min.js'), format: 'umd', env: 'production', banner &#125;, // Runtime+compiler development build (Browser) 'web-full-dev': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.js'), format: 'umd', env: 'development', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // Runtime+compiler production build (Browser) 'web-full-prod': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.min.js'), format: 'umd', env: 'production', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // ...&#125; 这里简单列举了一些 Vue 构建的配置，其他已省略，可以看出实际上这是一个用于 Rollup 构建配置的对象。接下来我们再看一下构建函数 build，在scripts/build.js中：12345678910111213141516171819202122232425262728293031323334353637383940// ...build(builds)function build (builds) &#123; let built = 0 const total = builds.length const next = () =&gt; &#123; buildEntry(builds[built]).then(() =&gt; &#123; built++ if (built &lt; total) &#123; next() &#125; &#125;).catch(logError) &#125; next()&#125;function buildEntry (config) &#123; const output = config.output const &#123; file, banner &#125; = output const isProd = /min\.js$/.test(file) return rollup.rollup(config) .then(bundle =&gt; bundle.generate(output)) .then((&#123; code &#125;) =&gt; &#123; if (isProd) &#123; var minified = (banner ? banner + '\n' : '') + uglify.minify(code, &#123; output: &#123; ascii_only: true &#125;, compress: &#123; pure_funcs: ['makeMap'] &#125; &#125;).code return write(file, minified, true) &#125; else &#123; return write(file, code) &#125; &#125;)&#125; 上述关键的代码是return rollup.rollup(config)，可以看出这是通过 rollup 打包的，对于单个配置，它是遵循 Rollup 的构建规则的。其中 entry 属性表示构建的入口 JS 文件地址，dest 属性表示构建后的输出的 JS 文件地址，format 属性表示构建的格式，cjs 表示构建出来的文件遵循CommonJS 规范，es 表示构建出来的文件遵循ES Module 规范，umd 表示构建出来的文件遵循UMD 规范。 下面我们以配置文件的web-runtime-cjs配置为例： 构建的入口 JS 文件地址： 12345678910const builds = &#123; // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify 'web-runtime-cjs': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.common.js'), format: 'cjs', banner &#125;, // ...&#125; 沿着resolve函数我们来看一下它的定义，在scripts/config.js中： 123456789const aliases = require('./alias')const resolve = p =&gt; &#123; const base = p.split('/')[0] if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1)) &#125; else &#123; return path.resolve(__dirname, '../', p) &#125;&#125; 上述resolve函数实现非常简单：它把传入的参数p通过/分割成数组并取数组第一个元素赋值给base。在我们这个例子中，参数p的值是web/entry-runtime.js，那么base的值则为web。这里的base并不是实际的路径，它的实际路径是借助别名获取的，接下来我们来看一下别名配置的代码，在scripts/alias中：123456789101112131415const path = require('path')const resolve = p =&gt; path.resolve(__dirname, '../', p)module.exports = &#123; vue: resolve('src/platforms/web/entry-runtime-with-compiler'), compiler: resolve('src/compiler'), core: resolve('src/core'), shared: resolve('src/shared'), web: resolve('src/platforms/web'), weex: resolve('src/platforms/weex'), server: resolve('src/server'), entries: resolve('src/entries'), sfc: resolve('src/sfc')&#125; 很显然，这里web对应的真实的路径是path.resolve(__dirname, &#39;../&#39;, &#39;src/platforms/web&#39;)，这个路径就是src/platforms/web，然后resolve函数通过path.resolve(aliases[base], p.slice(base.length + 1))就得到了Vue源码的最终路径，它就是src/platforms/web/entry-runtime.js，因此，web-runtime-cjs配置对应的入口文件就是src/platforms/web/entry-runtime.js。 构建后的输出的 JS 文件地址： 12345678910111213141516171819202122232425262728293031323334353637const aliases = require('./alias')const resolve = p =&gt; &#123; const base = p.split('/')[0] if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1)) &#125; else &#123; return path.resolve(__dirname, '../', p) &#125;&#125;const builds = &#123; // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify 'web-runtime-cjs': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.common.js'), format: 'cjs', banner &#125;, // ...&#125;// alias.jsconst path = require('path')const resolve = p =&gt; path.resolve(__dirname, '../', p)module.exports = &#123; vue: resolve('src/platforms/web/entry-runtime-with-compiler'), compiler: resolve('src/compiler'), core: resolve('src/core'), shared: resolve('src/shared'), web: resolve('src/platforms/web'), weex: resolve('src/platforms/weex'), server: resolve('src/server'), entries: resolve('src/entries'), sfc: resolve('src/sfc')&#125; 由于别名配置里并没有dist别名配置，因此dest直接返回path.resolve(__dirname,&#39;../&#39;,dist/vue.runtime.common.js);，因此构建后的输出的 JS 文件地址是dist/vue.runtime.common.js。 小结通过这一节的分析，我们可以了解到 Vue.js 的打包过程，也知道了不同作用和功能的 Vue.js 它们对应的入口以及最终编译生成的 JS 文件。尽管在实际开发过程中我们会用Runtime Only版本开发比较多，但为了分析 Vue 的编译过程，我们重点分析的源码是Runtime + Compiler 的 Vue.js。 源码入口Vue 的定义我们在源码构建一节讲到，在web应用下，我们来分析Runtime + Compiler构建出来的 Vue.js，它的入口是src/platforms/web/entry-runtime-with-compiler.js： 12345678910111213141516171819202122232425262728293031/* @flow */import config from 'core/config'import &#123; warn, cached &#125; from 'core/util/index'import &#123; mark, measure &#125; from 'core/util/perf'import Vue from './runtime/index'import &#123; query &#125; from './util/index'import &#123; compileToFunctions &#125; from './compiler/index'import &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref &#125; from './util/compat'const idToTemplate = cached(id =&gt; &#123; const el = query(id) return el &amp;&amp; el.innerHTML&#125;)const mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; // ... return mount.call(this, el, hydrating)&#125;// ...Vue.compile = compileToFunctionsexport default Vue 由此可以看出，当我们在代码执行import Vue from &#39;vue&#39;时，就是从这个入口来初始化 Vue 的。在这个入口 JS 的上方我们可以找到 Vue 的来源：import Vue from &#39;./runtime/index&#39;，接下来我们来看一下这块儿的实现，在src/platforms/web/runtime/index.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* @flow */import Vue from 'core/index'import config from 'core/config'import &#123; extend, noop &#125; from 'shared/util'import &#123; mountComponent &#125; from 'core/instance/lifecycle'import &#123; devtools, inBrowser, isChrome &#125; from 'core/util/index'import &#123; query, mustUseProp, isReservedTag, isReservedAttr, getTagNamespace, isUnknownElement&#125; from 'web/util/index'import &#123; patch &#125; from './patch'import platformDirectives from './directives/index'import platformComponents from './components/index'// install platform specific utilsVue.config.mustUseProp = mustUsePropVue.config.isReservedTag = isReservedTagVue.config.isReservedAttr = isReservedAttrVue.config.getTagNamespace = getTagNamespaceVue.config.isUnknownElement = isUnknownElement// install platform runtime directives &amp; componentsextend(Vue.options.directives, platformDirectives)extend(Vue.options.components, platformComponents)// install platform patch functionVue.prototype.__patch__ = inBrowser ? patch : noop// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125;// ...export default Vue 在这个 JS 的上方我们可以找到 Vue 的来源：import Vue from &#39;core/index&#39;，剩下的都是对 Vue 这个对象的扩展，我们暂且不去分析，我们先来看一下关键代码实现的文件，在src/core/index.js中：1234567891011121314151617181920212223242526import Vue from './instance/index'import &#123; initGlobalAPI &#125; from './global-api/index'import &#123; isServerRendering &#125; from 'core/util/env'import &#123; FunctionalRenderContext &#125; from 'core/vdom/create-functional-component'initGlobalAPI(Vue)Object.defineProperty(Vue.prototype, '$isServer', &#123; get: isServerRendering&#125;)Object.defineProperty(Vue.prototype, '$ssrContext', &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, 'FunctionalRenderContext', &#123; value: FunctionalRenderContext&#125;)Vue.version = '__VERSION__'export default Vue 阿西吧，还没到！在这个 JS 的上方我们可以找到 Vue 的来源是import Vue from &#39;./instance/index&#39;，在src/core/instance/index.js中，不过这里有一点需要特别说明下：initGlobalAPI(Vue)用于初始化全局 Vue API（我们稍后介绍）： 1234567891011121314151617181920212223import &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 至此，我们终于看到了 Vue 的定义，可以看出它实际上就是一个用 Function 实现的类，我们只能通过 new Vue 去实例化它。接下来我们来分析一下上面遗留下来的问题。 initGlobalAPIVue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在src/core/global-api/index.js中： 12345678910111213141516171819202122232425262728293031323334353637383940414243export function initGlobalAPI (Vue: GlobalAPI) &#123; // config const configDef = &#123;&#125; configDef.get = () =&gt; config if (process.env.NODE_ENV !== 'production') &#123; configDef.set = () =&gt; &#123; warn( 'Do not replace the Vue.config object, set individual fields instead.' ) &#125; &#125; Object.defineProperty(Vue, 'config', configDef) // exposed util methods. // NOTE: these are not considered part of the public API - avoid relying on // them unless you are aware of the risk. Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125; Vue.set = set Vue.delete = del Vue.nextTick = nextTick Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + 's'] = Object.create(null) &#125;) // this is used to identify the "base" constructor to extend all plain-object // components with in Weex's multi-instance scenarios. Vue.options._base = Vue extend(Vue.options.components, builtInComponents) initUse(Vue) initMixin(Vue) initExtend(Vue) initAssetRegisters(Vue)&#125; 这里是对 Vue 扩展的一些全局方法，有一点要注意的是，Vue.util 暴露的方法最好不要依赖，因为它可能经常会发生变化且不稳定的。 小结那么至此，我们应该对 Vue 是什么有一个直观的认识，它本质上就是一个用 Function 实现的 Class，然后在它的原型 prototype 以及它本身都扩展了一系列的方法和属性，至于 Vue 能做什么，它是怎么做的，我们会在后面的章节一一剖析它们。 基础组件化在Vue.js中，除了它内置的组件如keep-alive、component、transition、transition-group等，其它自定义组件在使用前必须注册。我们在开发过程中可能会遇到如下报错信息：12'Unknown custom element: &lt;xxx&gt; - did you register the component correctly? For recursive components, make sure to provide the "name" option.' 一般报这个错的原因都是我们使用了未注册的组件。Vue.js 提供了 2 种组件的注册方式：全局注册和局部注册。接下来我们从源码分析的角度来分析这两种注册方式。 组件注册本文不断更新中]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码全方位剖析]]></title>
    <url>%2F2018%2F08%2F12%2Freact-source-analysis.html</url>
    <content type="text"><![CDATA[版本：v16.5.2 前言当时在各种前端框架或库充斥市场的情况下，出现了大量优秀的框架，比如 Backbone、Angular、Knockout、Ember 这些框架大都采用了 MV* 的理念，把数据与视图分离。而就在这样纷繁复杂的时期，React 诞生于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。所谓知其然还要知其所以然，加上 React 真是一天一改，如果现在不看，以后也真的很难看懂了。目前社区有很多 React 的源码剖析文章，趁着最近工作不忙，我打算分享一下 React 源码，并自形成一个系列，欢迎一起交流。在开始之前我们先做以下几点约定： 第一：目前分析的版本是 React 的最新版本 16.5.2；第二：React web应用是最常见的，也是最易于理解的，所以该源码均围绕 React web应用剖析；第三：我尽可能站在我自己的角度去剖析，当然我会借鉴社区比较优秀的文章，同时面对大家的拍砖，我无条件接受，也很乐意与大家一起交换意见，努力写好该 React 源码系列；第四：如果有幸您读到该 React 源码系列，感觉写得还行，还望收藏、分享或打赏。 前置知识我们从这一章开始即将分析 React 的源码，在分析源码之前我们很有必要介绍一些前置知识如flow、Rollup等。除此之外，我们最好已经用过 React 做过实际项目，对 React 的思想有了一定的了解，对绝大部分的 API 都已经有使用，同时，我们应该有一定的HTML、CSS、JavaScript、ES6+、node &amp; npm等功底，并对代码调试有一定的了解。 如果具备了以上条件，并且对 React 的实现原理很感兴趣，那么就可以开始 React 的底层学习了，对它的实现细节一探究竟。 Flow - JavaScript静态类型检查工具Flow 是 facebook 出品的 JavaScript 静态类型检查工具，它与 Typescript 不同的是，它可以部分引入，不需要完全重构整个项目，所以对于一个已有一定规模的项目来说，迁移成本更小，也更加可行。除此之外，Flow 可以提供实时增量的反馈，通过运行 Flow server 不需要在每次更改项目的时候完全从头运行类型检查，提高运行效率。可以简单总结为：对于新项目，可以考虑使用 TypeScript 或者 Flow，对于已有一定规模的项目则建议使用 Flow 进行较小成本的逐步迁移来引入类型检查。React 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。 为什么用静态类型检查工具 FlowJavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用就是很容易就写出非常隐蔽的隐患代码，在编译期甚至运行时看上去都不会报错，但是可能会发生各种各样奇怪的和难以解决的bug。 类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。 项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。React 源码在 ES2015 的基础上，除了用 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，最根本原因应该和 Vue 一样，还是在于工程上成本和收益的考量。 大致体现在以下几点： 第一点：使用 Flow 可以一个一个文件地迁移，如果使用 TypeScript，则需要全部替换，成本极高，短期内并不现实；第二点：Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力；第三点：更贴近 ES 规范。除了 Flow 的类型声明之外，其他都是标准的 ES。万一哪天不想用 Flow 了，用babel-plugin-transform-flow-strip-types转一下，就得到符合规范的 ES；第四点：在需要的地方保留 ES 的灵活性，并且对于生成的代码尺寸有更好的控制力 (rollup / 自定义 babel 插件）。 如何用静态类型检查工具 Flow在这里我们就简单说一说 Flow 的用法，其他用法可以参考Flow官网（可能需要 VPN，非常不稳定），有时间我会详细写一篇 Flow 使用指南。 Flow 仅仅是一个用于检查的工具，安装使用都很方便，使用时注意以下3点即可： 1.将 Flow 安装到我们的项目中。2.确保编译之后的代码移除了 Flow 相关的语法。3.在需要检查的地方增加了 Flow 相关的类型注解。 第一点：将Flow增加到我们的项目中 安装最新版本的 Flow：1$ npm install --save-dev flow-bin 安装完成之后在 package.json 文件中增加执行脚本： 12345678&#123; // ... "scripts": &#123; "your-script-name": "flow", // ... &#125;, // ...&#125; 然后初始化 Flow： 1$ npm run flow init 执行完成后，Flow 会在终端输出以下内容： 12&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot; 然后在根目录下生成一个名为 .flowconfig 的文件，打开之后是这样的： 1234567891011[ignore][include][libs][lints][options][strict] 基本上，配置文件没有什么特殊需求是不用去配置的，Flow 默认涵盖了当前目录之后的所有文件。[include] 用于引入项目之外的文件。例如： 12345[include]../otherProject/a.js[libs] 它会将和当前项目平级的 otherProject/a.js 文件纳入进来。详细配置文件请看官网。 第二点：编译之后的代码移除 Flow 相关的语法 Flow 在 JavaScript 语法的基础上使用了一些注解（annotation）进行了扩展。因此浏览器无法正确的解读这些 Flow 相关的语法，我们必须在编译之后的代码中（最终发布的代码）将增加的 Flow 注解移除掉。具体方法需要看我们使用了什么样的编译工具。下面将说明一些 React 开发常用的编译工具： 方式一：create-react-app 如果我们的项目是使用create-react-app直接创建的，那么移除 Flow 语法的事项就不用操心了，create-react-app 已经帮我们搞定了这个事。 方式二：Babel 如果使用 Babel 我们需要安装一个 Babel 对于 Flow 的 preset：1$ npm install --save-dev babel-preset-flow 然后，我们需要在项目根目录Babel 的配置文件 .babelrc中添加一个 Flow 相关的 preset： 123456&#123; "presets": [ "flow", //other config ]&#125; 方式三：flow-remove-types 如果我们既没有使用 create-react-app 也没使用 Babel 作为语法糖编译器，那么可以使用 flow-remove-types 这个工具在发布之前移除 Flow 代码。 第三点：在需要检查的地方增加 Flow 相关的类型注解 如果我们了解 C++/C# 的元编程或者 Java 的 Annotation，那么理解 Flow 的 Annotation 就会非常轻松。大概就是在文件、方法、代码块之前增加一个注解（Annotation）用来告知 Flow 的执行行为。 首先，Flow 只检查包含// @flow注解的文件，所以如果需要检查，我们需要这样编写我们的文件，首先我们写一个正确的示例： 1234567/* @flow */function add(x: number, y: number): number &#123; return x + y&#125;add(22, 11) 运行 Flow 终端会打印出以下内容： 1234&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot;Found 0 errors 承接上面代码，我们把代码修改成带有检查错误的例子： 1234567/* @flow */function add(x: number, y: number): number &#123; return x + y&#125;add("Hello", 11) 运行 Flow 终端会打印出以下内容： 12345678910111213141516171819&gt; yourProjectName@1.0.0 flow /yourProjectPath&gt; flow &quot;init&quot;Error ------------------------------------------------------------------------------------- src/platforms/web/mnr.js:8:5Cannot call `add` with `&quot;Hello&quot;` bound to `x` because string [1] is incompatible with number [2]. src/platforms/web/mnr.js:8:5 8| add(&quot;Hello&quot;, 11) ^^^^^^^ [1]References: src/platforms/web/mnr.js:4:17 4| function add(x: number, y: number): number &#123; ^^^^^^ [2]Found 1 error 到这里，Flow 已经算是安装成功了，接下来的事是要增加各种注解以加强类型限定或者参数检测。之后的内容将简要介绍 flow 的类型检查方式。 Flow 的类型检查方式现在我们就说说 Flow 常用的2种类型检查方式：类型推断：通过变量的执行上下文来推断出变量类型，然后根据这些推断来检查类型。类型注释：事先注释好我们期望的类型，Flow 会基于这些注释来检查。 第一种方式：类型推断 此方式不需要编写任何代码即可进行类型检查，最小化开发者的工作量，它也不会强制我们改变开发习惯，因为它会自动推断出变量的类型，这就是所谓的类型推断，Flow 最重要的特性之一。 通过一个简单例子说明一下：1234567/*@flow*/function split(str) &#123; return str.split(' ')&#125;split(11) Flow 检查上述代码后会报错，因为函数 split 期待的参数是字符串，而我们输入的是数字。 第二种方式：类型注释 如上所述，类型推断是 Flow 最有用的特性之一，不需要编写任何代码就能进行类型检查。但在某些特定的场景下，使用类型注释可以提供更好更明确的检查依据。 看看以下代码：1234567/*@flow*/function add(x, y)&#123; return x + y&#125;add('Hello', 11) Flow 根据类型推断检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 add() 的参数必须为数字。在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以冒号 : 开头，可以在函数参数，返回值，变量声明中使用。如果我们在上段代码中使用类型注释，就会变成如下：1234567/*@flow*/function add(x: number, y: number): number &#123; return x + y&#125;add('Hello', 11) 现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。上面的例子是针对函数的类型注释。接下来我们来看看 Flow 能支持的一些常见的类型注释: 第一种：数组12345/*@flow*/var arr: Array&lt;number&gt; = [1, 2, 3]arr.push('Hello') 数组类型注释的格式是 Array，T 表示数组中每项的数据类型。在上述代码中，arr 是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow 能检查出错误。 第二种：类和对象 12345678910111213141516171819202122/*@flow*/class Bar &#123; x: string; // x 是字符串 y: string | number; // y 可以是字符串或者数字 z: boolean; constructor(x: string, y: string | number) &#123; this.x = x this.y = y this.z = false &#125;&#125;var bar: Bar = new Bar('hello', 4)var obj: &#123; a: string, b: number, c: Array&lt;string&gt;, d: Bar &#125; = &#123; a: 'hello', b: 11, c: ['hello', 'world'], d: new Bar('hello', 3)&#125; 类的类型注释格式如上，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。这里需要注意的是：属性 y 的类型中间用 | 做间隔，表示 y 的类型即可以是字符串也可以是数字。 对象的注释类型类似于类，需要指定对象属性的类型。 第三种：Null/undefined Flow 会检查所有的 JavaScript 基础类型—— Boolean、String、Number、null、undefined（在Flow中用void代替）。除此之外还提供了一些操作符号，例如 text : ?string，它表示参数存在“没有值”的情况，除了传递 string 类型之外，还可以是 null 或 undefined。需要特别注意的是，这里的没有值和 JavaScript 的表达式的“非”是两个概念，Flow 的“没有值”只有 null、void（undefined），而 JavaScript 表达式的“非”包含：null、undefined、0、false。 如果想任意类型 T 可以为 null 或者 undefined，只需写成如下 ?T 的格式即可： 123/*@flow*/var foo: ?string = null 此时，foo 可以为字符串，也可以为 null。 Flow 在 React 源码中的应用Flow 是 Facebook 开源的静态代码检查工具，它的作用就是在运行代码之前对 React 组件以及 Jsx 语法进行静态代码的检查以发现一些可能存在的问题。在 React v16 Fiber中的部分 TypeScript 代码只是类型声明文件和测试代码，也就是为了方便利用 TypeScript 写应用的开发者使用 React，给了接口定义和测试样例而已。 小结React 重构告诉我们，项目重构要么依赖规范，要么就得自己有绝对控制权，同时还要考量开发成本、项目收益以及整个团队的技术水平，并不是一味的什么火就用什么。这一节主要对 Flow 的认识，有助于我们后续阅读 React 的源码，这种静态类型检查的方式非常有利于大型项目源码的开发和维护。 Rollup - 另一个前端模块化的打包工具Rollup 是前端模块化的一个打包工具，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。简单地说，它可以从一个入口文件开始，将所有使用的模块根据命令或者根据 Rollup 配置文件打包成一个目标文件，并且 Rollup 会自动过滤掉那些没有被使用过的函数或变量，从而使代码最小化，如果想使用直接导入这一个目标文件即可，因此 Rollup 极其适合构建一个工具库。 这里提到 Rollup 的两个特别重要的特性，第一个就是它使用了 ES2015 的模板标准，这意味着我们可以直接使用 import 和 export 而不需要引入 babel。另一个重要特性叫做 tree-shaking，这个特性可以帮助我们将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。举个简单的例子，我们在 foo.js 文件定义了 f1 和 f2 两个方法，然后在入口文件 index.js 只引入了 foo.js 文件中的 f1 方法，那么在最后打包 index.js 文件时，Rollup 就不会将 f2 方法打包到最终文件中（这个特性是基于 ES6 模块的静态分析的，也就是说，只有 export 而没有 import 的变量是不会被打包到最终代码中的）。 为什么用前端模块化的打包工具 Rollup之前的构建系统是基于 Gulp/Grunt+Browserify 手搓的一套工具，后来在扩展方面受限于工具，例如： Node 环境下性能不好：频繁的process.env.NODE_ENV访问拖慢了SSR 性能，但又没办法从类库角度解决，因为Uglify依靠这个去除无用代码，所以React SSR性能最佳实践一般都有一条“重新打包 React，在构建时去掉 process.env.NODE_ENV”. 丢弃了过于复杂（overly-complicated）的自定义构建工具，改用更合适的 Rollup： It solves one problem well: how to combine multiple modules into a flat file with minimal junk code in between. 无论 Haste -&gt; ES Module 还是 Gulp/Grunt+Browserify -&gt; Rollup 的切换都是从非标准的定制化方案切换到标准的开放的方案，应该在“手搓”方面吸取教训，为什么业界规范的东西在我们的场景不适用，非要自己造吗？ 如何用前端模块化的打包工具 Rollup关于如何使用前端模块化的打包工具 Rollup，这里就不做过多介绍了，可参考我之前写的一篇文章：Rollup使用指南，更详细的使用文档可参考：官网。 Webpack 和 Rollup 有什么不同2017年4月初，Facebook 将一个巨大的 pull 请求合并到了 React 主分支(master)中，将其现有的构建流程替换为基于 Rollup，这一举动促使一些人产生很大的疑惑“React 为什么选择 Rollup 而抛弃 webpack”，难道webpack要跌下神坛了？ Webpack 是目前使用最为火热的打包工具，没有之一，每月有数百万的下载量，为成千上万的网站和应用提供支持。相比之下，Rollup 并不起眼。但 React 并不孤单 – Vue，Ember，Preact，D3，Three.js，Moment 以及其他许多知名的库也使用 Rollup 。世界到底怎么了？为什么我们不能只有一个大众认可的 JavaScript 模块化打包工具？ Webpack 始于2012年，由 Tobias Koppers 发起，用于解决当时现有工具未解决的的一个难题：构建复杂的单页应用程序(SPA)。特别是 webpack 的两个特性改变了一切： 第一个特性：代码拆分(Code Splitting) 代码拆分也就是说我们可以将应用程序分解成可管理的代码块，可以按需加载，这意味着用户可以快速获取网站内容，而不必等到整个应用程序下载和解析完成。 第二个特性：各式各样的加载器（loader） 不管是图像，css，还是 html ，在 Webpack 看来一切都可作为模块，然后通过不同的加载器 loader 来加载它们。 ES6 发布之后，其中引入的模块机制使得静态分析成为了可能，于是 Rollup 发布了：其中 Rollup 有两个特别重要的特性，第一个就是它利用 ES2015 巧妙的模块设计，尽可能高效的构建出能够直接被其他 Javascript 库的。另一个重要特性叫做 tree-shaking，这个特性可以帮助我们将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。 紧接着 Webpack2 发布，仿照 Rollup 增加了 tree-shaking。 在之后， Webpack3 发布，仿照 Rollup 又增加了 Scope Hoisting。在在之后， Parcel 发布了一个快速、零配置的打包工具。于是，Webpack4 仿照 Parcel 发布了。 说了这么多，工作中我们到底该用哪个工具？ 对于应用使用 webpack，对于类库使用 Rollup。如果我们需要代码拆分(Code Splitting)，或者我们有很多静态资源需要处理，再或者我们构建的项目需要引入很多 CommonJS 模块的依赖，那么 webpack 是个很不错的选择。如果您的代码库是基于 ES2015 模块的，而且希望我们写的代码能够被其他人直接使用，我们需要的打包工具可能是 Rollup。 小结无论 Haste -&gt; ES Module 还是 Gulp/Grunt+Browserify -&gt; Rollup 的切换都是从非标准的定制化方案切换到标准的开放的方案，可以看出 React 团队也在积极拥抱标准方案并非一味造轮子。其实 Vue.js 1.0.10 就已经使用 Rollup 了，而 React v16.0 改用 Rollup 肯定也有借鉴之意，因此，好技术都是在借鉴的大背景下诞生的（Vue 就是一个典型的例子）。在这里通过对 Rollup 的认识，有助于我们了解 React 的构建以及源码目录结构。 项目介绍上一章我们简单介绍了下flow、Rollup等前置知识，有兴趣的可以有针对性的学习它们。这一章我们真正的开始分析 React 源码，激动不激动？该章主要包括三小节：项目目录、源码构建、源码入口。 项目目录目录结构我们主要剖析的 React 源码目录在 packages 下，在这里我们看看详细目录结构，混个眼熟： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748├── build --------------------------------------- 构建后的输出目录├── fixtures ------------------------------------ React 开发的测试用例├── packages ------------------------------------ 源码目录，我们主要剖析目录│ ├── create-subscription --------------------- 在组件里订阅额外数据的工具│ ├── events ---------------------------------- 事件处理 │ ├── interaction-tracking -------------------- 跟踪交互事件│ ├── react ----------------------------------- 核心代码│ ├── react-art ------------------------------- 矢量图形库│ ├── react-dom ------------------------------- DOM 渲染相关│ ├── react-is -------------------------------- React 元素类型相关│ ├── react-native-renderer ------------------- react-native 渲染相关 │ ├── react-noop-renderer --------------------- Fiber 测试相关 │ ├── react-reconciler ------------------------ React 调制器│ ├── react-scheduler ------------------------- 规划 React 初始化，更新等等│ ├── react-test-renderer --------------------- 实验性的 React 渲染器│ ├── shared ---------------------------------- 通用代码│ ├── simple-cache-provider ------------------- 为 React 应用提供缓存│ ├── server ---------------------------------- 服务端渲染│ ├── sfc ------------------------------------- .vue 文件解析│ ├── shared ---------------------------------- 整个项目通用代码├── scripts ------------------------------------- 公共的lint，build，test和release等相关的文件│ ├── eslint ---------------------------------- 语法规则和代码风格│ ├── flow ------------------------------------ Flow 类型声明│ ├── git ------------------------------------- git钩子的目录│ ├── jest ------------------------------------ JavaScript 测试目录│ ├── release --------------------------------- 自动发布新版本脚本│ ├── rollup ---------------------------------- rollup 构建目录├── .babelrc ------------------------------------ babel 配置文件├── .editorconfig ------------------------------- 编辑器语法规范配置├── .eslintignore ------------------------------- eslint 忽略配置 ├── .eslintrc ----------------------------------- eslint 配置文件├── .gitattributes ------------------------------ 给 attributes 路径名的简单文本文件├── .gitignore ---------------------------------- git 忽略配置├── .mailmap ------------------------------------ 邮件列表档案 ├── .nvmrc -------------------------------------- nvm 配置文件├── .prettierrc.js ------------------------------ prettierrc 配置文件├── .watchmanconfig ----------------------------- watchman 配置文件├── appveyor.yml -------------------------------- GitHub 托管项目的自动化集成├── AUTHORS ------------------------------------- 开发者列表档案├── CHANGELOG.md -------------------------------- 更新日志├── CODE_OF_CONDUCT.md -------------------------- Code of Conduct├── CONTRIBUTING.md ----------------------------- Contributing to React├── dangerfile.js ------------------------------- 提高 Code Review 体验├── netlify.toml -------------------------------- 持续集成静态网站├── package-lock.json --------------------------- npm 加锁文件├── package.json -------------------------------- 项目管理文件├── README.md ----------------------------------- 项目文档├── yarn.lock ----------------------------------- yarn 加锁文件 一眼望去，上面的目录结构是不是感觉很是奇怪？根目录下没有 src 之类的源码目录，也没有 test 这类的存放单元测试的目录，只有一个 packages 目录。这个 repository 其实是一个用 Lerna 管理的 monorepo。实际上，我们往npm上发布的几个package都来自于同一个codebase，包括react、react-dom、react-is…… monorepo通常，当我们的项目不断的迭代更新的时候，我们会根据业务或者是功能又或者是方便复用某些代码模块，把一个大的 codebase 拆成一些独立的 package 或 module，再将这些功能独立的 package 分别放入单独的 repository 中进行维护，此方式可以简单地称为multiple repositories。而 monorepo 则是一种相反的做法，它提倡将所有的相关 package 都放入一个 repository 来管理。 monorepo VS multirepo（集中管理 vs 多元化）首先这两者都是管理组织代码的方式，顾名思义 monorepo 就是把所有的相关项目都放在一个仓库中（比如 React, Angular, Babel, Google…），multirepo 则是按模块分为多个仓库。 multirepo：这种管理方式可以让每个子团队拥有自己的 repo，我们可以用自己擅长的工具、workflow 等等。多元化能促使各个团队尽可能的提升自己的效率。但代价也在于会增加很多沟通成本，如果我们项目用到的库中发现了一个 bug，就必须到目标库里修复它、打包、发版本，然后再回到我们的库继续工作。在不同的仓库间，我们不仅需要处理不同的代码、工具，甚至是不同的工作流程。甚至我们只能去问维护这个仓库的人，能不能为我们做出改变，然后等着他们去解决。 monorepo：这种管理方式可以让不同的团队走自己的路，并不见得能提高生产力。虽然有些团队可能会找到自己最佳的工作方式，但我们的收益也会被其他团队不那么好的工作方式所抵消。相反，严格统一的管理更能提升效率，团队中的任何人都可以（并且应该也被鼓励）修改任何东西（因为修改造成的结果马上就能展现出来，）。虽然把所有的鸡蛋都放进了一个篮子里，但我们也可以更小心的照顾这个篮子。 如果我们团队选择 monorepo，那主要的挑战自然是随着项目的发展，其会变得非常庞大（因为没有根据模块或功能拆分成不同 repo）。因此会需要很多的工具来应对这样的挑战。虽然我们可能认为这是一个很糟糕的做法，但是现在这样做的开源项目和公司并不算少。 谁在使用 monorepoBabel 是一个 Javascript 编译器，它可以将浏览器环境尚未支持的 Javascript 变为向下兼容的版本。因此，我们可以毫无顾虑地使用较新的 Javascript 语法和特性来提升编程的体验和效率。 其中 Babel 官方维护了众多独立的 plugin、polyfill、preset，但并未按照传统，将这些独立的模块分别放入不同的 repo。而是遵循了 monorepo 的方式，将它们放入一个相同的 repo 中。因为 Babel 认为，有效的组织一个多模块，多 repo 的项目，就像是尝试教一个刚出生的婴儿骑自行车一样。 Juggling a multimodule project over multiple repos is like trying to teach a newborn baby how to ride a bike. 所以，Babel 采用了 lerna 来管理自己的 monorepo。 无独有偶，Cycle.js（一个函数式和响应式 Javascript 框架）的作者 André Staltz 也摒弃了一个 package 一个 repo 的做法，将 Cycle.js 的众多 package 迁移到了一个 monorepo 中。他也认为，管理多个 repo 并不是件有意思的事情。多个 repo 意味着有多个地方需要处理 issue，保持多个 repo 的 issue 标签统一，管理很多 PR 和 git 钩子等等。 Managing multiple repos isn’t that fun. Multiple repos means multiple places to manage issues, manage issue labels (and making them consistent across repos), manage PRs, git hooks for conventions, etc. André Staltz 并没有使用 lerna 之类的工具来实现自己的 monorepo，他自己通过 Bash sh 实现了类似于 Lerna 管理的 monorepo。 除了 Babel 和 Cycle.js 以外，React、Angular、Meteor、Ember，还包括国内饿了么的 mint-ui 等等开源项目，以及一些公司如 Google、Facebook、BBC 等也都采用了 monorepo。它到底有什么优点，这么多公司，这么多库纷纷加入。 优点一：单个的 lint，build，test 和 release 流程；二：统一的地方处理issue；三：不用到处去找自己项目的repo；四：方便管理版本和dependencies；五：跨项目的操作和修改变得容易；六：方便生成总的changelog。 缺点一：repo 的体积变得很大；二：安全问题，如何管理权限。 关于 monorepo 我们暂且就说这么多，有时间我会单独写一篇 monorepo 文章。 小结从 React 的目录设计可以看出，React 团队在项目管理比较倾向 monorepo 方式，看来这种严格统一的管理方式真的提升效率。无论 monorepo 方式，还是 multirepo 方式都是为了团队效率，因此建议还是根据团队的情况选定一种方式，尽可能的扬长避短。 源码构建React v16.0 之前源码是基于Gulp/Grunt+Browserify构建的，而 React v16.0 是基于Rollup构建的，它的构建相关配置都在scripts/rollup目录下。 构建命令通常基于 NPM 托管的项目都会有一个 package.json 文件，实际上它是项目的描述文件，它的内容是一个标准的 JSON 对象。我们通常会配置 script 字段作为 NPM 的构建命令，React 源码构建配置如下： 123456789&#123; // ... "scripts": &#123; "build": "npm run version-check &amp;&amp; node ./scripts/rollup/build.js", // ... "version-check": "node ./scripts/tasks/version-check.js" &#125; // ...&#125; 这里build命令，实际上先执行version-check命令，然后执行node ./scripts/rollup/build.js进行打包，其中version-check命令实际上是执行node ./scripts/tasks/version-check.js，用于检查即将构建的bundle版本是否完全匹配，接下来我们就来看看它实际上是如何构建的。 构建过程我们首先打开build命令对应的第一个 JS 文件，在scripts/tasks/version-check.js中： 12345678910111213141516171819202122232425262728const reactVersion = require('../../package.json').version;const versions = &#123; 'packages/react/package.json': require('../../packages/react/package.json') .version, 'packages/react-dom/package.json': require('../../packages/react-dom/package.json') .version, 'packages/react-test-renderer/package.json': require('../../packages/react-test-renderer/package.json') .version, 'packages/shared/ReactVersion.js': require('../../packages/shared/ReactVersion'),&#125;;let allVersionsMatch = true;Object.keys(versions).forEach(function(name) &#123; const version = versions[name]; if (version !== reactVersion) &#123; allVersionsMatch = false; console.log( '%s version does not match package.json. Expected %s, saw %s.', name, reactVersion, version ); &#125;&#125;);if (!allVersionsMatch) &#123; process.exit(1);&#125; 这段代码逻辑非常简单，先获取即将发布的以及源码核心bundle的管理文件，再比对即将发布的和源码核心bundle的版本，如果不相同，给出对应的提示并结束构建，这样就保证了构建出来的 bundle 版本统一。 接下来我们打开build命令对应的第二个 JS 文件，在scripts/rollup/build.js中：12345678910111213141516async function buildEverything() &#123; await asyncRimRaf('build'); // Run them serially for better console output // and to avoid any potential race conditions. // eslint-disable-next-line no-for-of-loops/no-for-of-loops for (const bundle of Bundles.bundles) &#123; await createBundle(bundle, UMD_DEV); await createBundle(bundle, UMD_PROD); // ... &#125; // ... // ...&#125;buildEverything(); 这里通过调用buildEverything函数开启构建过程，asyncRimRaf用于删除上一次打包生成的包文件，然后循环包配置文件的配置构建出不同用途的 React 包，稍后我们再来看构建函数createBundle，我们先来看看包配置文件，在scripts/rollup/bundles.js中：123456789101112131415161718192021222324252627282930313233343536373839404142const bundles = [ /******* Isomorphic *******/ &#123; label: 'core', bundleTypes: [ UMD_DEV, UMD_PROD, NODE_DEV, NODE_PROD, FB_WWW_DEV, FB_WWW_PROD, ], moduleType: ISOMORPHIC, entry: 'react', global: 'React', externals: [], &#125;, /******* React DOM *******/ &#123; label: 'dom-client', bundleTypes: [ UMD_DEV, UMD_PROD, NODE_DEV, NODE_PROD, NODE_PROFILING, FB_WWW_DEV, FB_WWW_PROD, FB_WWW_PROFILING, ], moduleType: RENDERER, entry: 'react-dom', global: 'ReactDOM', externals: ['react'], &#125;, // ... // ...];module.exports = &#123; bundles,&#125;; 这里简单列举了一些 React 包构建的配置，其他已省略，可以看出实际上这是一个用于 Rollup 构建配置的对象数组，通过循环该对象数组构建出不同用途的 React 包。接下来我们再看一下构建函数createBundle，在scripts/rollup/build.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495async function createBundle(bundle, bundleType) &#123; if (shouldSkipBundle(bundle, bundleType)) &#123; return; &#125; const filename = getFilename(bundle.entry, bundle.global, bundleType); const logKey = chalk.white.bold(filename) + chalk.dim(` ($&#123;bundleType.toLowerCase()&#125;)`); const format = getFormat(bundleType); const packageName = Packaging.getPackageName(bundle.entry); let resolvedEntry = require.resolve(bundle.entry); if ( bundleType === FB_WWW_DEV || bundleType === FB_WWW_PROD || bundleType === FB_WWW_PROFILING ) &#123; const resolvedFBEntry = resolvedEntry.replace('.js', '.fb.js'); if (fs.existsSync(resolvedFBEntry)) &#123; resolvedEntry = resolvedFBEntry; &#125; &#125; const shouldBundleDependencies = bundleType === UMD_DEV || bundleType === UMD_PROD; const peerGlobals = Modules.getPeerGlobals(bundle.externals, bundleType); let externals = Object.keys(peerGlobals); if (!shouldBundleDependencies) &#123; const deps = Modules.getDependencies(bundleType, bundle.entry); externals = externals.concat(deps); &#125; const importSideEffects = Modules.getImportSideEffects(); const pureExternalModules = Object.keys(importSideEffects).filter( module =&gt; !importSideEffects[module] ); const rollupConfig = &#123; input: resolvedEntry, treeshake: &#123; pureExternalModules, &#125;, external(id) &#123; const containsThisModule = pkg =&gt; id === pkg || id.startsWith(pkg + '/'); const isProvidedByDependency = externals.some(containsThisModule); if (!shouldBundleDependencies &amp;&amp; isProvidedByDependency) &#123; return true; &#125; return !!peerGlobals[id]; &#125;, onwarn: handleRollupWarning, plugins: getPlugins( bundle.entry, externals, bundle.babel, filename, packageName, bundleType, bundle.global, bundle.moduleType, bundle.modulesToStub ), // We can't use getters in www. legacy: bundleType === FB_WWW_DEV || bundleType === FB_WWW_PROD || bundleType === FB_WWW_PROFILING, &#125;; const [mainOutputPath, ...otherOutputPaths] = Packaging.getBundleOutputPaths( bundleType, filename, packageName ); const rollupOutputOptions = getRollupOutputOptions( mainOutputPath, format, peerGlobals, bundle.global, bundleType ); console.log(`$&#123;chalk.bgYellow.black(' BUILDING ')&#125; $&#123;logKey&#125;`); try &#123; const result = await rollup(rollupConfig); await result.write(rollupOutputOptions); &#125; catch (error) &#123; console.log(`$&#123;chalk.bgRed.black(' OH NOES! ')&#125; $&#123;logKey&#125;\n`); handleRollupError(error); throw error; &#125; for (let i = 0; i &lt; otherOutputPaths.length; i++) &#123; await asyncCopyTo(mainOutputPath, otherOutputPaths[i]); &#125; console.log(`$&#123;chalk.bgGreen.black(' COMPLETE ')&#125; $&#123;logKey&#125;\n`);&#125; 上述关键的代码是const result = await rollup(rollupConfig);，可以看出这是通过 rollup 打包的，对于单个配置，它是遵循 Rollup 的构建规则的。其中 input 属性表示构建的入口 JS 文件地址，output.file 属性表示构建后的输出的 JS 文件地址，format 属性表示构建的格式，cjs 表示构建出来的文件遵循CommonJS 规范，es 表示构建出来的文件遵循ES Module 规范，umd 表示构建出来的文件遵循UMD 规范。 下面我们以配置文件的第一个react配置为例： 构建的入口 JS 文件地址： 1let resolvedEntry = require.resolve(bundle.entry); 沿着bundle.entry我们发现它的值为react（在scripts/rollup/bundles.js中），require.resolve用于查询文件的完整绝对路径，也就说react对应的真实入口路径是/**/**/react/packages/react/index.js，由此不难看出所有源码都在packages中： 构建后的输出的 JS 文件地址：12345const [mainOutputPath, ...otherOutputPaths] = Packaging.getBundleOutputPaths( bundleType, filename, packageName); 接下来我们看看Packaging.getBundleOutputPaths，在scripts/rollup/packaging.js中：1234567891011121314151617function getBundleOutputPaths(bundleType, filename, packageName) &#123; switch (bundleType) &#123; case NODE_DEV: case NODE_PROD: case NODE_PROFILING: return [`build/node_modules/$&#123;packageName&#125;/cjs/$&#123;filename&#125;`]; case UMD_DEV: case UMD_PROD: return [ `build/node_modules/$&#123;packageName&#125;/umd/$&#123;filename&#125;`, `build/dist/$&#123;filename&#125;`, ]; // ... default: throw new Error('Unknown bundle type.'); &#125;&#125; 从上面不难看出所有打包后的输出文件都在build，这就是为什么打包前先删除build文件了。 小结通过这一节的分析，我们可以了解到 React 的打包过程，也知道了不同作用和功能的 React 对应的入口以及最终编译生成的 JS 文件。 源码入口React 对象实际项目中，可以看到首先需要使用如下代码：1import React from 'react'; 这句代码做的就是引入了React核心源码模块。而我们在源码构建一节讲到 React 的核心入口文件是packages/react/index.js:1234567'use strict';const React = require('./src/React');// TODO: decide on the top-level export form.// This is hacky but makes it work with both Rollup and Jest.module.exports = React.default || React; 上述代码中执行import React from &#39;react&#39;时，其实引入的就是这里提供的对象。 这里需要说明一点：这里为什么会导出 React.default || React？（以下提到的插件都可以在源码中找到） React.default 用于 Jest 测试babel解析器将 es6 的 export、import等模块关键字转换成 commonjs 的规范，babel 转换 es6 的模块输出逻辑非常简单，即将所有输出都赋值给 exports。其中packages/react/src/React.js使用export default导出 React 对象，这里 babel 会将其转化exports.default = React，因此导入的结果其实是一个含 default 属性的对象，因此需要使用 React.default 来获取实际的 React 对象。 React 用于 Rolluprollup-plugin-node-resolve 插件可以解决 ES6 模块的查找导入，如果npm中的包以CommonJS模块的形式出现的，我们可以使用rollup-plugin-commonjs 将CommonJS模块转换为ES6来为Rollup获得兼容（即令(ES6)import === (CommonJS)require），导入的结果其实是不含 default 属性的对象，因此直接使用 React 来获取实际的 React 对象。 在这个入口 JS 的上方我们可以找到 React 的来源：const React = require(&#39;./src/React&#39;);，我们来看一下这块儿的实现，它定义在packages/react/src/React.js 中， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import ReactVersion from 'shared/ReactVersion';import &#123; REACT_ASYNC_MODE_TYPE, REACT_FRAGMENT_TYPE, REACT_PROFILER_TYPE, REACT_STRICT_MODE_TYPE, REACT_PLACEHOLDER_TYPE,&#125; from 'shared/ReactSymbols';import &#123;enableSuspense&#125; from 'shared/ReactFeatureFlags';import &#123;Component, PureComponent&#125; from './ReactBaseClasses';import &#123;createRef&#125; from './ReactCreateRef';import &#123;forEach, map, count, toArray, only&#125; from './ReactChildren';import &#123; createElement, createFactory, cloneElement, isValidElement,&#125; from './ReactElement';import &#123;createContext&#125; from './ReactContext';import &#123;lazy&#125; from './ReactLazy';import forwardRef from './forwardRef';import &#123; createElementWithValidation, createFactoryWithValidation, cloneElementWithValidation,&#125; from './ReactElementValidator';import ReactSharedInternals from './ReactSharedInternals';const React = &#123; Children: &#123; map, forEach, count, toArray, only, &#125;, createRef, Component, PureComponent, createContext, forwardRef, Fragment: REACT_FRAGMENT_TYPE, StrictMode: REACT_STRICT_MODE_TYPE, unstable_AsyncMode: REACT_ASYNC_MODE_TYPE, unstable_Profiler: REACT_PROFILER_TYPE, createElement: __DEV__ ? createElementWithValidation : createElement, cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement, createFactory: __DEV__ ? createFactoryWithValidation : createFactory, isValidElement: isValidElement, version: ReactVersion, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,&#125;;if (enableSuspense) &#123; React.Placeholder = REACT_PLACEHOLDER_TYPE; React.lazy = lazy;&#125;export default React; 上述就是我们 React 的庐山真面目，实际上它的内容是一个标准的 JSON 对象，这里 React 对象里面包含什么一目了然，比如我们常用的Component、PureComponent等，由此可以看出React核心内容只包括定义组件相关的内容和API。 渲染React 的定位是一个构建用户界面的JavaScript类库，它使用JavaScript语言开发UI组件，可以使用多种方式渲染这些组件，输出用户界面，很大程度上达到了跨平台的能力： We don’t make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code. 现在的 React 在以下几个方面都发挥着很不错的效果： React Web应用用户界面开发； React Native App用户界面开发； Node.js 服务端渲染； 在这些不同场景，渲染的主体很明显是不一样的，有诸如web应用的DOM渲染，React Native的原生View渲染，服务端字符串渲染等，要做到兼容适应多种不同渲染环境，很显然，React不能局限固定渲染UI的方式。 上一节我们讲到React核心内容只涉及如何定义组件，并不涉及具体的组件渲染（即输出用户界面），这需要引入额外渲染模块，下面以渲染React定义的组件为例： React DOM渲染模块：React DOM渲染模块：将React组件渲染为DOM，然后可以被浏览器处理呈现给用户，这就是通常在web应用中引入的react-dom模块：12345import React from 'react';import ReactDOM from 'react-dom';import App from './App';ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 上述代码中，App是使用React核心模块定义的组件，然后使用react-dom渲染模块提供的render方法将其渲染为DOM输出至页面。 React Native 渲染：：将React组件渲染为移动端原生View，在React Native应用中引入react-native模块，它提供相应渲染方法可以渲染React组件：1234import &#123; AppRegistry &#125; from 'react-native';import App from './src/app.js';AppRegistry.registerComponent('fuc', () =&gt; App); 上述代码中，App是React根组件，使用react-native渲染器的AppRegistry.registerComponent方法将其渲染为原生View。 React测试渲染：将React组件渲染为JSON树，用来完成Jest的快照测试，内容在react-test-renderer模块：12345678import ReactTestRenderer from 'react-test-renderer'; const renderer = ReactTestRenderer.create( &lt;Link page="https://www.facebook.com/"&gt;Facebook&lt;/Link&gt;); console.log(renderer.toJSON()); // &#123; type: 'a',// props: &#123; href: 'https://www.facebook.com/' &#125;,// children: [ 'Facebook' ] &#125; 小结那么至此，我们应该对 React 是什么有一个直观的认识，它本质上是含有诸多属性的JavaScript对象，它核心内容只涉及如何定义组件，具体的组件渲染（即输出用户界面），需要引入额外的渲染模块，渲染组件方式由环境决定，定义组件，组件状态管理，生命周期方法管理，组件更新等应该跨平台一致处理，不受渲染环境影响，这部分内容统一由调和器（Reconciler）处理，不同渲染器都会使用该模块。调和器主要作用就是在组件状态变更时，调用组件树各组件的render方法，渲染，卸载组件。至于 React 能做什么，它是怎么做的，我们会在后面的章节一一剖析它们。 基本概念在正式进入流程分析之前，我们先来了解一些 React 源码内部的基本概念，读懂这些有助于我们更好地理解整个流程。 ReactElement我们在写 React 组件时，通常会使用JSX来描述组件，经过babel（Facebook早期有提供自己的编译器，后来Babel发展为社区jsx语法的主要编译工具）编译成对应的React.createElement(type, props, children)形式。 将以下代码放到Babel官网上编译一下：1234567891011121314151617181920212223242526class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;header className="App-header"&gt; &lt;img src=&#123;logo&#125; className="App-logo" alt="logo" /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className="App-link" href="https://reactjs.org" target="_blank" rel="noopener noreferrer" &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;Hello /&gt; &lt;Inner text="heiheihei"&gt; &lt;div&gt;yoyoyo&lt;/div&gt; &lt;/Inner&gt; &lt;/div&gt; ); &#125;&#125; 经过Babel编译后：12345678910111213141516171819202122232425262728293031323334353637383940React.createElement( "div", &#123; className: "App" &#125;, React.createElement( "header", &#123; className: "App-header" &#125;, React.createElement("img", &#123; src: logo, className: "App-logo", alt: "logo" &#125;), React.createElement( "p", null, "Edit ", React.createElement( "code", null, "src/App.js" ), " and save to reload." ), React.createElement( "a", &#123; className: "App-link", href: "https://reactjs.org", target: "_blank", rel: "noopener noreferrer" &#125;, "Learn React" ) ), React.createElement(Hello, null), React.createElement( Inner, &#123; text: "heiheihei" &#125;, React.createElement( "div", null, "yoyoyo" ) )); 可以看出我们使用JSX来编写的组件会被编译成调用React.createElement的形式。如果组件里的DOM标签的首字母为大写的时候，这个标签（类 =&gt; 自定义组件类， 函数 =&gt; 无状态组件）则会被作为参数传递给createElement；如果DOM标签的首字母为小写，则将标签名（div, span, a 等html的 DOM标签）以字符串的形式传给createElement；如果是字符串或者空的话，则直接将字符串或者null当做参数传递给createElement。接下来我们React.createElement的源码。 React.createElement的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106export function createElement(type, config, children) &#123; let propName; // Reserved names are extracted const props = &#123;&#125;; let key = null; let ref = null; let self = null; let source = null; // 将参数赋给props对象 if (config != null) &#123; if (hasValidRef(config)) &#123; ref = config.ref; &#125; if (hasValidKey(config)) &#123; key = '' + config.key; &#125; self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object for (propName in config) &#123; // 跳过React保留的参数 if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; props[propName] = config[propName]; &#125; &#125; &#125; // 将子元素按照顺序赋给children的数组 // Children can be more than one argument, and those are transferred onto // the newly allocated props object. const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; if (__DEV__) &#123; if (Object.freeze) &#123; Object.freeze(childArray); &#125; &#125; props.children = childArray; &#125; // 对于默认的参数，判断是否有传入值，有的话直接将参数和对应的值赋给props，否则将参数和参数默认值赋给props // Resolve default props if (type &amp;&amp; type.defaultProps) &#123; const defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; if (__DEV__) &#123; if (key || ref) &#123; const displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type; if (key) &#123; defineKeyPropWarningGetter(props, displayName); &#125; if (ref) &#123; defineRefPropWarningGetter(props, displayName); &#125; &#125; &#125; return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );&#125;const ReactElement = function(type, key, ref, self, source, owner, props) &#123; const element = &#123; // Symbol类型的tag唯一标示这个对象是一个React Element类型 // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, &#125;; return element;&#125;; 我们可以看出createElement基本没做什么特别的处理，最终返回了一个ReactElement对象。ReactElement是描述DOM节点或component实例的字面级对象，ReactElement主要包含了对象类型标识（$$typeof）、DOM节点的类型（type）和属性（props）。 key type desc $$typeof Symbol &nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; Number 对象类型标识，用于判断当前Object属于哪一种类型的ReactElement type Function &nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; String &nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; Symbol &nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; Number &nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; Object 如果当前ReactElement是一个ReactComponent，那这里将是它对应的Constructor；而普通HTML标签，一般都是String props Object ReactElement上的所有属性，包含children这个特殊属性 ReactElement只是保存了DOM需要的数据，并没有对应的方法来实现React提供给我们的那些功能和特性。ReactElement主要分为DOM Elements和Component Elements两种，我们称这样的对象为ReactElement。 DOM Elements当节点的type属性为字符串时，它代表是普通的节点，如div，span：123456789101112&#123; type: 'button', props: &#123; className: 'button button-blue', children: &#123; type: 'b', props: &#123; children: 'OK!' &#125; &#125; &#125;&#125; Component Elements当节点的type属性为一个函数或一个类时，它代表自定义的节点：12345678910111213141516171819202122232425class Button extends React.Component &#123; render() &#123; const &#123; children, color &#125; = this.props; return &#123; type: 'button', props: &#123; className: 'button button-' + color, children: &#123; type: 'b', props: &#123; children: children &#125; &#125; &#125; &#125;; &#125;&#125;// Component Elements&#123; type: Button, props: &#123; color: 'blue', children: 'OK!' &#125;&#125; ReactClassReactClass就是我们平时写的Component组件(类或函数)，例如上面的Button类。ReactClass实例化后调用render方法可返回DOM Element。 ReactComponentReactComponent是基于ReactElement创建的一个对象，这个对象保存了ReactElement的数据的同时注入了一些方法，这些方法可以用来实现我们熟知的那些React的特性。 ReactRoot主要概念首次渲染渲染入口在 Web 项目中，如果我们要将应用渲染至页面，通常会用如下代码： 12345import React from 'react';import ReactDOM from 'react-dom';import App from './App'; // 应用根组件ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); // 应用挂载容器DOM 这里react-dom是浏览器端渲染React应用的模块，通过ReactDOM.render(component, mountNode)可以对自定义组件/原生DOM/字符串进行挂载。在React16中，虽然还是通过JSX编译得到一个虚拟DOM对象，但对这些虚拟DOM对象的再加工则是发生了翻天覆地的变化。我们需要追根溯底，看它是怎么一步步转换的。我们首先找到ReactDOM.render，源码在packages/react-dom/src/client/ReactDOM.js中，有三个类似的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const ReactDOM: Object = &#123; // 新API，未来代替render hydrate(element: React$Node, container: DOMContainer, callback: ?Function) &#123; // TODO: throw or warn if we couldn't hydrate? return legacyRenderSubtreeIntoContainer( null, element, container, true, callback, ); &#125;, // React15的重要API，逐渐退出舞台 render( element: React$Element&lt;any&gt;, // react组件对象，通常是项目根组件 container: DOMContainer, // id为root的那个dom callback: ?Function, // 回调函数 ) &#123; return legacyRenderSubtreeIntoContainer( null, element, container, false, callback, ); &#125;, // 将组件挂载到传入的 DOM 节点上（不稳定api） unstable_renderSubtreeIntoContainer( parentComponent: React$Component&lt;any, any&gt;, element: React$Element&lt;any&gt;, containerNode: DOMContainer, callback: ?Function, ) &#123; invariant( parentComponent != null &amp;&amp; ReactInstanceMap.has(parentComponent), 'parentComponent must be a valid React Component', ); return legacyRenderSubtreeIntoContainer( parentComponent, element, containerNode, false, callback, ); &#125;,&#125;; 这里ReactDOM.render/hydrate/unstable_renderSubtreeIntoContainer/unmountComponentAtNode都是legacyRenderSubtreeIntoContainer方法的加壳方法。因此ReactDOM.render实际调用了legacyRenderSubtreeIntoContainer，这是一个内部API。 渲染虚拟dom树legacyRenderSubtreeIntoContainer从字面可以看出它大致意思就是把虚拟的dom树渲染到真实的dom容器中，我们找到legacyRenderSubtreeIntoContainer方法，源码在packages/react-dom/src/client/ReactDOM.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 渲染组件的子组件树至父容器function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component&lt;any, any&gt;, // 父组件 这里为 null children: ReactNodeList, // element 虚拟dom树 container: DOMContainer, // html中的dom根对象 forceHydrate: boolean, // 服务器端渲染标识 这里为false callback: ?Function, // 回调函数 这里没有) &#123; // 对 container 进行校验 invariant( isValidContainer(container), 'Target container is not a DOM element.', ); if (__DEV__) &#123; // 开发模式render时进行检查并提供许多有用的警告和错误提示信息 topLevelUpdateWarnings(container); &#125; // 获取 root 对象 let root: Root = (container._reactRootContainer: any); if (!root) &#123; // 初次渲染时初始化 // 创建一个 FiberRoot对象 并将它缓存到DOM容器的_reactRootContainer属性 root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 forceHydrate, // 服务器端渲染标识 这里为false ); if (typeof callback === 'function') &#123; const originalCallback = callback; callback = function() &#123; const instance = DOMRenderer.getPublicRootInstance(root._internalRoot); originalCallback.call(instance); &#125;; &#125; // 初始化容器相关 // Initial mount should not be batched. DOMRenderer.unbatchedUpdates(() =&gt; &#123; if (parentComponent != null) &#123; // 向真实dom中挂载虚拟dom root.legacy_renderSubtreeIntoContainer( parentComponent, // 父组件 children, // 虚拟dom树 callback, // 回调函数 ); &#125; else &#123; root.render( children, // 虚拟dom树 callback // 回调函数 ); &#125; &#125;); &#125; else &#123; if (typeof callback === 'function') &#123; const originalCallback = callback; callback = function() &#123; const instance = DOMRenderer.getPublicRootInstance(root._internalRoot); originalCallback.call(instance); &#125;; &#125; if (parentComponent != null) &#123; root.legacy_renderSubtreeIntoContainer( parentComponent, // 父组件 children, // 虚拟dom树 callback, // 回调函数 ); &#125; else &#123; root.render( children, // 虚拟dom树 callback // 回调函数 ); &#125; &#125; // 返回根容器fiber树的根fiber实例 return DOMRenderer.getPublicRootInstance(root._internalRoot);&#125;// 源码在 packages/react-reconciler/src/ReactFiberReconciler.js 中export function getPublicRootInstance( container: OpaqueRoot,): React$Component&lt;any, any&gt; | PublicInstance | null &#123; // 获取fiber实例 const containerFiber = container.current; if (!containerFiber.child) &#123; return null; &#125; switch (containerFiber.child.tag) &#123; case HostComponent: return getPublicInstance(containerFiber.child.stateNode); default: return containerFiber.child.stateNode; &#125;&#125; 由此可见，legacyRenderSubtreeIntoContainer主要执行了以下几个操作：root：由legacyCreateRootFromDOMContainer生成，该函数会生成一个FiberRoot对象挂载到真实的dom根节点上，有了这个对象，执行该对象上的一些方法可以将虚拟dom变成dom树挂载到根节点上。DOMRenderer.unbatchedUpdates：DOMRenderer.unbatchedUpdates的回调执行root.legacy_renderSubtreeIntoContainer或root.render。root.legacy_renderSubtreeIntoContainer 和 root.render：如果有parentComponent，就执行root.render否则执行root.legacy_renderSubtreeIntoContainer。 root我们知道root是由legacyCreateRootFromDOMContainer生成的，我们找到legacyCreateRootFromDOMContainer函数，源码在packages/react-dom/src/client/ReactDOM.js中:1234567891011121314151617181920212223242526272829function legacyCreateRootFromDOMContainer( container: DOMContainer, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 forceHydrate: boolean, // 服务器端渲染标识 这里为false): Root &#123; const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // 是否需要服务器端渲染 if (!shouldHydrate) &#123; let warned = false; let rootSibling; while ((rootSibling = container.lastChild)) &#123; if (__DEV__) &#123; // ... &#125; // 将dom根节点清空 container.removeChild(rootSibling); &#125; &#125; if (__DEV__) &#123; // ... &#125; // Legacy roots are not async by default. const isAsync = false; return new ReactRoot( container, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync, // 是否异步模式，默认false shouldHydrate // 服务器端渲染标识 这里为false );&#125; 我们发现该函数实际上返回的是由构造函数ReactRoot创建的对象。其中如果在非ssr的情况下，将dom根节点清空。我们找到构造函数ReactRoot，源码在packages\react-dom\src\client\ReactDOM.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 构造函数function ReactRoot( container: Container, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync: boolean, // 是否异步模式，默认false hydrate: boolean // 服务器端渲染标识 这里为false) &#123; // FiberRoot 对象 const root = DOMRenderer.createContainer( container, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync, // 是否异步模式，默认false hydrate // 服务器端渲染标识 这里为false ); this._internalRoot = root;&#125;// 以下几个是原型方法// 渲染ReactRoot.prototype.render = function( children: ReactNodeList, // 虚拟dom树 callback: ?() =&gt; mixed, // 回调函数): Work &#123; const root = this._internalRoot; const work = new ReactWork(); callback = callback === undefined ? null : callback; if (__DEV__) &#123; warnOnInvalidCallback(callback, 'render'); &#125; if (callback !== null) &#123; work.then(callback); &#125; DOMRenderer.updateContainer( children, // 虚拟dom树 root, // FiberRoot 对象 null, // 父组件 这里为 null work._onCommit ); return work;&#125;;// 销毁组件ReactRoot.prototype.unmount = function(callback: ?() =&gt; mixed): Work &#123; // ...&#125;;ReactRoot.prototype.legacy_renderSubtreeIntoContainer = function( parentComponent: ?React$Component&lt;any, any&gt;, children: ReactNodeList, callback: ?() =&gt; mixed,): Work &#123; const root = this._internalRoot; const work = new ReactWork(); callback = callback === undefined ? null : callback; if (__DEV__) &#123; warnOnInvalidCallback(callback, 'render'); &#125; if (callback !== null) &#123; work.then(callback); &#125; DOMRenderer.updateContainer( children, // 虚拟dom树 root, // FiberRoot 对象 parentComponent, // 父组件 work._onCommit ); return work;&#125;;ReactRoot.prototype.createBatch = function(): Batch &#123; // ...&#125;; 可以看出构造函数ReactRoot有render、unmount、legacy_renderSubtreeIntoContainer等原型方法外，同时还声明了一个和fiber相关的_internalRoot属性。其中render和legacy_renderSubtreeIntoContainer原型方法都会去执行DOMRenderer.updateContainer方法更新容器内容，唯一差别就是第三个参数一个传null，一个传parentComponent。_internalRoot是由DOMRenderer.createContainer生成的。我们找到DOMRenderer.createContainer，源码在packages\react-reconciler\src\ReactFiberReconciler.js中：1234567891011export function createContainer( containerInfo: Container, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync: boolean, // 是否异步模式，默认false hydrate: boolean, // 服务器端渲染标识 这里为false): OpaqueRoot &#123; return createFiberRoot( containerInfo, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync, // 是否异步模式，默认false hydrate // 服务器端渲染标识 这里为false );&#125; 接下来我们看看createFiberRoot是怎么将一个真实DOM变成一个Fiber对象，我们找到createFiberRoot，源码在 packages\react-reconciler\src\ReactFiberReconciler.js 中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159export function createFiberRoot( containerInfo: any, // ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点 isAsync: boolean, // 是否异步模式，默认false hydrate: boolean, // 服务器端渲染标识 这里为false): FiberRoot &#123; // 创建初始根组件对应的fiber实例 const uninitializedFiber = createHostRootFiber(isAsync); let root; if (enableSchedulerTracing) &#123; root = (&#123; current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, interactionThreadID: unstable_getThreadID(), memoizedInteractions: new Set(), pendingInteractionMap: new Map(), &#125;: FiberRoot); &#125; else &#123; root = (&#123; current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, &#125;: BaseFiberRootProperties); &#125; uninitializedFiber.stateNode = root; return ((root: any): FiberRoot);&#125;// 源码在 packages\react-reconciler\src\ReactFiber.js 中// 返回一个初始根组件对应的fiber实例export function createHostRootFiber(isAsync: boolean): Fiber &#123; let mode = isAsync ? AsyncMode | StrictMode : NoContext; if (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123; // Always collect profile timings when DevTools are present. // This enables DevTools to start capturing timing at any point– // Without some nodes in the tree having empty base times. mode |= ProfileMode; &#125; // 创建 Fiber 实例 return createFiber( HostRoot, // 组件树根组件，可以嵌套 null, null, mode );&#125;// 源码在 packages\react-reconciler\src\ReactFiber.js 中// 创建 Fiber 实例const createFiber = function( tag: WorkTag, // 标记 fiber 类型 pendingProps: mixed, // 当前处理过程中的组件props对象 key: null | string, // 调和阶段，标识fiber，以检测是否可重用该fiber实例 mode: TypeOfMode,): Fiber &#123; // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors return new FiberNode(tag, pendingProps, key, mode);&#125;;// 源码在 packages\react-reconciler\src\ReactFiber.js 中function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode,) &#123; // Instance this.tag = tag; this.key = key; this.type = null; this.stateNode = null; // Fiber this.return = null; this.child = null; this.sibling = null; this.index = 0; this.ref = null; this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.firstContextDependency = null; this.mode = mode; // Effects this.effectTag = NoEffect; this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; this.expirationTime = NoWork; this.childExpirationTime = NoWork; this.alternate = null; if (enableProfilerTimer) &#123; this.actualDuration = 0; this.actualStartTime = -1; this.selfBaseDuration = 0; this.treeBaseDuration = 0; &#125; if (__DEV__) &#123; this._debugID = debugCounter++; this._debugSource = null; this._debugOwner = null; this._debugIsCurrentlyTiming = false; if (!hasBadMapPolyfill &amp;&amp; typeof Object.preventExtensions === 'function') &#123; Object.preventExtensions(this); &#125; &#125;&#125; 由此可知，react-dom渲染模块调用createContainer创建容器、根fiber实例、FiberRoot对象等。所有Fiber对象都是FiberNode的实例，它有许多种类型，通过tag来标识，其中内部有很多方法来生成Fiber对象： createFiberFromElement：type为类，无状态函数，元素标签名 createFiberFromFragment：type为React.Fragment createFiberFromText：在JSX中表现为字符串，数字 createFiberFromPortal：用于 createPortal createFiberRoot：用于ReactDOM.render的根节点 这里createFiberRoot就是创建了一个普通对象，里面current属性引用fiber对象，containerInfo属性引用ReactDOM.render(&lt;div/&gt;, container)的第二个参数，也就是一个元素节点，然后fiber对象的stateNode引用普通对象root。在React15中，stateNode应该是一个组件实例或真实DOM，最后返回普通对象stateNode。现在我们回顾下调用reactDOM.render传入的container，在执行过程中附加了哪些有用的东西：1234567container = &#123; // 就是我们传入的那个真实dom _reactRootContainer: &#123; // legacyCreateRootFromDOMContainer _internalRoot: &#123; // DOMRenderer.createContainer current:&#123;&#125; // new FiberNode &#125; &#125;&#125; unbatchedUpdates我们找到DOMRenderer.unbatchedUpdates，源码在packages\react-reconciler\src\ReactFiberScheduler.js中：123456789101112131415161718192021// 正在批量更新标识let isBatchingUpdates: boolean = false;// 未批量更新标识let isUnbatchingUpdates: boolean = false;// 非批量更新操作function unbatchedUpdates&lt;A, R&gt;(fn: (a: A) =&gt; R, a: A): R &#123; // 如果正在批量更新 if (isBatchingUpdates &amp;&amp; !isUnbatchingUpdates) &#123; // 未批量更新设为true isUnbatchingUpdates = true; try &#123; // 运行入参函数且返回执行结果 return fn(a); &#125; finally &#123; // 仍旧将未批量更新设为false isUnbatchingUpdates = false; &#125; &#125; // 不管是否在批量更新流程中，都执行入参函数 return fn(a);&#125; 由此可知unbatchedUpdates无论如何都会执行入参函数，其中isBatchingUpdates和isUnbatchingUpdates初始值都是false。DOMRenderer.unbatchedUpdates的回调执行root.legacy_renderSubtreeIntoContainer或root.render。 更新容器内容从legacyRenderSubtreeIntoContainer函数里可以看出，无论怎样判断，最终都会到root.legacy_renderSubtreeIntoContainer和root.render两个方法，而这两个方法的核心就是DOMRenderer.updateContainer，无非就是传不传父组件这点区别。我们找到DOMRenderer.updateContainer，源码在packages\react-reconciler\src\ReactFiberReconciler.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125export function updateContainer( element: ReactNodeList, // ReactDOM.render函数的第一个参数，泛指各种虚拟DOM container: OpaqueRoot, // ReactDOM.render函数的第二个参数，也就是一个元素节点 parentComponent: ?React$Component&lt;any, any&gt;, // parentComponent为之前的根组件，现在它为null callback: ?Function, // 回调函数): ExpirationTime &#123; // createFiberRoot中创建的fiber对象 const current = container.current; const currentTime = requestCurrentTime(); // 获取任务到期时间 const expirationTime = computeExpirationForFiber(currentTime, current); return updateContainerAtExpirationTime( element, // ReactDOM.render函数的第一个参数，泛指各种虚拟DOM container, // ReactDOM.render函数的第二个参数，也就是一个元素节点 parentComponent, // 父组件 expirationTime, // 任务到期时间 callback, // 回调函数 );&#125;// 源码在 packages\react-reconciler\src\ReactFiberScheduler.js 中// 计算fiber的到期时间function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) &#123; let expirationTime; if (expirationContext !== NoWork) &#123; // 显示设置过期上下文 expirationTime = expirationContext; &#125; else if (isWorking) &#123; if (isCommitting) &#123; // 在提交阶段的更新任务 // 需要明确设置同步优先级（Sync Priority） expirationTime = Sync; &#125; else &#123; // 在渲染阶段发生的更新任务 // 需要设置为下一次渲染时间的到期时间优先级 expirationTime = nextRenderExpirationTime; &#125; &#125; else &#123; // 不在任务执行阶段，需要计算新的过期时间 if (fiber.mode &amp; AsyncMode) &#123; if (isBatchingInteractiveUpdates) &#123; // This is an interactive update expirationTime = computeInteractiveExpiration(currentTime); &#125; else &#123; // 异步更新 expirationTime = computeAsyncExpiration(currentTime); &#125; // 如果我们正处于渲染树的中间, 请不要在已经呈现的相同过期时间内更新。 if (nextRoot !== null &amp;&amp; expirationTime === nextRenderExpirationTime) &#123; expirationTime += 1; &#125; &#125; else &#123; // 同步更新 expirationTime = Sync; &#125; &#125; if (isBatchingInteractiveUpdates) &#123; // This is an interactive update. Keep track of the lowest pending // interactive expiration time. This allows us to synchronously flush // all interactive updates when needed. if (expirationTime &gt; lowestPriorityPendingInteractiveExpirationTime) &#123; lowestPriorityPendingInteractiveExpirationTime = expirationTime; &#125; &#125; return expirationTime;&#125;// 根据渲染优先级更新domexport function updateContainerAtExpirationTime( element: ReactNodeList, // ReactDOM.render函数的第一个参数，泛指各种虚拟DOM container: OpaqueRoot, // ReactDOM.render函数的第二个参数，也就是一个元素节点 parentComponent: ?React$Component&lt;any, any&gt;, // parentComponent为之前的根组件，现在它为null expirationTime: ExpirationTime, // 期望的任务到期时间 callback: ?Function, // 回调函数) &#123; // TODO: If this is a nested container, this won't be the root. // 引用fiber对象 const current = container.current; if (__DEV__) &#123; // ... &#125; // 获得上下文对象 const context = getContextForSubtree(parentComponent); if (container.context === null) &#123; container.context = context; &#125; else &#123; container.pendingContext = context; &#125; // 下一步：schedule:安排, Root: 根, Update:更新 return scheduleRootUpdate( current, // fiber对象 element, // ReactDOM.render函数的第一个参数，泛指各种虚拟DOM expirationTime, // 期望的任务到期时间 callback // 回调函数 );&#125;// 源码在 packages\react-reconciler\src\ReactFiberReconciler.js 中// 获得上下文对象function getContextForSubtree( parentComponent: ?React$Component&lt;any, any&gt;,): Object &#123; if (!parentComponent) &#123; return emptyContextObject; &#125; const fiber = ReactInstanceMap.get(parentComponent); const parentContext = findCurrentUnmaskedContext(fiber); if (fiber.tag === ClassComponent) &#123; const Component = fiber.type; if (isLegacyContextProvider(Component)) &#123; return processChildContext(fiber, Component, parentContext); &#125; &#125; else if (fiber.tag === ClassComponentLazy) &#123; const Component = getResultFromResolvedThenable(fiber.type); if (isLegacyContextProvider(Component)) &#123; return processChildContext(fiber, Component, parentContext); &#125; &#125; return parentContext;&#125; updateContainer的源码很简单，通过computeExpirationForFiber获得计算优先级，然后丢给updateContainerAtExpirationTime，这里updateContainerAtExpirationTime其实相当于什么都没做，通过getContextForSubtree（这里getContextForSubtree因为一开始parentComponent是不存在的，于是返回一个空对象。注意，这个空对象可以重复使用，不用每次返回一个新的空对象，这是一个很好的优化）获得上下文对象，然后分配给container.context或container.pendingContext，最后一起丢给scheduleRootUpdate。 开始更新我们找到scheduleRootUpdate，源码在packages/react-reconciler/src/ReactFiberReconciler.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 进行根节点更新function scheduleRootUpdate( current: Fiber, // 引用fiber对象 element: ReactNodeList, // 虚拟dom树 expirationTime: ExpirationTime, // 任务到期时间 callback: ?Function, // 回调函数) &#123; if (__DEV__) &#123; // ... &#125; // 返回一个包含以上属性的update对象 const update = createUpdate(expirationTime); // Caution: React DevTools currently depends on this property // being called "element". // 将虚拟dom树放入payload update.payload = &#123;element&#125;; callback = callback === undefined ? null : callback; if (callback !== null) &#123; warningWithoutStack( typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback, ); update.callback = callback; &#125; // 开始队列更新 enqueueUpdate(current, update); // 调用调度器API：scheduleWork(...)来调度fiber任务 scheduleWork( current, // fiber实例 expirationTime // 任务到期时间 ); return expirationTime;&#125;// 创建一个包含以上属性的update对象export function createUpdate(expirationTime: ExpirationTime): Update&lt;*&gt; &#123; return &#123; expirationTime: expirationTime, tag: UpdateState, payload: null, callback: null, next: null, nextEffect: null, &#125;;&#125; scheduleRootUpdate是将用户的传参封装成一个update对象, 其中update对象有payload对象，它就是相当于React15中 的setState的第一个state传参，但现在payload中把children也放进去了。然后添加更新任务至fiber：enqueueUpdate(...)，现在我们找到enqueueUpdate，源码在packages/react-reconciler/src/ReactUpdateQueue.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125export function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) &#123; // alternate 主要用来保存更新过程中各版本更新队列，方便崩溃或冲突时回退 const alternate = fiber.alternate; // 创建两个独立的更新队列 let queue1; let queue2; if (alternate === null) &#123; // 只存在一个 fiber queue1 = fiber.updateQueue; queue2 = null; if (queue1 === null) &#123; // 如果不存在，则创建一个更新队列 queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState); &#125; &#125; else &#123; // 两个所有者 queue1 = fiber.updateQueue; queue2 = alternate.updateQueue; if (queue1 === null) &#123; if (queue2 === null) &#123; // 如果两个都不存在，则创建两个新的 queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState); queue2 = alternate.updateQueue = createUpdateQueue( alternate.memoizedState, ); &#125; else &#123; // queue1 不存在，queue2 存在，queue1 根据 queue2 创建 queue1 = fiber.updateQueue = cloneUpdateQueue(queue2); &#125; &#125; else &#123; if (queue2 === null) &#123; // queue2 不存在，queue1 存在，queue2 根据 queue1 创建 queue2 = alternate.updateQueue = cloneUpdateQueue(queue1); &#125; else &#123; // 全都有 &#125; &#125; &#125; if (queue2 === null || queue1 === queue2) &#123; // 只存在一个更新队列 appendUpdateToQueue(queue1, update); &#125; else &#123; // 如果任意更新队列为空，则需要将更新添加至两个更新队列 if (queue1.lastUpdate === null || queue2.lastUpdate === null) &#123; appendUpdateToQueue(queue1, update); appendUpdateToQueue(queue2, update); &#125; else &#123; // 如果2个更新队列均非空，则添加更新至第一个队列，并更新另一个队列的尾部更新项 appendUpdateToQueue(queue1, update); queue2.lastUpdate = update; &#125; &#125; if (__DEV__) &#123; if ( (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) &amp;&amp; (currentlyProcessingQueue === queue1 || (queue2 !== null &amp;&amp; currentlyProcessingQueue === queue2)) &amp;&amp; !didWarnUpdateInsideUpdate ) &#123; warningWithoutStack( false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.', ); didWarnUpdateInsideUpdate = true; &#125; &#125;&#125;// 创建一个更新队列export function createUpdateQueue&lt;State&gt;(baseState: State): UpdateQueue&lt;State&gt; &#123; const queue: UpdateQueue&lt;State&gt; = &#123; baseState, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null, &#125;; return queue;&#125;// clone 一个更新队列function cloneUpdateQueue&lt;State&gt;( currentQueue: UpdateQueue&lt;State&gt;,): UpdateQueue&lt;State&gt; &#123; const queue: UpdateQueue&lt;State&gt; = &#123; baseState: currentQueue.baseState, firstUpdate: currentQueue.firstUpdate, lastUpdate: currentQueue.lastUpdate, // TODO: With resuming, if we bail out and resuse the child tree, we should // keep these effects. firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null, &#125;; return queue;&#125;// 更新队列function appendUpdateToQueue&lt;State&gt;( queue: UpdateQueue&lt;State&gt;, update: Update&lt;State&gt;,) &#123; // Append the update to the end of the list. if (queue.lastUpdate === null) &#123; // Queue is empty queue.firstUpdate = queue.lastUpdate = update; &#125; else &#123; queue.lastUpdate.next = update; queue.lastUpdate = update; &#125;&#125; 这里enqueueUpdate是一个链表，然后根据fiber的状态创建一个或两个列队对象，再接下来调用调度器API：scheduleWork(...)来调度fiber任务，现在我们看一下如何处理更新的。 处理更新我们找到scheduleWork，源码在packages/react-reconciler/src/ReactFiberScheduler.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) &#123; // 记录调度器的执行状态 recordScheduleUpdate(); if (__DEV__) &#123; if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) &#123; const instance = fiber.stateNode; warnAboutInvalidUpdates(instance); &#125; &#125; const root = scheduleWorkToRoot(fiber, expirationTime); if (root === null) &#123; if ( __DEV__ &amp;&amp; (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) ) &#123; warnAboutUpdateOnUnmounted(fiber); &#125; return; &#125; if (enableSchedulerTracing) &#123; const interactions = __interactionsRef.current; if (interactions.size &gt; 0) &#123; const pendingInteractionMap = root.pendingInteractionMap; const pendingInteractions = pendingInteractionMap.get(expirationTime); if (pendingInteractions != null) &#123; interactions.forEach(interaction =&gt; &#123; if (!pendingInteractions.has(interaction)) &#123; // Update the pending async work count for previously unscheduled interaction. interaction.__count++; &#125; pendingInteractions.add(interaction); &#125;); &#125; else &#123; pendingInteractionMap.set(expirationTime, new Set(interactions)); // Update the pending async work count for the current interactions. interactions.forEach(interaction =&gt; &#123; interaction.__count++; &#125;); &#125; const subscriber = __subscriberRef.current; if (subscriber !== null) &#123; const threadID = computeThreadID( expirationTime, root.interactionThreadID, ); subscriber.onWorkScheduled(interactions, threadID); &#125; &#125; &#125; if ( !isWorking &amp;&amp; nextRenderExpirationTime !== NoWork &amp;&amp; expirationTime &lt; nextRenderExpirationTime ) &#123; // This is an interruption. (Used for performance tracking.) interruptedBy = fiber; resetStack(); &#125; markPendingPriorityLevel(root, expirationTime); if ( // If we're in the render phase, we don't need to schedule this root // for an update, because we'll do it before we exit... !isWorking || isCommitting || // ...unless this is a different root than the one we're rendering. nextRoot !== root ) &#123; const rootExpirationTime = root.expirationTime; requestWork(root, rootExpirationTime); &#125; if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) &#123; // Reset this back to zero so subsequent updates don't throw. nestedUpdateCount = 0; invariant( false, 'Maximum update depth exceeded. This can happen when a ' + 'component repeatedly calls setState inside ' + 'componentWillUpdate or componentDidUpdate. React limits ' + 'the number of nested updates to prevent infinite loops.', ); &#125;&#125;function scheduleWorkToRoot(fiber: Fiber, expirationTime): FiberRoot | null &#123; // 更新 fiber实例的过期时间 if ( fiber.expirationTime === NoWork || fiber.expirationTime &gt; expirationTime ) &#123; // 若fiber实例到期时间大于期望的任务到期时间，则更新fiber到期时间 fiber.expirationTime = expirationTime; &#125; let alternate = fiber.alternate; // 同时更新alternate fiber的到期时间 if ( alternate !== null &amp;&amp; (alternate.expirationTime === NoWork || alternate.expirationTime &gt; expirationTime) ) &#123; // 若alternate fiber到期时间大于期望的任务到期时间，则更新fiber到期时间 alternate.expirationTime = expirationTime; &#125; let node = fiber.return; // fiber.return 为空，说明到达组件树顶部 if (node === null &amp;&amp; fiber.tag === HostRoot) &#123; // 确保是组件树根组件并获取FiberRoot实例 return fiber.stateNode; &#125; while (node !== null) &#123; alternate = node.alternate; if ( node.childExpirationTime === NoWork || node.childExpirationTime &gt; expirationTime ) &#123; node.childExpirationTime = expirationTime; if ( alternate !== null &amp;&amp; (alternate.childExpirationTime === NoWork || alternate.childExpirationTime &gt; expirationTime) ) &#123; alternate.childExpirationTime = expirationTime; &#125; &#125; else if ( alternate !== null &amp;&amp; (alternate.childExpirationTime === NoWork || alternate.childExpirationTime &gt; expirationTime) ) &#123; alternate.childExpirationTime = expirationTime; &#125; if (node.return === null &amp;&amp; node.tag === HostRoot) &#123; return node.stateNode; &#125; node = node.return; &#125; return null;&#125; 这里scheduleWork主要进行虚拟DOM（fiber树）的更新。scheduleWork的最开头有一个recordScheduleUpdate方法，我们找到recordScheduleUpdate，源码在packages\react-reconciler\src\ReactDebugFiberPerf.js中：123456789101112131415export function recordScheduleUpdate(): void &#123; if (enableUserTimingAPI) &#123; // 全局变量，默认为true if (isCommitting) &#123; // 全局变量，默认为false, 没有进入分支 hasScheduledUpdateInCurrentCommit = true; &#125; // 全局变量，默认为null，没有没有进入分支 if ( currentPhase !== null &amp;&amp; currentPhase !== 'componentWillMount' &amp;&amp; currentPhase !== 'componentWillReceiveProps' ) &#123; hasScheduledUpdateInCurrentPhase = true; &#125; &#125;&#125; recordScheduleUpdate主要用来记录调度器的执行状态，如注释所示，它现在相当于什么都没有做。 requestWork123456789101112131415161718192021222324252627function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123; addRootToSchedule(root, expirationTime); if (isRendering) &#123; // Prevent reentrancy. Remaining work will be scheduled at the end of // the currently rendering batch. return; &#125; if (isBatchingUpdates) &#123; // Flush work at the end of the batch. if (isUnbatchingUpdates) &#123; // ...unless we're inside unbatchedUpdates, in which case we should // flush it now. nextFlushedRoot = root; nextFlushedExpirationTime = Sync; performWorkOnRoot(root, Sync, true); &#125; return; &#125; // TODO: Get rid of Sync and use current time? if (expirationTime === Sync) &#123; performSyncWork(); &#125; else &#123; scheduleCallbackWithExpirationTime(root, expirationTime); &#125;&#125; performWork12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function performWork(minExpirationTime: ExpirationTime, dl: Deadline | null) &#123; deadline = dl; // Keep working on roots until there's no more work, or until we reach // the deadline. findHighestPriorityRoot(); if (deadline !== null) &#123; recomputeCurrentRendererTime(); currentSchedulerTime = currentRendererTime; if (enableUserTimingAPI) &#123; const didExpire = nextFlushedExpirationTime &lt; currentRendererTime; const timeout = expirationTimeToMs(nextFlushedExpirationTime); stopRequestCallbackTimer(didExpire, timeout); &#125; while ( nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime) &amp;&amp; (!deadlineDidExpire || currentRendererTime &gt;= nextFlushedExpirationTime) ) &#123; performWorkOnRoot( nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime &gt;= nextFlushedExpirationTime, ); findHighestPriorityRoot(); recomputeCurrentRendererTime(); currentSchedulerTime = currentRendererTime; &#125; &#125; else &#123; while ( nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime) ) &#123; performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true); findHighestPriorityRoot(); &#125; &#125; // We're done flushing work. Either we ran out of time in this callback, // or there's no more work left with sufficient priority. // If we're inside a callback, set this to false since we just completed it. if (deadline !== null) &#123; callbackExpirationTime = NoWork; callbackID = null; &#125; // If there's work left over, schedule a new callback. if (nextFlushedExpirationTime !== NoWork) &#123; scheduleCallbackWithExpirationTime( ((nextFlushedRoot: any): FiberRoot), nextFlushedExpirationTime, ); &#125; // Clean-up. deadline = null; deadlineDidExpire = false; finishRendering();&#125; performWorkOnRoot123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function performWorkOnRoot( root: FiberRoot, expirationTime: ExpirationTime, isExpired: boolean,) &#123; invariant( !isRendering, 'performWorkOnRoot was called recursively. This error is likely caused ' + 'by a bug in React. Please file an issue.', ); isRendering = true; // Check if this is async work or sync/expired work. if (deadline === null || isExpired) &#123; // Flush work without yielding. // TODO: Non-yieldy work does not necessarily imply expired work. A renderer // may want to perform some work without yielding, but also without // requiring the root to complete (by triggering placeholders). let finishedWork = root.finishedWork; if (finishedWork !== null) &#123; // This root is already complete. We can commit it. completeRoot(root, finishedWork, expirationTime); &#125; else &#123; root.finishedWork = null; // If this root previously suspended, clear its existing timeout, since // we're about to try rendering again. const timeoutHandle = root.timeoutHandle; if (enableSuspense &amp;&amp; timeoutHandle !== noTimeout) &#123; root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above cancelTimeout(timeoutHandle); &#125; const isYieldy = false; renderRoot(root, isYieldy, isExpired); finishedWork = root.finishedWork; if (finishedWork !== null) &#123; // We've completed the root. Commit it. completeRoot(root, finishedWork, expirationTime); &#125; &#125; &#125; else &#123; // Flush async work. let finishedWork = root.finishedWork; if (finishedWork !== null) &#123; // This root is already complete. We can commit it. completeRoot(root, finishedWork, expirationTime); &#125; else &#123; root.finishedWork = null; // If this root previously suspended, clear its existing timeout, since // we're about to try rendering again. const timeoutHandle = root.timeoutHandle; if (enableSuspense &amp;&amp; timeoutHandle !== noTimeout) &#123; root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above cancelTimeout(timeoutHandle); &#125; const isYieldy = true; renderRoot(root, isYieldy, isExpired); finishedWork = root.finishedWork; if (finishedWork !== null) &#123; // We've completed the root. Check the deadline one more time // before committing. if (!shouldYield()) &#123; // Still time left. Commit the root. completeRoot(root, finishedWork, expirationTime); &#125; else &#123; // There's no time left. Mark this root as complete. We'll come // back and commit it later. root.finishedWork = finishedWork; &#125; &#125; &#125; &#125; isRendering = false;&#125; renderRoot123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291function renderRoot( root: FiberRoot, isYieldy: boolean, isExpired: boolean,): void &#123; invariant( !isWorking, 'renderRoot was called recursively. This error is likely caused ' + 'by a bug in React. Please file an issue.', ); isWorking = true; ReactCurrentOwner.currentDispatcher = Dispatcher; const expirationTime = root.nextExpirationTimeToWorkOn; // Check if we're starting from a fresh stack, or if we're resuming from // previously yielded work. if ( expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null ) &#123; // Reset the stack and start working from the root. resetStack(); nextRoot = root; nextRenderExpirationTime = expirationTime; nextUnitOfWork = createWorkInProgress( nextRoot.current, null, nextRenderExpirationTime, ); root.pendingCommitExpirationTime = NoWork; if (enableSchedulerTracing) &#123; // Reset this flag once we start rendering a new root or at a new priority. // This might indicate that suspended work has completed. // If not, the flag will be reset. nextRenderIncludesTimedOutPlaceholder = false; // Determine which interactions this batch of work currently includes, // So that we can accurately attribute time spent working on it, // And so that cascading work triggered during the render phase will be associated with it. const interactions: Set&lt;Interaction&gt; = new Set(); root.pendingInteractionMap.forEach( (scheduledInteractions, scheduledExpirationTime) =&gt; &#123; if (scheduledExpirationTime &lt;= expirationTime) &#123; scheduledInteractions.forEach(interaction =&gt; interactions.add(interaction), ); &#125; &#125;, ); // Store the current set of interactions on the FiberRoot for a few reasons: // We can re-use it in hot functions like renderRoot() without having to recalculate it. // We will also use it in commitWork() to pass to any Profiler onRender() hooks. // This also provides DevTools with a way to access it when the onCommitRoot() hook is called. root.memoizedInteractions = interactions; if (interactions.size &gt; 0) &#123; const subscriber = __subscriberRef.current; if (subscriber !== null) &#123; const threadID = computeThreadID( expirationTime, root.interactionThreadID, ); try &#123; subscriber.onWorkStarted(interactions, threadID); &#125; catch (error) &#123; // Work thrown by an interaction tracing subscriber should be rethrown, // But only once it's safe (to avoid leaveing the scheduler in an invalid state). // Store the error for now and we'll re-throw in finishRendering(). if (!hasUnhandledError) &#123; hasUnhandledError = true; unhandledError = error; &#125; &#125; &#125; &#125; &#125; &#125; let prevInteractions: Set&lt;Interaction&gt; = (null: any); if (enableSchedulerTracing) &#123; // We're about to start new traced work. // Restore pending interactions so cascading work triggered during the render phase will be accounted for. prevInteractions = __interactionsRef.current; __interactionsRef.current = root.memoizedInteractions; &#125; let didFatal = false; startWorkLoopTimer(nextUnitOfWork); do &#123; try &#123; workLoop(isYieldy); &#125; catch (thrownValue) &#123; if (nextUnitOfWork === null) &#123; // This is a fatal error. didFatal = true; onUncaughtError(thrownValue); &#125; else &#123; if (__DEV__) &#123; // Reset global debug state // We assume this is defined in DEV (resetCurrentlyProcessingQueue: any)(); &#125; const failedUnitOfWork: Fiber = nextUnitOfWork; if (__DEV__ &amp;&amp; replayFailedUnitOfWorkWithInvokeGuardedCallback) &#123; replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy); &#125; // TODO: we already know this isn't true in some cases. // At least this shows a nicer error message until we figure out the cause. // https://github.com/facebook/react/issues/12449#issuecomment-386727431 invariant( nextUnitOfWork !== null, 'Failed to replay rendering after an error. This ' + 'is likely caused by a bug in React. Please file an issue ' + 'with a reproducing case to help us find it.', ); const sourceFiber: Fiber = nextUnitOfWork; let returnFiber = sourceFiber.return; if (returnFiber === null) &#123; // This is the root. The root could capture its own errors. However, // we don't know if it errors before or after we pushed the host // context. This information is needed to avoid a stack mismatch. // Because we're not sure, treat this as a fatal error. We could track // which phase it fails in, but doesn't seem worth it. At least // for now. didFatal = true; onUncaughtError(thrownValue); &#125; else &#123; throwException( root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime, ); nextUnitOfWork = completeUnitOfWork(sourceFiber); continue; &#125; &#125; &#125; break; &#125; while (true); if (enableSchedulerTracing) &#123; // Traced work is done for now; restore the previous interactions. __interactionsRef.current = prevInteractions; &#125; // We're done performing work. Time to clean up. isWorking = false; ReactCurrentOwner.currentDispatcher = null; resetContextDependences(); // Yield back to main thread. if (didFatal) &#123; const didCompleteRoot = false; stopWorkLoopTimer(interruptedBy, didCompleteRoot); interruptedBy = null; // There was a fatal error. if (__DEV__) &#123; resetStackAfterFatalErrorInDev(); &#125; // `nextRoot` points to the in-progress root. A non-null value indicates // that we're in the middle of an async render. Set it to null to indicate // there's no more work to be done in the current batch. nextRoot = null; onFatal(root); return; &#125; if (nextUnitOfWork !== null) &#123; // There's still remaining async work in this tree, but we ran out of time // in the current frame. Yield back to the renderer. Unless we're // interrupted by a higher priority update, we'll continue later from where // we left off. const didCompleteRoot = false; stopWorkLoopTimer(interruptedBy, didCompleteRoot); interruptedBy = null; onYield(root); return; &#125; // We completed the whole tree. const didCompleteRoot = true; stopWorkLoopTimer(interruptedBy, didCompleteRoot); const rootWorkInProgress = root.current.alternate; invariant( rootWorkInProgress !== null, 'Finished root should have a work-in-progress. This error is likely ' + 'caused by a bug in React. Please file an issue.', ); // `nextRoot` points to the in-progress root. A non-null value indicates // that we're in the middle of an async render. Set it to null to indicate // there's no more work to be done in the current batch. nextRoot = null; interruptedBy = null; if (nextRenderDidError) &#123; // There was an error if (hasLowerPriorityWork(root, expirationTime)) &#123; // There's lower priority work. If so, it may have the effect of fixing // the exception that was just thrown. Exit without committing. This is // similar to a suspend, but without a timeout because we're not waiting // for a promise to resolve. React will restart at the lower // priority level. markSuspendedPriorityLevel(root, expirationTime); const suspendedExpirationTime = expirationTime; const rootExpirationTime = root.expirationTime; onSuspend( root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1, // Indicates no timeout ); return; &#125; else if ( // There's no lower priority work, but we're rendering asynchronously. // Synchronsouly attempt to render the same level one more time. This is // similar to a suspend, but without a timeout because we're not waiting // for a promise to resolve. !root.didError &amp;&amp; !isExpired ) &#123; root.didError = true; const suspendedExpirationTime = (root.nextExpirationTimeToWorkOn = expirationTime); const rootExpirationTime = (root.expirationTime = Sync); onSuspend( root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1, // Indicates no timeout ); return; &#125; &#125; if (enableSuspense &amp;&amp; !isExpired &amp;&amp; nextLatestAbsoluteTimeoutMs !== -1) &#123; // The tree was suspended. if (enableSchedulerTracing) &#123; nextRenderIncludesTimedOutPlaceholder = true; &#125; const suspendedExpirationTime = expirationTime; markSuspendedPriorityLevel(root, suspendedExpirationTime); // Find the earliest uncommitted expiration time in the tree, including // work that is suspended. The timeout threshold cannot be longer than // the overall expiration. const earliestExpirationTime = findEarliestOutstandingPriorityLevel( root, expirationTime, ); const earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime); if (earliestExpirationTimeMs &lt; nextLatestAbsoluteTimeoutMs) &#123; nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs; &#125; // Subtract the current time from the absolute timeout to get the number // of milliseconds until the timeout. In other words, convert an absolute // timestamp to a relative time. This is the value that is passed // to `setTimeout`. const currentTimeMs = expirationTimeToMs(requestCurrentTime()); let msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs; msUntilTimeout = msUntilTimeout &lt; 0 ? 0 : msUntilTimeout; // TODO: Account for the Just Noticeable Difference const rootExpirationTime = root.expirationTime; onSuspend( root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, msUntilTimeout, ); return; &#125; // Ready to commit. onComplete(root, rootWorkInProgress, expirationTime);&#125; completeRoot1234567891011121314151617181920212223242526272829303132333435363738function completeRoot( root: FiberRoot, finishedWork: Fiber, expirationTime: ExpirationTime,): void &#123; // Check if there's a batch that matches this expiration time. const firstBatch = root.firstBatch; if (firstBatch !== null &amp;&amp; firstBatch._expirationTime &lt;= expirationTime) &#123; if (completedBatches === null) &#123; completedBatches = [firstBatch]; &#125; else &#123; completedBatches.push(firstBatch); &#125; if (firstBatch._defer) &#123; // This root is blocked from committing by a batch. Unschedule it until // we receive another update. root.finishedWork = finishedWork; root.expirationTime = NoWork; return; &#125; &#125; // Commit the root. root.finishedWork = null; // Check if this is a nested update (a sync update scheduled during the // commit phase). if (root === lastCommittedRootDuringThisBatch) &#123; // If the next root is the same as the previous root, this is a nested // update. To prevent an infinite loop, increment the nested update count. nestedUpdateCount++; &#125; else &#123; // Reset whenever we switch roots. lastCommittedRootDuringThisBatch = root; nestedUpdateCount = 0; &#125; commitRoot(root, finishedWork);&#125; 提交更新处理完更新后需要确认提交更新至渲染模块，然后渲染模块才能将更新渲染至DOM。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342function commitRoot(root: FiberRoot, finishedWork: Fiber): void &#123; isWorking = true; isCommitting = true; startCommitTimer(); invariant( root.current !== finishedWork, 'Cannot commit the same tree as before. This is probably a bug ' + 'related to the return field. This error is likely caused by a bug ' + 'in React. Please file an issue.', ); const committedExpirationTime = root.pendingCommitExpirationTime; invariant( committedExpirationTime !== NoWork, 'Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.', ); root.pendingCommitExpirationTime = NoWork; // Update the pending priority levels to account for the work that we are // about to commit. This needs to happen before calling the lifecycles, since // they may schedule additional updates. const updateExpirationTimeBeforeCommit = finishedWork.expirationTime; const childExpirationTimeBeforeCommit = finishedWork.childExpirationTime; const earliestRemainingTimeBeforeCommit = updateExpirationTimeBeforeCommit === NoWork || (childExpirationTimeBeforeCommit !== NoWork &amp;&amp; childExpirationTimeBeforeCommit &lt; updateExpirationTimeBeforeCommit) ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit; markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit); let prevInteractions: Set&lt;Interaction&gt; = (null: any); if (enableSchedulerTracing) &#123; // Restore any pending interactions at this point, // So that cascading work triggered during the render phase will be accounted for. prevInteractions = __interactionsRef.current; __interactionsRef.current = root.memoizedInteractions; &#125; // Reset this to null before calling lifecycles ReactCurrentOwner.current = null; let firstEffect; if (finishedWork.effectTag &gt; PerformedWork) &#123; // A fiber's effect list consists only of its children, not itself. So if // the root has an effect, we need to add it to the end of the list. The // resulting list is the set that would belong to the root's parent, if // it had one; that is, all the effects in the tree including the root. if (finishedWork.lastEffect !== null) &#123; finishedWork.lastEffect.nextEffect = finishedWork; firstEffect = finishedWork.firstEffect; &#125; else &#123; firstEffect = finishedWork; &#125; &#125; else &#123; // There is no effect on the root. firstEffect = finishedWork.firstEffect; &#125; prepareForCommit(root.containerInfo); // Invoke instances of getSnapshotBeforeUpdate before mutation. nextEffect = firstEffect; startCommitSnapshotEffectsTimer(); while (nextEffect !== null) &#123; let didError = false; let error; if (__DEV__) &#123; invokeGuardedCallback(null, commitBeforeMutationLifecycles, null); if (hasCaughtError()) &#123; didError = true; error = clearCaughtError(); &#125; &#125; else &#123; try &#123; commitBeforeMutationLifecycles(); &#125; catch (e) &#123; didError = true; error = e; &#125; &#125; if (didError) &#123; invariant( nextEffect !== null, 'Should have next effect. This error is likely caused by a bug ' + 'in React. Please file an issue.', ); captureCommitPhaseError(nextEffect, error); // Clean-up if (nextEffect !== null) &#123; nextEffect = nextEffect.nextEffect; &#125; &#125; &#125; stopCommitSnapshotEffectsTimer(); if (enableProfilerTimer) &#123; // Mark the current commit time to be shared by all Profilers in this batch. // This enables them to be grouped later. recordCommitTime(); &#125; // Commit all the side-effects within a tree. We'll do this in two passes. // The first pass performs all the host insertions, updates, deletions and // ref unmounts. nextEffect = firstEffect; startCommitHostEffectsTimer(); while (nextEffect !== null) &#123; let didError = false; let error; if (__DEV__) &#123; invokeGuardedCallback(null, commitAllHostEffects, null); if (hasCaughtError()) &#123; didError = true; error = clearCaughtError(); &#125; &#125; else &#123; try &#123; commitAllHostEffects(); &#125; catch (e) &#123; didError = true; error = e; &#125; &#125; if (didError) &#123; invariant( nextEffect !== null, 'Should have next effect. This error is likely caused by a bug ' + 'in React. Please file an issue.', ); captureCommitPhaseError(nextEffect, error); // Clean-up if (nextEffect !== null) &#123; nextEffect = nextEffect.nextEffect; &#125; &#125; &#125; stopCommitHostEffectsTimer(); resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after // the first pass of the commit phase, so that the previous tree is still // current during componentWillUnmount, but before the second pass, so that // the finished work is current during componentDidMount/Update. root.current = finishedWork; // In the second pass we'll perform all life-cycles and ref callbacks. // Life-cycles happen as a separate pass so that all placements, updates, // and deletions in the entire tree have already been invoked. // This pass also triggers any renderer-specific initial effects. nextEffect = firstEffect; startCommitLifeCyclesTimer(); while (nextEffect !== null) &#123; let didError = false; let error; if (__DEV__) &#123; invokeGuardedCallback( null, commitAllLifeCycles, null, root, committedExpirationTime, ); if (hasCaughtError()) &#123; didError = true; error = clearCaughtError(); &#125; &#125; else &#123; try &#123; commitAllLifeCycles(root, committedExpirationTime); &#125; catch (e) &#123; didError = true; error = e; &#125; &#125; if (didError) &#123; invariant( nextEffect !== null, 'Should have next effect. This error is likely caused by a bug ' + 'in React. Please file an issue.', ); captureCommitPhaseError(nextEffect, error); if (nextEffect !== null) &#123; nextEffect = nextEffect.nextEffect; &#125; &#125; &#125; isCommitting = false; isWorking = false; stopCommitLifeCyclesTimer(); stopCommitTimer(); onCommitRoot(finishedWork.stateNode); if (__DEV__ &amp;&amp; ReactFiberInstrumentation.debugTool) &#123; ReactFiberInstrumentation.debugTool.onCommitWork(finishedWork); &#125; const updateExpirationTimeAfterCommit = finishedWork.expirationTime; const childExpirationTimeAfterCommit = finishedWork.childExpirationTime; const earliestRemainingTimeAfterCommit = updateExpirationTimeAfterCommit === NoWork || (childExpirationTimeAfterCommit !== NoWork &amp;&amp; childExpirationTimeAfterCommit &lt; updateExpirationTimeAfterCommit) ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit; if (earliestRemainingTimeAfterCommit === NoWork) &#123; // If there's no remaining work, we can clear the set of already failed // error boundaries. legacyErrorBoundariesThatAlreadyFailed = null; &#125; onCommit(root, earliestRemainingTimeAfterCommit); if (enableSchedulerTracing) &#123; __interactionsRef.current = prevInteractions; let subscriber; try &#123; subscriber = __subscriberRef.current; if (subscriber !== null &amp;&amp; root.memoizedInteractions.size &gt; 0) &#123; const threadID = computeThreadID( committedExpirationTime, root.interactionThreadID, ); subscriber.onWorkStopped(root.memoizedInteractions, threadID); &#125; &#125; catch (error) &#123; // It's not safe for commitRoot() to throw. // Store the error for now and we'll re-throw in finishRendering(). if (!hasUnhandledError) &#123; hasUnhandledError = true; unhandledError = error; &#125; &#125; finally &#123; if (!nextRenderIncludesTimedOutPlaceholder) &#123; // Clear completed interactions from the pending Map. // Unless the render was suspended or cascading work was scheduled, // In which case– leave pending interactions until the subsequent render. const pendingInteractionMap = root.pendingInteractionMap; pendingInteractionMap.forEach( (scheduledInteractions, scheduledExpirationTime) =&gt; &#123; // Only decrement the pending interaction count if we're done. // If there's still work at the current priority, // That indicates that we are waiting for suspense data. if ( earliestRemainingTimeAfterCommit === NoWork || scheduledExpirationTime &lt; earliestRemainingTimeAfterCommit ) &#123; pendingInteractionMap.delete(scheduledExpirationTime); scheduledInteractions.forEach(interaction =&gt; &#123; interaction.__count--; if (subscriber !== null &amp;&amp; interaction.__count === 0) &#123; try &#123; subscriber.onInteractionScheduledWorkCompleted(interaction); &#125; catch (error) &#123; // It's not safe for commitRoot() to throw. // Store the error for now and we'll re-throw in finishRendering(). if (!hasUnhandledError) &#123; hasUnhandledError = true; unhandledError = error; &#125; &#125; &#125; &#125;); &#125; &#125;, ); &#125; &#125; &#125;&#125;// 循环执行提交更新function commitAllHostEffects() &#123; while (nextEffect !== null) &#123; if (__DEV__) &#123; ReactCurrentFiber.setCurrentFiber(nextEffect); &#125; recordEffect(); const effectTag = nextEffect.effectTag; if (effectTag &amp; ContentReset) &#123; commitResetTextContent(nextEffect); &#125; if (effectTag &amp; Ref) &#123; const current = nextEffect.alternate; if (current !== null) &#123; commitDetachRef(current); &#125; &#125; // The following switch statement is only concerned about placement, // updates, and deletions. To avoid needing to add a case for every // possible bitmap value, we remove the secondary effects from the // effect tag and switch on that value. let primaryEffectTag = effectTag &amp; (Placement | Update | Deletion); switch (primaryEffectTag) &#123; case Placement: &#123; commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is inserted, before // any life-cycles like componentDidMount gets called. // TODO: findDOMNode doesn't rely on this any more but isMounted // does and isMounted is deprecated anyway so we should be able // to kill this. nextEffect.effectTag &amp;= ~Placement; break; &#125; case PlacementAndUpdate: &#123; // Placement commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is inserted, before // any life-cycles like componentDidMount gets called. nextEffect.effectTag &amp;= ~Placement; // Update const current = nextEffect.alternate; commitWork(current, nextEffect); break; &#125; case Update: &#123; const current = nextEffect.alternate; commitWork(current, nextEffect); break; &#125; case Deletion: &#123; commitDeletion(nextEffect); break; &#125; &#125; nextEffect = nextEffect.nextEffect; &#125; if (__DEV__) &#123; ReactCurrentFiber.resetCurrentFiber(); &#125;&#125; 提交更新是最后确认更新组件的阶段，现在我们看一下提交更新的主要逻辑：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function commitWork(current: Fiber | null, finishedWork: Fiber): void &#123; if (!supportsMutation) &#123; commitContainer(finishedWork); return; &#125; switch (finishedWork.tag) &#123; case ClassComponent: case ClassComponentLazy: &#123; return; &#125; case HostComponent: &#123; const instance: Instance = finishedWork.stateNode; if (instance != null) &#123; // Commit the work prepared earlier. const newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps // as the newProps. The updatePayload will contain the real change in // this case. const oldProps = current !== null ? current.memoizedProps : newProps; const type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components. const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any); finishedWork.updateQueue = null; if (updatePayload !== null) &#123; commitUpdate( instance, updatePayload, type, oldProps, newProps, finishedWork, ); &#125; &#125; return; &#125; case HostText: &#123; invariant( finishedWork.stateNode !== null, 'This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.', ); const textInstance: TextInstance = finishedWork.stateNode; const newText: string = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps // as the newProps. The updatePayload will contain the real change in // this case. const oldText: string = current !== null ? current.memoizedProps : newText; commitTextUpdate(textInstance, oldText, newText); return; &#125; case HostRoot: &#123; return; &#125; case Profiler: &#123; return; &#125; case PlaceholderComponent: &#123; return; &#125; default: &#123; invariant( false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.', ); &#125; &#125;&#125; 小结至此首次渲染的执行流程为：ReactDOM.render（渲染入口） =&gt; legacyRenderSubtreeIntoContainer（把虚拟的dom树渲染到真实的dom容器中） =&gt; DOMRenderer.updateContainer（更新容器内容） =&gt; scheduleRootUpdate（开始更新） =&gt; scheduleWork（处理更新） =&gt; commitWork（提交更新） 高级指南插槽(Portals)Portals 提供了一种很好的方法，将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。 React Fiber React Fiber 并不是所谓的纤程（微线程、协程），而是一种基于浏览器的单线程调度算法。 我们都知道浏览器渲染引擎是单线程的，在 React15.x 及之前版本，从 setState 开始到渲染完成整个过程是不受控制且连续不中断完成的，由于该过程将会占用整个线程，则其他任务都会被阻塞，如样式计算、界面布局以及许多情况下的绘制等。如果需要渲染的是一个很大、层级很深的组件，这可能就会使用户感觉明显卡顿，比如更新一个组件需要1毫秒，如果有200个组件要更新，那就需要200毫秒，在这200毫秒的更新过程中，浏览器唯一的主线程在专心运行更新操作，无暇去做其他任何事情。想象一下，在这200毫秒内，用户往一个input元素中输入点什么，敲击键盘也不会立即获得响应，虽然渲染输入按键结果是浏览器主线程的工作，但是浏览器主线程被React占用，抽不出空，最后的结果就是用户敲了按键看不到反应，等React更新过程结束之后，咔咔咔那些按键一下子出现在input元素里了，这个版本的调和器可以称为栈调和器（Stack Reconciler）。Stack Reconcilier 的主要缺陷就是不能暂停渲染任务，也不能切分任务，更无法有效平衡组件更新渲染与动画相关任务间的执行顺序（即不能划分任务优先级），这样就很有可能导致重要任务卡顿，动画掉帧等问题。 为了解决这个问题，React 团队经过两年多的努力，提出了一个更先进的调和器，它允许渲染过程分段完成，而不必一次性完成，在渲染期间可返回到主线程控制执行其他任务。这是通过计算部分组件树的变更，并暂停渲染更新，询问主线程是否有更高需求的绘制或者更新任务需要执行，这些高需求的任务完成后再重新渲染。这一切的实现是在代码层引入了一个新的数据结构：Fiber对象，每一个组件实例对应有一个fiber实例，此fiber实例负责管理组件实例的更新，渲染任务及与其他fiber实例的通信，这个先进的调和器叫做纤维调和器（Fiber Reconciler），它提供的新功能主要有：一：把可中断的任务拆分成小任务；二：可重用各分阶段任务，对正在做的工作调整优先次序；三：可以在父子组件任务间前进后退切换任务，以支持React执行过程中的布局刷新；四：支持 render 方法返回多个元素；五：对异常边界处理提供了更好的支持； 调度任务（scheduleWork）前面提到 Fiber 可以异步实现不同优先级任务的协调执行，目前在 JavaScript 中也提供了这种方式，在新版主流浏览器有两个可用API：requestIdleCallback 和 requestAnimationFrame：requestIdleCallback：在线程空闲时调度执行低优先级函数。requestAnimationFrame：在下一个动画帧调度执行高优先级函数。 一般网页线程执行任务时会以帧的形式划分，大部分网页控制在30-60帧是不会影响用户体验的；在两个执行帧之间，主线程通常会有一小段空闲时间，requestIdleCallback可以在这个空闲期（Idle Period）调用空闲期回调（Idle Callback），执行一些任务。 而 Fiber 所做的就是需要分解渲染任务，根据优先级使用API调度，异步执行指定任务。低优先级任务由 requestIdleCallback 处理；高优先级任务，如动画相关的由 requestAnimationFrame 处理；requestIdleCallback 可以在多个空闲期调用空闲期回调，执行任务；requestIdleCallback 方法提供 deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞UI渲染而导致掉帧； 现在我们来看一下 React 调度任务实现的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442// TODO: 目前，只有一个优先级别，Deferred。未来将增加额外的优先级var DEFERRED_TIMEOUT = 5000;// 回调被储存为一个双向循环链表var firstCallbackNode = null;// 是否在执行工作var isPerformingWork = false;var isHostCallbackScheduled = false;var hasNativePerformanceNow = typeof performance === 'object' &amp;&amp; typeof performance.now === 'function';var timeRemaining;if (hasNativePerformanceNow) &#123; timeRemaining = function() &#123; // We assume that if we have a performance timer that the rAF callback // gets a performance timer value. Not sure if this is always true. var remaining = getFrameDeadline() - performance.now(); // 计算得到当前帧运行剩余时间 return remaining &gt; 0 ? remaining : 0; &#125;;&#125; else &#123; timeRemaining = function() &#123; // Fallback to Date.now() var remaining = getFrameDeadline() - Date.now(); // 计算得到当前帧运行剩余时间 return remaining &gt; 0 ? remaining : 0; &#125;;&#125;var deadlineObject = &#123; timeRemaining, didTimeout: false,&#125;;function ensureHostCallbackIsScheduled() &#123; // 正在执行工作 if (isPerformingWork) &#123; return; &#125; // 使用列表中最先超时的回调 var timesOutAt = firstCallbackNode.timesOutAt; if (!isHostCallbackScheduled) &#123; isHostCallbackScheduled = true; &#125; else &#123; // 取消回调 cancelCallback(); &#125; requestCallback(flushWork, timesOutAt);&#125;// 刷新第一次回调function flushFirstCallback(node) &#123; var flushedNode = firstCallbackNode; // 在调用回调之前从列表中移除该节点。这样，即使回调抛出, 列表也处于一致状态。 var next = firstCallbackNode.next; if (firstCallbackNode === next) &#123; // 这是列表中的最后一个回调。 firstCallbackNode = null; next = null; &#125; else &#123; var previous = firstCallbackNode.previous; firstCallbackNode = previous.next = next; next.previous = previous; &#125; flushedNode.next = flushedNode.previous = null; // 现在调用回调是安全的。 var callback = flushedNode.callback; callback(deadlineObject);&#125;function flushWork(didTimeout) &#123; isPerformingWork = true; deadlineObject.didTimeout = didTimeout; try &#123; if (didTimeout) &#123; // Flush all the timed out callbacks without yielding. while (firstCallbackNode !== null) &#123; // Read the current time. Flush all the callbacks that expire at or // earlier than that time. Then read the current time again and repeat. // This optimizes for as few performance.now calls as possible. var currentTime = getCurrentTime(); if (firstCallbackNode.timesOutAt &lt;= currentTime) &#123; do &#123; flushFirstCallback(); &#125; while ( firstCallbackNode !== null &amp;&amp; firstCallbackNode.timesOutAt &lt;= currentTime ); continue; &#125; break; &#125; &#125; else &#123; // Keep flushing callbacks until we run out of time in the frame. if (firstCallbackNode !== null) &#123; do &#123; flushFirstCallback(); &#125; while ( firstCallbackNode !== null &amp;&amp; getFrameDeadline() - getCurrentTime() &gt; 0 ); &#125; &#125; &#125; finally &#123; isPerformingWork = false; if (firstCallbackNode !== null) &#123; // There's still work remaining. Request another callback. ensureHostCallbackIsScheduled(firstCallbackNode); &#125; else &#123; isHostCallbackScheduled = false; &#125; &#125;&#125;// 调度任务，这是一个不稳定 apifunction unstable_scheduleWork(callback, options) &#123; var currentTime = getCurrentTime(); var timesOutAt; if ( options !== undefined &amp;&amp; options !== null &amp;&amp; options.timeout !== null &amp;&amp; options.timeout !== undefined ) &#123; // 根据传入的 timeout 计算超时 timesOutAt = currentTime + options.timeout; &#125; else &#123; // 使用默认常量计算超时 timesOutAt = currentTime + DEFERRED_TIMEOUT; &#125; var newNode = &#123; callback, timesOutAt, next: null, previous: null, &#125;; // 将新回调插入列表中, 并按其超时顺序排序 if (firstCallbackNode === null) &#123; // 这是列表中的第一个回调 firstCallbackNode = newNode.next = newNode.previous = newNode; ensureHostCallbackIsScheduled(firstCallbackNode); &#125; else &#123; var next = null; var node = firstCallbackNode; do &#123; if (node.timesOutAt &gt; timesOutAt) &#123; // 在此之前, 新的回调超时 next = node; break; &#125; node = node.next; &#125; while (node !== firstCallbackNode); if (next === null) &#123; // 找不到稍后超时的回调, 这意味着新的回调在列表中具有最新的超时。 next = firstCallbackNode; &#125; else if (next === firstCallbackNode) &#123; // 新回调在整个列表中具有最早的超时。 firstCallbackNode = newNode; ensureHostCallbackIsScheduled(firstCallbackNode); &#125; var previous = next.previous; previous.next = next.previous = newNode; newNode.next = next; newNode.previous = previous; &#125; return newNode;&#125;function unstable_cancelScheduledWork(callbackNode) &#123; var next = callbackNode.next; if (next === null) &#123; // Already cancelled. return; &#125; if (next === callbackNode) &#123; // This is the only scheduled callback. Clear the list. firstCallbackNode = null; &#125; else &#123; // Remove the callback from its position in the list. if (callbackNode === firstCallbackNode) &#123; firstCallbackNode = next; &#125; var previous = callbackNode.previous; previous.next = next; next.previous = previous; &#125; callbackNode.next = callbackNode.previous = null;&#125;// The remaining code is essentially a polyfill for requestIdleCallback. It// works by scheduling a requestAnimationFrame, storing the time for the start// of the frame, then scheduling a postMessage which gets scheduled after paint.// Within the postMessage handler do as much work as possible until time + frame// rate. By separating the idle call into a separate event tick we ensure that// layout, paint and other browser work is counted against the available time.// The frame rate is dynamically adjusted.// We capture a local reference to any global, in case it gets polyfilled after// this module is initially evaluated. We want to be using a// consistent implementation.var localDate = Date;// This initialization code may run even on server environments if a component// just imports ReactDOM (e.g. for findDOMNode). Some environments might not// have setTimeout or clearTimeout. However, we always expect them to be defined// on the client. https://github.com/facebook/react/pull/13088var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;// We don't expect either of these to necessarily be defined, but we will error// later if they are missing on the client.var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;var getCurrentTime;// requestAnimationFrame does not run when the tab is in the background. If// we're backgrounded we prefer for that work to happen so that the page// continues to load in the background. So we also schedule a 'setTimeout' as// a fallback.// TODO: Need a better heuristic for backgrounded work.var ANIMATION_FRAME_TIMEOUT = 100;var rAFID;var rAFTimeoutID;var requestAnimationFrameWithTimeout = function(callback) &#123; // schedule rAF and also a setTimeout rAFID = localRequestAnimationFrame(function(timestamp) &#123; // cancel the setTimeout localClearTimeout(rAFTimeoutID); callback(timestamp); &#125;); rAFTimeoutID = localSetTimeout(function() &#123; // cancel the requestAnimationFrame localCancelAnimationFrame(rAFID); callback(getCurrentTime()); &#125;, ANIMATION_FRAME_TIMEOUT);&#125;;if (hasNativePerformanceNow) &#123; var Performance = performance; getCurrentTime = function() &#123; return Performance.now(); &#125;;&#125; else &#123; getCurrentTime = function() &#123; return localDate.now(); &#125;;&#125;var requestCallback;var cancelCallback;var getFrameDeadline;if (typeof window === 'undefined') &#123; // 非浏览器环境 var timeoutID = -1; requestCallback = function(callback, absoluteTimeout) &#123; timeoutID = setTimeout(callback, 0, true); &#125;; cancelCallback = function() &#123; clearTimeout(timeoutID); &#125;; getFrameDeadline = function() &#123; return 0; &#125;;&#125; else if (window._schedMock) &#123; // 动态注入, 仅用于测试目的。 var impl = window._schedMock; requestCallback = impl[0]; cancelCallback = impl[1]; getFrameDeadline = impl[2];&#125; else &#123; if (typeof console !== 'undefined') &#123; if (typeof localRequestAnimationFrame !== 'function') &#123; console.error( "This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills', ); &#125; if (typeof localCancelAnimationFrame !== 'function') &#123; console.error( "This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills', ); &#125; &#125; var scheduledCallback = null; // 是否在执行空闲期回调 var isIdleScheduled = false; var timeoutTime = -1; var isAnimationFrameScheduled = false; var isPerformingIdleWork = false; var frameDeadline = 0; // 用启发式跟踪法，从30fps（即30帧）开始调整得到的更适于当前环境的一帧限制时间； var previousFrameTime = 33; var activeFrameTime = 33; getFrameDeadline = function() &#123; return frameDeadline; &#125;; // We use the postMessage trick to defer idle work until after the repaint. var messageKey = '__reactIdleCallback$' + Math.random() .toString(36) .slice(2); // 空闲期回调 var idleTick = function(event) &#123; if (event.source !== window || event.data !== messageKey) &#123; return; &#125; // 重置为false，表明可以调用空闲期回调 isIdleScheduled = false; var currentTime = getCurrentTime(); var didTimeout = false; if (frameDeadline - currentTime &lt;= 0) &#123; // 帧到期时间小于当前时间，说明已过期 if (timeoutTime !== -1 &amp;&amp; timeoutTime &lt;= currentTime) &#123; // 此帧已过期，且发生任务处理函数（执行具体任务，传入的回调）的超时 // 需要执行任务处理，下文将调用； didTimeout = true; &#125; else &#123; // 帧已过期，但没有发生任务处理函数的超时，暂时不调用任务处理函数 if (!isAnimationFrameScheduled) &#123; // 当前没有调度别的帧回调函数 // 调度下一帧 isAnimationFrameScheduled = true; requestAnimationFrameWithTimeout(animationTick); &#125; // Exit without invoking the callback. return; &#125; &#125; // 缓存的任务处理函数 timeoutTime = -1; var callback = scheduledCallback; scheduledCallback = null; if (callback !== null) &#123; isPerformingIdleWork = true; try &#123; // 执行回调 callback(didTimeout); &#125; finally &#123; isPerformingIdleWork = false; &#125; &#125; &#125;; // Assumes that we have addEventListener in this environment. Might need // something better for old IE. window.addEventListener('message', idleTick, false); // 帧回调 var animationTick = function(rafTime) &#123; isAnimationFrameScheduled = false; var nextFrameTime = rafTime - frameDeadline + activeFrameTime; if ( nextFrameTime &lt; activeFrameTime &amp;&amp; previousFrameTime &lt; activeFrameTime ) &#123; if (nextFrameTime &lt; 8) &#123; // Defensive coding. We don't support higher frame rates than 120hz. // If we get lower than that, it is probably a bug. nextFrameTime = 8; &#125; // If one frame goes long, then the next one can be short to catch up. // If two frames are short in a row, then that's an indication that we // actually have a higher frame rate than what we're currently optimizing. // We adjust our heuristic dynamically accordingly. For example, if we're // running on 120hz display or 90hz VR display. // Take the max of the two in case one of them was an anomaly due to // missed frame deadlines. activeFrameTime = nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime; &#125; else &#123; previousFrameTime = nextFrameTime; &#125; frameDeadline = rafTime + activeFrameTime; if (!isIdleScheduled) &#123; // 不在执行空闲期回调，表明可以调用空闲期回调 isIdleScheduled = true; window.postMessage(messageKey, '*'); &#125; &#125;; // 自定义 模拟requestIdleCallback requestCallback = function(callback, absoluteTimeout) &#123; // 回调函数 scheduledCallback = callback; timeoutTime = absoluteTimeout; if (isPerformingIdleWork) &#123; // 如果我们已经在执行空闲工作, 则必须抛出错误。 // 不要等待下一帧。在新事件中继续尽快工作 ASAP。 window.postMessage(messageKey, '*'); &#125; else if (!isAnimationFrameScheduled) &#123; // 如果当前没有调度帧回调函数，我们需要进行一个调度帧回调函数 // TODO: rAF 仍是 setTimeout isAnimationFrameScheduled = true; // 初始开始执行帧回调 requestAnimationFrameWithTimeout(animationTick); &#125; &#125;; cancelCallback = function() &#123; scheduledCallback = null; isIdleScheduled = false; timeoutTime = -1; &#125;;&#125;export &#123; unstable_scheduleWork, unstable_cancelScheduledWork, getCurrentTime as unstable_now,&#125;; Fiber与组件我们已经知道了Fiber的功能及其主要特点，那么其如何和组件联系，并且如何实现效果的呢，以下几点可以概括： React应用中的基础单元是组件，应用以组件树形式组织，渲染组件； Fiber调和器基础单元则是fiber（调和单元），应用以fiber树形式组织，应用Fiber算法； 组件树和fiber树结构对应，一个组件实例有一个对应的fiber实例； Fiber负责整个应用层面的调和，fiber实例负责对应组件的调和； 注意Fiber与fiber的区别，Fiber是指调和器算法，fiber则是调和器算法组成单元，和组件与应用关系类似，每一个组件实例会有对应的fiber实例负责该组件的调和。 Fiber数据结构截止目前，我们对Fiber应该有了初步的了解，在具体介绍Fiber的实现与架构之前，准备先简单介绍一下Fiber的数据结构，数据结构能一定程度反映其整体工作架构。其实，一个fiber就是一个JavaScript对象，以键值对形式存储了一个关联组件的信息，包括组件接收的props，维护的state，最后需要渲染出的内容等。接下来我们将介Fiber对象的主要属性。 FiberRoot 对象FiberRoot 对象主要用来管理组件树组件的更新进程，同时记录组件树挂载的DOM容器相关信息。123456789101112131415161718192021222324252627282930313233343536373839export type FiberRoot = &#123; // fiber节点的容器元素相关信息，通常会直接传入容器元素 containerInfo: any, // 仅用于持久更新 pendingChildren: any, // 当前fiber树中激活状态（正在处理）的fiber节点 current: Fiber, // 从提交中暂停的最早和最新的优先级级别 earliestSuspendedTime: ExpirationTime, latestSuspendedTime: ExpirationTime, // 不知道要暂停的最早和最新的优先级级别。 earliestPendingTime: ExpirationTime, latestPendingTime: ExpirationTime, // 由已解决的承诺 pinged 的最新优先级级别, 并可以重试 latestPingedTime: ExpirationTime, // 如果引发错误, 并且队列中没有其他更新, 我们尝试在处理前再一次从根中渲染错误。 didError: boolean, pendingCommitExpirationTime: ExpirationTime, // 已完成的工作正在进行的 HostRoot 已准备好提交 finishedWork: Fiber | null, // setTimeout 返回的超时句柄。如果它被一个新的取代了。用于取消挂起的超时, timeoutHandle: TimeoutHandle | NoTimeout, // 顶部上下文对象, 由 renderSubtreeIntoContainer 使用 context: Object | null, pendingContext: Object | null, // 确定我们是否应该尝试在初始加载使用 hydrate +hydrate: boolean, // 此节点剩余的任务到期时间 // TODO: Lift this into the renderer nextExpirationTimeToWorkOn: ExpirationTime, expirationTime: ExpirationTime, // 顶级批次的列表。此列表指示是否应推迟提交，也包含完成回调。 // TODO: Lift this into the renderer firstBatch: Batch | null, // 多组件树FirberRoot对象以单链表存储链接，指向下一个需要调度的FiberRoot nextScheduledRoot: FiberRoot | null,&#125;; 创建FiberRoot实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485export function createFiberRoot( containerInfo: any, isAsync: boolean, hydrate: boolean,): FiberRoot &#123; // 创建初始根组件对应的fiber实例 const uninitializedFiber = createHostRootFiber(isAsync); let root; if (enableSchedulerTracing) &#123; root = (&#123; // 根组件对应的fiber实例，一直用它 current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, interactionThreadID: unstable_getThreadID(), memoizedInteractions: new Set(), pendingInteractionMap: new Map(), &#125;: FiberRoot); &#125; else &#123; root = (&#123; current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, &#125;: BaseFiberRootProperties); &#125; // 组件树根组件fiber实例的stateNode指向FiberRoot对象 uninitializedFiber.stateNode = root; return ((root: any): FiberRoot);&#125;// 创建返回一个初始根组件对应的fiber实例export function createHostRootFiber(isAsync: boolean): Fiber &#123; let mode = isAsync ? AsyncMode | StrictMode : NoContext; if (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123; // Always collect profile timings when DevTools are present. // This enables DevTools to start capturing timing at any point– // Without some nodes in the tree having empty base times. mode |= ProfileMode; &#125; // 创建fiber return createFiber(HostRoot, null, null, mode);&#125; Fiber对象Fiber对象的定义在packages/react-reconciler/src/ReactFiber.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// 一个Fiber对象作用于一个组件export type Fiber = &#123;| // 标记fiber类型tag tag: TypeOfWork, // 唯一标识 key: null | string, // fiber对应的function/class/module类型组件名. type: any, // fiber所在组件树的根组件FiberRoot对象 stateNode: any, // 处理完当前fiber后返回的fiber， // 返回当前fiber所在fiber树的父级fiber实例 return: Fiber | null, // fiber树结构相关链接 child: Fiber | null, sibling: Fiber | null, index: number, // The ref last used to attach this node. // I'll avoid adding an owner field for prod and model that as functions. ref: null | (((handle: mixed) =&gt; void) &amp; &#123;_stringRef: ?string&#125;) | RefObject, // 当前处理过程中的组件props对象 pendingProps: any, // This type will be more specific once we overload the tag. // 缓存的之前组件props对象 memoizedProps: any, // The props used to create the output. // 组件状态更新及对应回调函数的存储队列 updateQueue: UpdateQueue&lt;any&gt; | null, // The state used to create the output memoizedState: any, // A linked-list of contexts that this fiber depends on firstContextDependency: ContextDependency&lt;mixed&gt; | null, // Bitfield that describes properties about the fiber and its subtree. E.g. // the AsyncMode flag indicates whether the subtree should be async-by- // default. When a fiber is created, it inherits the mode of its // parent. Additional flags can be set at creation time, but after that the // value should remain unchanged throughout the fiber's lifetime, particularly // before its child fibers are created. mode: TypeOfMode, // Effect effectTag: TypeOfSideEffect, // Singly linked list fast path to the next fiber with side-effects. nextEffect: Fiber | null, // The first and last fiber with side-effect within this subtree. This allows // us to reuse a slice of the linked list when we reuse the work done within // this fiber. firstEffect: Fiber | null, lastEffect: Fiber | null, // 更新任务的最晚执行时间 expirationTime: ExpirationTime, // This is used to quickly determine if a subtree has no pending changes. childExpirationTime: ExpirationTime, // fiber的版本池，即记录fiber更新过程，便于恢复 alternate: Fiber | null, // Conceptual aliases // workInProgress : Fiber -&gt; alternate The alternate used for reuse happens // to be the same as work in progress. // Time spent rendering this Fiber and its descendants for the current update. // This tells us how well the tree makes use of sCU for memoization. // It is reset to 0 each time we render and only updated when we don't bailout. // This field is only set when the enableProfilerTimer flag is enabled. actualDuration?: number, // If the Fiber is currently active in the "render" phase, // This marks the time at which the work began. // This field is only set when the enableProfilerTimer flag is enabled. actualStartTime?: number, // Duration of the most recent render time for this Fiber. // This value is not updated when we bailout for memoization purposes. // This field is only set when the enableProfilerTimer flag is enabled. selfBaseDuration?: number, // Sum of base times for all descedents of this Fiber. // This value bubbles up during the "complete" phase. // This field is only set when the enableProfilerTimer flag is enabled. treeBaseDuration?: number, // Conceptual aliases // workInProgress : Fiber -&gt; alternate The alternate used for reuse happens // to be the same as work in progress. // __DEV__ only _debugID?: number, _debugSource?: Source | null, _debugOwner?: Fiber | null, _debugIsCurrentlyTiming?: boolean,|&#125;; type &amp; key：同React元素的值； type：描述fiber对应的React组件； 对于组合组件：值为function或class组件本身； 对于原生组件（div等）：值为该元素类型字符串； key：调和阶段，标识fiber，以检测是否可重用该fiber实例； child &amp; sibling：组件树，对应生成fiber树，类比的关系； pendingProps &amp; memoizedProps：分别表示组件当前传入的及之前的props； return：返回当前fiber所在fiber树的父级fiber实例，即当前组件的父组件对应的fiber； alternate：fiber的版本池，即记录fiber更新过程，便于恢复重用； workInProgress：正在处理的fiber，概念上叫法，实际上没有此属性； alternate fiber可以理解为一个fiber版本池，用于交替记录组件更新（切分任务后变成多阶段更新）过程中fiber的更新，因为在组件更新的各阶段，更新前及更新过程中fiber状态并不一致，在需要恢复时（如，发生冲突），即可使用另一者直接回退至上一版本fiber。 使用alternate属性双向连接一个当前fiber和其work-in-progress，当前fiber实例的alternate属性指向其work-in-progress，work-in-progress的alternate属性指向当前稳定fiber； 当前fiber的替换版本是其work-in-progress，work-in-progress的交替版本是当前fiber； 当work-in-progress更新一次后，将同步至当前fiber，然后继续处理，同步直至任务完成； work-in-progress指向处理过程中的fiber，而当前fiber总是维护处理完成的最新版本的fiber。 创建Fiber实例创建fiber实例即返回一个带有上一小节描述的诸多属性的JavaScript对象，FiberNode即根据传入的参数构造返回一个初始化的对象：123456789const createFiber = function( tag: TypeOfWork, pendingProps: mixed, key: null | string, mode: TypeOfMode,): Fiber &#123; // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors return new FiberNode(tag, pendingProps, key, mode);&#125;; 创建alternate fiber以处理任务的实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 创建一个alternate fiber处理任务export function createWorkInProgress( current: Fiber, pendingProps: any, expirationTime: ExpirationTime,): Fiber &#123; let workInProgress = current.alternate; if (workInProgress === null) &#123; // We use a double buffering pooling technique because we know that we'll // only ever need at most two versions of a tree. We pool the "other" unused // node that we're free to reuse. This is lazily created to avoid allocating // extra objects for things that are never updated. It also allow us to // reclaim the extra memory if needed. workInProgress = createFiber( current.tag, pendingProps, current.key, current.mode, ); workInProgress.type = current.type; workInProgress.stateNode = current.stateNode; if (__DEV__) &#123; // DEV-only fields workInProgress._debugID = current._debugID; workInProgress._debugSource = current._debugSource; workInProgress._debugOwner = current._debugOwner; &#125; workInProgress.alternate = current; current.alternate = workInProgress; &#125; else &#123; workInProgress.pendingProps = pendingProps; // We already have an alternate. // Reset the effect tag. workInProgress.effectTag = NoEffect; // The effect list is no longer valid. workInProgress.nextEffect = null; workInProgress.firstEffect = null; workInProgress.lastEffect = null; if (enableProfilerTimer) &#123; // We intentionally reset, rather than copy, actualDuration &amp; actualStartTime. // This prevents time from endlessly accumulating in new commits. // This has the downside of resetting values for different priority renders, // But works for yielding (the common case) and should support resuming. workInProgress.actualDuration = 0; workInProgress.actualStartTime = -1; &#125; &#125; // Don't touching the subtree's expiration time, which has not changed. workInProgress.childExpirationTime = current.childExpirationTime; if (pendingProps !== current.pendingProps) &#123; // This fiber has new props. workInProgress.expirationTime = expirationTime; &#125; else &#123; // This fiber's props have not changed. workInProgress.expirationTime = current.expirationTime; &#125; workInProgress.child = current.child; workInProgress.memoizedProps = current.memoizedProps; workInProgress.memoizedState = current.memoizedState; workInProgress.updateQueue = current.updateQueue; workInProgress.firstContextDependency = current.firstContextDependency; // These will be overridden during the parent's reconciliation workInProgress.sibling = current.sibling; workInProgress.index = current.index; workInProgress.ref = current.ref; if (enableProfilerTimer) &#123; workInProgress.selfBaseDuration = current.selfBaseDuration; workInProgress.treeBaseDuration = current.treeBaseDuration; &#125; return workInProgress;&#125; Fiber类型上一小节，Fiber对象中有个tag属性，标记fiber类型，而fiber实例是和组件对应的，所以其类型基本上对应于组件类型，在packages/shared/ReactWorkTags.js中：12345678910111213141516171819export type TypeOfWork = | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16;export const FunctionalComponent = 0; // 函数式组件export const FunctionalComponentLazy = 1;export const ClassComponent = 2; // Class类组件export const ClassComponentLazy = 3;export const IndeterminateComponent = 4; // Before we know whether it is functional or classexport const HostRoot = 5; // 组件树根组件，可以嵌套export const HostPortal = 6; // 子树。可以是一个入口点不同的渲染器。export const HostComponent = 7; // 标准组件，如地div， span等export const HostText = 8; // 文本export const Fragment = 9; // 片段export const Mode = 10;export const ContextConsumer = 11;export const ContextProvider = 12;export const ForwardRef = 13;export const ForwardRefLazy = 14;export const Profiler = 15;export const PlaceholderComponent = 16; // placeholder（占位符） 在调度执行任务的时候会根据不同类型fiber，即fiber.tag值进行不同处理。 FiberRoot对象FiberRoot对象，主要用来管理组件树组件的更新进程，同时记录组件树挂载的DOM容器相关信息，在packages/react-reconciler/src/ReactFiberRoot.js中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export type FiberRoot = &#123; // fiber节点的容器元素相关信息，通常会直接传入容器元素 containerInfo: any, // Used only by persistent updates. pendingChildren: any, // 当前fiber树中激活状态（正在处理）的fiber节点， current: Fiber, // The following priority levels are used to distinguish between 1) // uncommitted work, 2) uncommitted work that is suspended, and 3) uncommitted // work that may be unsuspended. We choose not to track each individual // pending level, trading granularity for performance. // // The earliest and latest priority levels that are suspended from committing. earliestSuspendedTime: ExpirationTime, latestSuspendedTime: ExpirationTime, // The earliest and latest priority levels that are not known to be suspended. earliestPendingTime: ExpirationTime, latestPendingTime: ExpirationTime, // The latest priority level that was pinged by a resolved promise and can // be retried. latestPingedTime: ExpirationTime, // If an error is thrown, and there are no more updates in the queue, we try // rendering from the root one more time, synchronously, before handling // the error. didError: boolean, pendingCommitExpirationTime: ExpirationTime, // 准备好提交的已处理完成的work-in-progress finishedWork: Fiber | null, // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if // it's superseded by a new one. timeoutHandle: TimeoutHandle | NoTimeout, // Top context object, used by renderSubtreeIntoContainer context: Object | null, pendingContext: Object | null, // Determines if we should attempt to hydrate on the initial mount +hydrate: boolean, // Remaining expiration time on this root. // TODO: Lift this into the renderer nextExpirationTimeToWorkOn: ExpirationTime, expirationTime: ExpirationTime, // List of top-level batches. This list indicates whether a commit should be // deferred. Also contains completion callbacks. // TODO: Lift this into the renderer firstBatch: Batch | null, // 多组件树FirberRoot对象以单链表存储链接，指向下一个需要调度的FiberRoot nextScheduledRoot: FiberRoot | null,&#125;; 创建FiberRoot实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123; ClassComponent, HostRoot, Mode,&#125; from 'shared/ReactTypeOfWork';// 创建返回一个初始根组件对应的fiber实例export function createHostRootFiber(isAsync: boolean): Fiber &#123; let mode = isAsync ? AsyncMode | StrictMode : NoContext; if (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123; // Always collect profile timings when DevTools are present. // This enables DevTools to start capturing timing at any point– // Without some nodes in the tree having empty base times. mode |= ProfileMode; &#125; // 创建fiber return createFiber(HostRoot, null, null, mode);&#125;export function createFiberRoot( containerInfo: any, isAsync: boolean, hydrate: boolean,): FiberRoot &#123; // 创建初始根组件对应的fiber实例 const uninitializedFiber = createHostRootFiber(isAsync); // 组件树根组件的FiberRoot对象 const root = &#123; // 根组件对应的fiber实例 current: uninitializedFiber, containerInfo: containerInfo, pendingChildren: null, earliestPendingTime: NoWork, latestPendingTime: NoWork, earliestSuspendedTime: NoWork, latestSuspendedTime: NoWork, latestPingedTime: NoWork, didError: false, pendingCommitExpirationTime: NoWork, finishedWork: null, timeoutHandle: noTimeout, context: null, pendingContext: null, hydrate, nextExpirationTimeToWorkOn: NoWork, expirationTime: NoWork, firstBatch: null, nextScheduledRoot: null, &#125;; // 组件树根组件fiber实例的stateNode指向FiberRoot对象 uninitializedFiber.stateNode = root; return root;&#125; ReactChildFiber在生成组件树的FiberRoot对象后，会为子组件生成各自的fiber实例，这一部分由ReactChildFiber模块实现，在packages/react-reconciler/src/ReactChildFiber.js中： 1234// 调和（处理更新）子fibersexport const reconcileChildFibers = ChildReconciler(true);// 挂载（初始化）子fibersexport const mountChildFibers = ChildReconciler(false); 而ChildReconciler方法所做的则是根据传入参数判断是调用初始化子组件fibers逻辑还是执行调和已有子组件fibers逻辑。 ChildReconciler方法，返回reconcileChildFibers方法： 判断子级传递内容的数据类型，执行不同的处理，这也对应着我们写React组件时传递props.children时，其类型可以是对象或数组，字符串，是数字等； 然后具体根据子组件类型，调用不同的具体调和处理函数； 最后返回根据子组件创建或更新得到的fiber实例； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126function reconcileChildFibers( returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any, expirationTime: ExpirationTime, ): Fiber | null &#123; // This function is not recursive. // If the top level item is an array, we treat it as a set of children, // not as a fragment. Nested arrays on the other hand will be treated as // fragment nodes. Recursion happens at the normal flow. // Handle top level unkeyed fragments as if they were arrays. // This leads to an ambiguity between &lt;&gt;&#123;[...]&#125;&lt;/&gt; and &lt;&gt;...&lt;/&gt;. // We treat the ambiguous cases above the same. const isUnkeyedTopLevelFragment = typeof newChild === 'object' &amp;&amp; newChild !== null &amp;&amp; newChild.type === REACT_FRAGMENT_TYPE &amp;&amp; newChild.key === null; if (isUnkeyedTopLevelFragment) &#123; newChild = newChild.props.children; &#125; // Handle object types const isObject = typeof newChild === 'object' &amp;&amp; newChild !== null; if (isObject) &#123; // 子组件实例类型，以Symbol符号表示的 switch (newChild.$$typeof) &#123; case REACT_ELEMENT_TYPE: return placeSingleChild( reconcileSingleElement( returnFiber, currentFirstChild, newChild, expirationTime, ), ); // React组件调用 case REACT_PORTAL_TYPE: return placeSingleChild( reconcileSinglePortal( returnFiber, currentFirstChild, newChild, expirationTime, ), ); &#125; &#125; if (typeof newChild === 'string' || typeof newChild === 'number') &#123; return placeSingleChild( reconcileSingleTextNode( returnFiber, currentFirstChild, '' + newChild, expirationTime, ), ); &#125; if (isArray(newChild)) &#123; return reconcileChildrenArray( returnFiber, currentFirstChild, newChild, expirationTime, ); &#125; if (getIteratorFn(newChild)) &#123; return reconcileChildrenIterator( returnFiber, currentFirstChild, newChild, expirationTime, ); &#125; if (isObject) &#123; throwOnInvalidObjectType(returnFiber, newChild); &#125; if (__DEV__) &#123; if (typeof newChild === 'function') &#123; warnOnFunctionType(); &#125; &#125; if (typeof newChild === 'undefined' &amp;&amp; !isUnkeyedTopLevelFragment) &#123; // If the new child is undefined, and the return fiber is a composite // component, throw an error. If Fiber return types are disabled, // we already threw above. switch (returnFiber.tag) &#123; case ClassComponent: case ClassComponentLazy: &#123; if (__DEV__) &#123; const instance = returnFiber.stateNode; if (instance.render._isMockFunction) &#123; // We allow auto-mocks to proceed as if they're returning null. break; &#125; &#125; &#125; // Intentionally fall through to the next case, which handles both // functions and classes // eslint-disable-next-lined no-fallthrough case FunctionalComponent: &#123; const Component = returnFiber.type; invariant( false, '%s(...): Nothing was returned from render. This usually means a ' + 'return statement is missing. Or, to render nothing, ' + 'return null.', Component.displayName || Component.name || 'Component', ); &#125; &#125; &#125; // Remaining cases are all treated as empty. return deleteRemainingChildren(returnFiber, currentFirstChild); &#125; return reconcileChildFibers;&#125; Fiber架构在学习Fiber的时候，我尝试去阅读源码，发现通过这种方式很难快速理解，学习Fiber，而先了解调和器是干什么的及调和器在React中的存在形式，然后再学习Fiber的结构及算法实现思路，明白从组件被定义到渲染至页面它需要做什么，这也是本篇文章的组织形式。 优先级（ExpirationTime VS PriorityLevel）我们已经知道Fiber可以切分任务并设置不同优先级，那么是如何实现划分优先级的呢，其表现形式什么呢？ ExpirationTimeFiber切分任务并调用requestIdleCallback和requestAnimationFrameAPI，保证渲染任务和其他任务，在不影响应用交互，不掉帧的前提下，稳定执行，而实现调度的方式正是给每一个fiber实例设置到期执行时间，不同时间即代表不同优先级，到期时间越短，则代表优先级越高，需要尽早执行。 所谓的到期时间（ExpirationTime），是相对于调度器初始调用的起始时间而言的一个时间段；调度器初始调用后的某一段时间内，需要调度完成这项更新，这个时间段长度值就是到期时间值。 Fiber提供ReactFiberExpirationTime模块实现到期时间的定义，在packages/react-reconciler/src/ReactFiberExpirationTime.js中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export const NoWork = 0; // 没有任务等待处理export const Sync = 1; // 同步模式，立即处理任务export const Never = MAX_SIGNED_31_BIT_INT; // 1073741823 Max 31: Math.pow(2, 30) - 1 const UNIT_SIZE = 10; // 过期时间单元（ms）const MAGIC_NUMBER_OFFSET = 2; // 到期时间偏移量// 以ExpirationTime特定单位（1单位=10ms）表示的到期执行时间export function msToExpirationTime(ms: number): ExpirationTime &#123; // 总是增加一个偏移量，在ms&lt;10时与Nowork模式进行区别 return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;&#125;// 以毫秒表示的到期执行时间export function expirationTimeToMs(expirationTime: ExpirationTime): number &#123; return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;&#125;// 向上取整（整数单位到期执行时间）// precision范围精度：弥补任务执行时间误差function ceiling(num: number, precision: number): number &#123; return (((num / precision) | 0) + 1) * precision;&#125;// 计算处理误差时间在内的到期时间function computeExpirationBucket( currentTime, expirationInMs, bucketSizeMs,): ExpirationTime &#123; return ( MAGIC_NUMBER_OFFSET + ceiling( currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE, ) );&#125;export const LOW_PRIORITY_EXPIRATION = 5000;export const LOW_PRIORITY_BATCH_SIZE = 250;export function computeAsyncExpiration( currentTime: ExpirationTime,): ExpirationTime &#123; return computeExpirationBucket( currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE, );&#125;// We intentionally set a higher expiration time for interactive updates in// dev than in production.//// If the main thread is being blocked so long that you hit the expiration,// it's a problem that could be solved with better scheduling.//// People will be more likely to notice this and fix it with the long// expiration time in development.//// In production we opt for better UX at the risk of masking scheduling// problems, by expiring fast.export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;export const HIGH_PRIORITY_BATCH_SIZE = 100;export function computeInteractiveExpiration(currentTime: ExpirationTime) &#123; return computeExpirationBucket( currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE, );&#125; 该模块提供的功能主要有： Sync：同步模式，在UI线程立即执行此类任务，如动画反馈等； 异步模式： 转换：到期时间特定单位和时间单位（ms）的相互转换； 计算：计算包含允许误差在内的到期时间； PriorityLevel其实在15.x版本中出现了对于任务的优先层级划分，ReactPriorityLevel模块，在/src/renderers/shared/fiber/ReactPriorityLevel.js中：12345678910export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;module.exports = &#123; NoWork: 0, // No work is pending. SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects. AnimationPriority: 2, // Needs to complete before the next frame. HighPriority: 3, // Interaction that needs to complete pretty soon to feel responsive. LowPriority: 4, // Data fetching, or result from updating stores. OffscreenPriority: 5, // Won't be visible but do the work in case it becomes visible.&#125;; 相对于PriorityLevel的简单层级划分，在16.x版本中使用的则是ExpirationTime的到期时间方式表示任务的优先级，可以更好的对任务进行切分，调度。 调度器（Scheduler）前面介绍调和器主要作用就是在组件状态变更时，调用组件树各组件的render方法，渲染，卸载组件，而Fiber使得应用可以更好的协调不同任务的执行，调和器内关于高效协调的实现，我们可以称它为调度器（Scheduler）。 顾名思义，调度器即调度资源以执行指定任务，React应用中应用组件的更新与渲染，需要占用系统CPU资源，如果不能很好的进行资源平衡，合理调度，优化任务执行策略，那很容易造成CPU这一紧缺资源的消耗和浪费，容易造成页面卡顿，动画掉帧，组件更新异常等诸多问题，就像城市交通调度一样，如果不能有效调度，交通状况很可能将拥堵不堪。 在React 15.x版本中，组件的状态变更将直接导致其子组件树的重新渲染，新版本Fiber算法将在调度器方面进行全面改进，主要的关注点是： 合并多次更新：没有必要在组件的每一个状态变更时都立即触发更新任务，有些中间状态变更其实是对更新任务所耗费资源的浪费，就比如用户发现错误点击时快速操作导致组件某状态从A至B再至C，这中间的B状态变更其实对于用户而言并没有意义，那么我们可以直接合并状态变更，直接从A至C只触发一次更新； 任务优先级：不同类型的更新有不同优先级，例如用户操作引起的交互动画可能需要有更好的体验，其优先级应该比完成数据更新高； 推拉式调度：基于推送的调度方式更多的需要开发者编码间接决定如何调度任务，而拉取式调度更方便React框架层直接进行全局自主调度； 源码在packages/react-reconciler/src/ReactFiberScheduler.js中： 1234567891011121314151617181920212223export &#123; requestCurrentTime, computeExpirationForFiber, captureCommitPhaseError, onUncaughtError, renderDidSuspend, renderDidError, retrySuspendedRoot, markLegacyErrorBoundaryAsFailed, isAlreadyFailedLegacyErrorBoundary, scheduleWork, requestWork, flushRoot, batchedUpdates, unbatchedUpdates, flushSync, flushControlled, deferredUpdates, syncUpdates, interactiveUpdates, flushInteractiveUpdates, computeUniqueAsyncExpiration,&#125;; 如上调度器主要输出API为实现调度任务，拉取更新，延迟更新等功能。 调度器与优先级调度器如何切分任务划分优先级的呢？在React调和算法中，任务由fiber实例描述，所以要划分任务优先级，等效于设置fiber的到期时间（expirationTime），调度器内提供了computeExpirationForFiber方法以计算某一个fiber的到期时间，源码在packages/react-reconciler/src/ReactFiberScheduler.js中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import &#123; NoWork, Sync, Never, msToExpirationTime, expirationTimeToMs, computeAsyncExpiration, computeInteractiveExpiration,&#125; from './ReactFiberExpirationTime';function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) &#123; let expirationTime; if (expirationContext !== NoWork) &#123; // An explicit expiration context was set; expirationTime = expirationContext; &#125; else if (isWorking) &#123; if (isCommitting) &#123; // 在提交阶段的更新任务 需要明确设置同步优先级（Sync Priority） expirationTime = Sync; &#125; else &#123; // 在渲染阶段发生的更新任务 // 需要设置为下一次渲染时间的到期时间优先级 expirationTime = nextRenderExpirationTime; &#125; &#125; else &#123; // No explicit expiration context was set, and we're not currently // performing work. Calculate a new expiration time. if (fiber.mode &amp; AsyncMode) &#123; if (isBatchingInteractiveUpdates) &#123; // This is an interactive update expirationTime = computeInteractiveExpiration(currentTime); &#125; else &#123; // This is an async update expirationTime = computeAsyncExpiration(currentTime); &#125; // If we're in the middle of rendering a tree, do not update at the same // expiration time that is already rendering. if (nextRoot !== null &amp;&amp; expirationTime === nextRenderExpirationTime) &#123; expirationTime += 1; &#125; &#125; else &#123; // 同步更新，设置为同步标记 expirationTime = Sync; &#125; &#125; if (isBatchingInteractiveUpdates) &#123; // This is an interactive update. Keep track of the lowest pending // interactive expiration time. This allows us to synchronously flush // all interactive updates when needed. if ( lowestPendingInteractiveExpirationTime === NoWork || expirationTime &gt; lowestPendingInteractiveExpirationTime ) &#123; lowestPendingInteractiveExpirationTime = expirationTime; &#125; &#125; return expirationTime;&#125; 若当前处于任务提交阶段（更新提交至DOM渲染）时，设置当前fiber到期时间为Sync，即同步执行模式； 若处于DOM渲染阶段时，则需要延迟此fiber任务，将fiber到期时间设置为下一次DOM渲染到期时间； 若不在任务执行阶段，则需重新设置fiber到期时间： 若明确设置useSyncScheduling且fiber.internalContextTag值不等于AsyncUpdates，则表明是同步模式，设置为Sync； 否则，调用computeAsyncExpiration方法重新计算此fiber的到期时间； 12345678910111213141516171819202122// 重新计算当前时间（ExpirationTime单位表示）function recalculateCurrentTime() &#123; const ms = now() - startTime; // ExpirationTime单位表示的当前时间 // 时间段值为 now() - startTime（起始时间） mostRecentCurrentTime = msToExpirationTime(ms); return mostRecentCurrentTime;&#125; // 计算异步任务的到期时间function computeAsyncExpiration() &#123; // 计算得到ExpirationTime单位的当前时间 // 聚合相似的更新在一起 // 更新应该在 ~1000ms，最多1200ms内完成 const currentTime = recalculateCurrentTime(); // 对于每个fiber的期望到期时间的增值，最大值为1000ms const expirationMs = 1000; // 到期时间的可接受误差时间，200ms const bucketSizeMs = 200; // 返回包含误差时间在内的到期时间 return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);&#125; 对于每一个fiber我们期望的到期时间参数是1000ms，另外由于任务执行时间误差，接受200ms误差，最后计算得到的到期时间默认返回值为ExpirationTime单位。 任务调度上一节介绍了调度器主要提供computeExpirationForFiber等方法支持计算任务优先级（到期时间），接下来介绍调度器如何调度任务。 React应用更新时，Fiber从当前处理节点，层层遍历至组件树根组件，然后开始处理更新，调用前面的requestIdleCallback等API执行更新处理。 主要调度逻辑实现在scheduleWork： 通过fiber.return属性，从当前fiber实例层层遍历至组件树根组件； 依次对每一个fiber实例进行到期时间判断，若大于传入的期望任务到期时间参数，则将其更新为传入的任务到期时间； 调用requestWork方法开始处理任务，并传入获取的组件树根组件FiberRoot对象和任务到期时间； 12 渲染与调和在调和阶段，不涉及任何DOM处理，在处理完更新后，需要渲染模块将更新渲染至DOM，这也是React应用中虚拟DOM（Virtual DOM）的概念，即所有的更新计算都基于虚拟DOM，计算完后才将优化后的更新渲染至真实DOM。Fiber使用requestIdleCallbackAPI更高效的执行渲染更新的任务，实现任务的切分。 本文不断更新中]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS系统使用指南]]></title>
    <url>%2F2018%2F08%2F11%2Fmacos-tutorial.html</url>
    <content type="text"><![CDATA[Mac OS是一套运行于苹果Macintosh系列电脑上的操作系统。Mac OS是首个在商用领域成功的图形用户界面操作系统。现行的最新的系统版本是OS X 10.12 ，且网上也有在PC上运行的Mac系统，简称 Mac PC。Mac系统是基于Unix内核的图形化操作系统；一般情况下在普通PC上无法安装的操作系统。由苹果公司自行开发。苹果机的操作系统已经到了OS 10，代号为MAC OS X(X为10的罗马数字写法），这是MAC电脑诞生15年来最大的变化。新系统非常可靠；它的许多特点和服务都体现了苹果公司的理念。另外，疯狂肆虐的电脑病毒几乎都是针对Windows的，由于MAC的架构与Windows不同，所以很少受到病毒的袭击。MAC OSX操作系统界面非常独特，突出了形象的图标和人机对话。苹果公司不仅自己开发系统，也涉及到硬件的开发。接下来，我们就总结下Mac OS常见的使用指南。 Mac电脑使用：您的安全性偏好设置仅允许安装来自App Store和被认可的开发者的应用（解决方法）1. 打开dock栏里面的“系统偏好设置”； 2. 在系统偏好设置里面，找到“安全性与隐私”选项； 3. 在安全性与隐私里面，找到左下角的锁型图标，然后点击锁，会弹出输入电脑开机密码的窗口，输入密码之后，点击“解锁”按钮，那个锁型变为开启的锁； 4. 解锁后，如果你的电脑里面在允许从以下位置下载应用有三个选项，就在允许从以下位置下载的应用选项中选择“任何来源”，在弹出的确认框里点击“允许来自任何来源”；如果你的电脑里面允许从以下位置下载的应用中只有两个选项，那你就直接去打开你刚才需要安装的那个程序的安装包，双击重新安装，会有一个提示框，也是提示允许来自任何来源安装的，然后就可以安装成功了，最后打开即可。 用终端连接远程服务器12345# 登录$ ssh -t root@121.199.61.169 -p 22# 退出$ control + d 隐藏/显示 隐藏文件12# 凡是前面带有小点的隐藏文件，或者是显示淡蓝色的文件都是隐藏文件$ shift + cmmand + . mac os 获取root/su/sudo权限的方法方法一： 打开终端， 输入sudo -i , 按照提示输入当前管理员用户密码，即可进入root权限 mac os 从root账户切换到普通账户方法一： 打开终端， 输入su - test , 即可进入test权限 如何解除mac上不能安装不明开发者的软件打开 「Launchpad」 - 「实用工具」 - 「终端」；你在终端里输入 1$ sudo spctl --master-disable 输入password（开机密码），输完敲回车；“任何来源”就会显示了，然后勾选你要的选项； mysql登录退出命令登录Mysql：“输入mysql -u帐号 -p密码 这是登陆 mysql退出：mysql &gt; exit; 以下是实例参考下： 登录Mysql：“输入mysql -uroot -p -P3306 -h127.0.0.1” 表示超级用户名root,密码稍后输入，端口号3306（不输入P默认为3306）， 主机地址127.0.0.1（若使用本机作为主机，h默认127.0.0.1） mysql退出三种方法： mysql &gt; exit; mysql &gt; quit; mysql &gt; \q; mysql连接错误如下：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2) 确保环境没有mysql 123$ brew remove mysql$ brew cleanup 安装 1$ brew install mysql 启动 1$ brew services start mysql 设置开机启动: launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist (设置启动的命令可以通过 brew info mysql获得) 4.登录1$ mysql -uroot]]></content>
      <categories>
        <category>Mac OS</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式开发指南]]></title>
    <url>%2F2018%2F08%2F10%2Fregular-expression-tutorial.html</url>
    <content type="text"><![CDATA[正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen。 语法 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 . 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.&#124;\n)”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(&#124;)”来组合一个模式的各个部分是很有用。例如“industr(?:y&#124;ies)”就是一个比“industry&#124;industries”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95&#124;98&#124;NT&#124;2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95&#124;98&#124;NT&#124;2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 使用技巧. 和 [.]. 特殊字符在中括号表达式时 如 [.] 只会匹配 .字符，等价于 .，而非匹配除换行符 \n 外的所有字符。 ^ 和 [^指定字符串] 之间的区别^ 指的是匹配字符串开始的位置[^指定字符串] 指的是除指定字符串以外的其他字符串12(^[0-9])+ // 匹配有一至多个数字的字符串组合[^[0-9]]+ // 匹配有一至多个不含数字的字符串组合 exec() 方法定义和用法exec() 方法用于检索字符串中的正则表达式的匹配。 语法12// string: 必需。要检索的字符串。RegExpObject.exec(string); 返回值返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 说明exec() 方法的功能非常强大，它是一个通用的方法，而且使用起来也比 test() 方法以及支持正则表达式的 String 对象的方法更为复杂。 如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。 但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。 提示和注释重要事项：如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。 提示：请注意，无论 RegExpObject 是否是全局模式，exec() 都会把完整的细节添加到它返回的数组中。这就是 exec() 与 String.match() 的不同之处，后者在全局模式下返回的信息要少得多。因此我们可以这么说，在循环中反复地调用 exec() 方法是唯一一种获得全局模式的完整模式匹配信息的方法。 ()和$1…$9的理解和使用()就是起到一个分组作用，将匹配到的放到mathches集合中，$相当于集合名字，1-9就相当于索引，$1…$9相当于对应索引的值。 示例一12345// 将yyyy-MM-dd格式的日期转换为yyyy年MM月dd日const str = "2018-07-02";const reg =/(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)/;const date = str.replace(reg,"$1年$2月$3日");console.log(date); // "2018年07月02日" 示例二12345// 将yyyy-MM-dd格式的日期转换为yyyy/MM/dd/const str = "2018-07-02";const reg =/(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)/;const date = str.replace(reg,"$1/$2/$3");console.log(date); // "2018/07/02" ^在[]里面和在[]外面如何区分^在[]里面123456789/[^0-9]/.test('abc') // true/[^0-9]/.test('123') // false``` 归纳：^在[]里面代表是非数字，所以它代表是非。**^在[]外面**``` js/^[0-9]/.test('abc') // false/^[0-9]/.test('1bc') // true 归纳：^在[]外面代表是为首的数字，所以它代表头。 ^在[]里面和在[]外面有一个记忆的方法：乌龟把头(^)缩进里面，变为无（非)头乌龟，乌龟把头(^)伸出来，变为头(首）领。 [\s\S]*?非贪婪匹配任意字符串（包括换行符），将这个表达式放在()内，()的前后是定位用的、固定不变的字段。()是用来在「Get Group from Matched Text」中仅输出匹配的变动字段。12345\s 空白符\S 非空白符[\s\S]任意字符[\s\S]* 0个到任意多个字符[\s\S]*? 0个到任意多个字符（非贪婪模式，即最短匹配情况） gmm表明可以进行多行匹配，g表明可以进行全局匹配，综合到一起就是可以进行多行全局匹配]]></content>
      <categories>
        <category>regex</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发指南]]></title>
    <url>%2F2018%2F08%2F09%2Fwechat-public-development-tutorial.html</url>
    <content type="text"><![CDATA[微信浏览器？啊，它是什么，好不好用，能吃不？我记得有个说法是这么评价微信浏览器的，微信浏览器就是移动端IE6。是程序员就知道IE什么样，好不好用。面向IE开发，我们经常会写出稀奇古怪的bug代码，同样的，基于微信浏览器开发也会BUG百出。因此，很有必要整理一些基于微信浏览器的开发技巧和开发问题。 开发问题vue 路由采用 history 模式在IOS中签名失败 Android签名良好基于微信公众号开发，我们经常会使用到分享、上传图片等功能，然而这种种功能都需要微信签名。提到签名，我们应该就会遇到签名失败的情况。接下来我们说说 vue 路由采用 history 模式在IOS中签名失败，Android签名良好的情况。 原因history 模式下视图是通过 pushState 来切换的，但IOS手机在微信浏览器中记录的 URL 只会是第一次进入时的URL，所以在IOS中，无论你路由怎么切换。真实的URL都是第一次进入应用时的URL。 解决办法每次路由变化时都重新请求下签名，同时在路由钩子函数里改写一下路由： 123456// beforeRouterif (isWeixin() &amp;&amp; to.meta.wxSign &amp;&amp; to.path !== location.pathname) &#123; location.assign(window.location.protocol + '//' + window.location.host + to.fullPath)&#125; else &#123; next();&#125; 两（多）张两张二维码无法在同一屏幕视窗中共存同一屏幕视窗”是指微信内置浏览器中在当前的手机屏幕上显示的可见范围，我们发现，当同一同一屏幕视窗中存在两个或以上的二维码的时候，微信客户端就会识别错误，无论你按哪个二维码长按识别，识别出来都是同一个目标。这个问题在 iOS 版（iPhone）微信2.2及安卓版上均有。 原因长按的时候相当于将当前手机屏幕截屏，识别截屏后的图片，这样一张图片有两个二维码图的时候当然只会识别出一个。 解决办法不要将两个二维码共存在同一个页面中。 微信只调用相机不使用相册时，安卓会退出并刷新页面解决办法相机和相册两者都加上！ 本文持续更新中]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[package.json详解]]></title>
    <url>%2F2018%2F08%2F08%2Fpackage-json-module.html</url>
    <content type="text"><![CDATA[通常基于 NPM 托管的项目都会有一个 package.json 文件，它是项目的描述文件，它的内容是一个标准的 JSON 对象。相信大家对 package.json 常用配置肯定熟悉的不能再熟悉了，例如项目名称（name）、项目版本号（version）、项目描述 （description）、npm 命令（scripts）等等，而我们今天聊聊package.json常用字段的功能以及使用场景。 pck.mainmain字段指定了模块的入口程序文件。就是说，如果你的模块名叫”foo”，用户安装了它，并且调用了 require(“foo”)，则这个main字段指定的模块的导出对象会被返回。这应该是一个相对于包根目录的模块标识。对于大部分模块来说，main字段除了指定一个主入口文件以外没什么其他用处了。 pck.module之前查阅了package.json的文档，并没有找到我们想要的 module 字段的定义，无意中看了一个帖子才知道它是 rollup 中最早就提出的概念 — pkg.module。在这之前 npm 包大都是基于 CommonJS 规范的。当我们当 require 引入包的时候，就会根据 main 字段去查找入口文件。 而在 ES6 规范出现后，ES6 定义了一套基于 import、export 操作符的模块规范。它与 CommonJS 规范最大的区别在于 ES6 中的 import 和 export 都是静态的。静态意味着一个模块要暴露或引入的所有方法在编译阶段就能全部确定，之后不能再改变。这样做的好处就是打包工具在打包阶段就可以分析出代码中用到了某个模块中的哪几个方法。其它没有用到的方法就可以从最终的 bundle 文件中剔除掉。这样既可以减少 bundle 文件的大小，又可以提高脚本的执行速度。这个机制被称为 Tree Shaking。在这个构建思想的基础上，开发基于 ES Module 规范的包是很有必要的。 之前我们说过 CommonJS 规范的包都是以 main 字段表示入口文件了，如果 ES Module 的也用 main 字段，就会对使用者造成困扰，如果他的项目不支持打包构建，比如大多数 node 项目(尽管 node9+ 支持 ES Module)，这时库开发者的模块系统跟项目构建的模块系统的冲突，更像是一种规范上的问题。况且目前大部分仍是采用 CommonJS，所以 rollup 便使用了另一个字段：module。如下配置：123456&#123; "name": "mypck", "version": "1.0.0", "main": "dist/index.cjs.js", "module": "dist/index.esm.js"&#125; webpack 从版本 2 开始也可以识别 pkg.module 字段。打包时，如果存在 module 字段，会优先使用，如果没找到对应的文件，则使用 main 字段，并按照 CommonJS 规范打包。所以目前主流的打包工具（webpack, rollup）都是支持 pkg.module 的，鉴于其优点，module 字段很有可能加入 package.json 的规范之中。另外，越来越多的 npm 包已经同时支持两种模块，使用者可以根据情况自行选择，并且实现也比较简单，只是模块导出的方式。 注意：虽然打包工具支持了 ES Module，但是并不意味着其他的 es6 代码可以正常使用，因为使用者并不会对我们的 npm 包做编译处理，比如 webpack rules 中 exclude: /node_modules/，所以如果不是事先约定好后编译或者没有兼容性的需求，我们仍需要用 babel 处理，从而产出兼容性更好的 npm 包。 pck.filesfiles字段是一个被项目包含的文件名数组，如果你在里面放一个文件夹名，那么这个文件夹中的所有文件都会被包含进项目中(除非是那些在其他规则中被忽略的文件)。你还可以在包的根目录或子目录下提供一个”.npmignore”文件来忽略项目包含文件，即使这些文件被包含在files字段中。.npmignore文件和.gitignore的功能很像。某些文件总是被包含的，不论是否在规则中指定了它们：1234package.jsonREADME (and its variants)CHANGELOG (and its variants)LICENSE / LICENCE 相反地，一些文件总是被忽略：12345678910.gitCVS.svn.hg.lock-wscript.wafpickle-N*.swp.DS_Store._*npm-debug.log]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>package.json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Commit message 和 Change log 编写指南]]></title>
    <url>%2F2018%2F08%2F07%2Fgit-commit-change-writing-guide.html</url>
    <content type="text"><![CDATA[Git 每次提交代码，都要编写 Commit message（提交说明），否则就不允许提交。 1$ git commit -m "hello world" 上面代码的 -m 参数，就是用来指定 commit mesage 的。如果一行不够，可以只执行 git commit，就会跳出文本编辑器，让你写多行。1$ git commit 基本上，你写什么都行。 但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。 目前，社区有多种 Commit message 的写法规范。本文介绍 Angular 规范，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。 Commit message 的作用提供更多的历史信息，方便快速浏览。比如，下面的命令显示上次发布后的变动，每个 commit 占据一行。你只看行首，就知道某次 commit 的目的。1$ git log &lt;last tag&gt; HEAD --pretty=format:%s 可以过滤某些commit（比如文档改动），便于快速查找信息。比如，下面的命令仅仅显示本次发布新增加的功能。 1$ git log &lt;last release&gt; HEAD --grep feature 可以直接从commit生成Change log。Commitizen：撰写合格 Commit message 的工具Commitizen 是一个撰写合格 Commit message 的工具。使用之前，我们先安装它： 1$ npm install -g commitizen 然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。 1$ commitizen init cz-conventional-changelog --save --save-exact 以后，凡是用到 git commit 命令，一律改为使用 git cz。这时，就会出现选项，用来生成符合格式的 Commit message。 commitlintcommitlint 用于检查 Node 项目的 Commit message 是否符合格式。使用前，我们先安装它： 1234# Install commitlint cli and angular config$ npm install --save-dev @commitlint/&#123;config-conventional,cli&#125;# For Windows:$ npm install --save-dev @commitlint/config-conventional @commitlint/cli 接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为 commit-msg 时运行。12345678&#123; "husky": &#123; "hooks": &#123; "pre-commit": "lint-staged", "commit-msg": "commitlint -E HUSKY_GIT_PARAMS" &#125; &#125;&#125; 然后，每次 git commit 的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。这里面有使用 husky，所以我们还要安装 husky 才能使用。 1$ npm install husky@next --save-dev Change log如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。生成的文档包括以下三个部分： New features Bug fixes Breaking changes. conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。12$ npm install -g conventional-changelog-cli$ conventional-changelog -p angular -i CHANGELOG.md -s -w -r 0 为了方便使用，可以将其写入 package.json 的 scripts 字段：12345&#123; "scripts": &#123; "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s -w -r 0" &#125;&#125; 以后，直接运行下面的命令即可：1$ npm run changelog]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>commit message</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git修复线上指定版本的问题]]></title>
    <url>%2F2018%2F08%2F05%2Fgit-assign-version-fix.html</url>
    <content type="text"><![CDATA[作为一个码农，bug 就像家常便饭一样。有了 bug 就需要修复，在 git 中，由于分支是如此的强大，所以，每个 bug 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。今天我们就来聊聊如何使用git修复线上指定版本的问题？第一步：查看远程分支，并确定要修复的分支，如图，远程分支为origin/V1.2.0. 如果没有远程分支或不清楚是哪个分支，那我相信在您每开发完一个版本发布生产时都会打包一个标签，就比如我们团队用的 gitlab 管理的项目： 这边很清楚的能够看到我们有 3 个远程分支，59 个标签，找到对应的标签生成对应的分支即可。如果您们目前尚未使用 gitlab，那只能用 git 命令了，不懂的伙伴，强烈推荐去看廖大神git教程。 第二步：创建本地分支V1.2.0，并拉取远程分支代码，同时切换到本地分支，如图 第三步：开发新代码，比如我这边测试代码空格，如图 第四步：开发完成，正常提交流程：git status、git add -A、git commit -m “修复某某问题”，如图 第五步：提交完成，把本地分支推送到远程分支git push origin V1.2.0:V1.2.0 第六步：切换到开发分支：git checkout dev，然后合并刚才修改的代码：git merge V1.2.0 最后：删除新创建的分支：git branch -D V1.2.0]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>fix bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript模块打包工具Rollup——完全入门指南]]></title>
    <url>%2F2018%2F08%2F04%2Frollup-tutorial.html</url>
    <content type="text"><![CDATA[版本：v0.63.5。 Rollup 是前端模块化的一个打包工具，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。简单地说，它可以从一个入口文件开始，将所有使用的模块根据命令或者根据 Rollup 配置文件打包成一个目标文件，并且 Rollup 会自动过滤掉那些没有被使用过的函数或变量，从而使代码最小化，如果想使用直接导入这一个目标文件即可，因此 Rollup 极其适合构建一个工具库。 这里提到 Rollup 的两个特别重要的特性，第一个就是它使用了 ES2015 的模板标准，这意味着你可以直接使用 import 和 export 而不需要引入 babel。另一个重要特性叫做 tree-shaking，这个特性可以帮助你将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。举个简单的例子，我们在 foo.js 文件定义了 f1 和 f2 两个方法，然后在入口文件 index.js 只引入了 foo.js 文件中的 f1 方法，那么在最后打包 index.js 文件时，Rollup 就不会将 f2 方法打包到最终文件中。（这个特性是基于 ES6 模块的静态分析的，也就是说，只有 export 而没有 import 的变量是不会被打包到最终代码中的）。 入门创建第一个 bundle开始前，需要安装Node.js，这样才可以使用npm；还需要了解如何使用command line。 使用 Rollup 最简单的方法是通过 Command Line Interface （或 CLI）。先全局安装 Rollup （之后会介绍如何在项目中进行安装，更便于打包，但现在不用担心这个问题）。在命令行中输入以下内容： 1$ npm install rollup --global 现在可以运行 rollup 命令了。试试吧~ 1$ rollup 由于没有传递参数，所以 Rollup 打印出了使用说明。这和运行 rollup –help 或 rollup -h 的效果一样。 我们来创建一个简单的项目： 12$ mkdir -p my-rollup-project/src$ cd my-rollup-project 首先，我们需要个入口文件。将以下代码粘贴到新建的文件 src/main.js 中： 123456// src/main.jsimport &#123; foo1 &#125; from './foo.js';export default function () &#123; foo1();&#125; 之后创建入口文件引用的 foo.js 模块:12345678// src/foo.jsexport function foo1() &#123; console.log('function foo1')&#125;export function foo2() &#123; console.log('function foo2')&#125; 现在可以创建 bundle 了：1$ rollup src/main.js -o bundle.js -f cjs -o 表示打包后输出的文件路径，在 -o 后面的 bundle.js 就是我们最终生成的打包文件了（其实这里我们省略了参数 -i，用来表示入口文件的路径， Rollup 是会把没有加参数的文件默认是入口文件）；-f 选项（–output.format 的缩写）指定了所创建 bundle 的类型（默认使用 es 模块标准来对文件进行打包）——这里是 CommonJS（在 Node.js 中运行）。现在我们看一下输出文件 bundle.js：12345678910111213'use strict';function foo1() &#123; console.log('function foo1');&#125;// src/main.jsfunction main () &#123; foo1();&#125;module.exports = main; 恭喜，你已经用 Rollup 完成了第一个 bundle。 使用配置文件在项目中创建一个名为 rollup.config.js 的文件，增加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// rollup.config.js // 1. output 为对象export default &#123; input: 'src/main.js', output: &#123; file: 'bundle.js', format: 'cjs' &#125;&#125;;// 2. output 为数组export default &#123; input: 'src/main.js', output: [&#123; file: 'dist/bundle.cjs.js', format: 'cjs' &#125;, &#123; file: 'dist/bundle.umd.js', name: 'moduleName', format: 'umd' &#125;, &#123; file: 'dist/bundle.es.js', format: 'es' &#125;]&#125;;// 整个配置为数组export default [&#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.cjs1.js', format: 'cjs' &#125;&#125;, &#123; input: 'src/main.js', output: [&#123; file: 'dist/bundle.cjs2.js', format: 'cjs' &#125;, &#123; file: 'dist/bundle.umd2.js', name: 'moduleName', format: 'umd' &#125;, &#123; file: 'dist/bundle.es2.js', format: 'es' &#125;]&#125;] input 表示打包的入口文件，output 表示打包输出文件的配置（如果要输出多个，可以是一个数组，如果是数组，Rollup 会把每一个数组元素当成一个配置输出结果，因此可以在一个配置文件内设置多种输出配置），file 表示输出文件的名称路径，format 表示要打包成的模块类型。若使用 iife 或 umd 模块类型打包，需要添加属性moduleName，用来表示模块的名称；若用 amd 模块打包，可以配置 amd 相关的参数（使用 umd 模块模式时，也会使用到 amd 相关配置参数）：1234amd: &#123; id: 'amd-name', // amd具名函数名称 define: 'def' // 用来代替define函数的函数名称&#125; 我们用 –config 或 -c 来使用配置文件： 1$ rollup -c 同样的命令行选项将会覆盖配置文件中的选项：1$ rollup -c -o bundle-2.js 在这里我们发现配置文件使用了 ES6 语法，这是因为 Rollup 本身会处理配置文件 ，所以可以使用 export default 语法——代码不会经过 Babel 等类似工具编译，所以只能使用所用 Node.js 版本支持的 ES2015 语法。 如果愿意的话，也可以指定与默认 rollup.config.js 文件不同的配置文件：12$ rollup --config rollup.config.dev.js$ rollup --config rollup.config.prod.js 当然，我们也可以在 package.json 文件中编写 npm scripts 命令： 1"build": "rollup -c" 针对不同模板类型我们简单编写几个命令：123456"build:amd": "rollup index.js -f amd -o ./dist/dist.amd.js","build:cjs": "rollup index.js -f cjs -o ./dist/dist.cjs.js","build:es": "rollup index.js -f es -o ./dist/dist.es.js","build:iife": "rollup index.js -f iife -n result -o ./dist/dist.iife.js","build:umd": "rollup index.js -f umd -n result -o ./dist/dist.umd.js","build": "npm run build:amd &amp;&amp; npm run build:cjs &amp;&amp; npm run build:es &amp;&amp; npm run build:iife &amp;&amp; npm run build:umd" 在这里我们发现在设置模块为 iife（立即执行函数）和 umd 时，还加上了一个参数 -n，这是为了事先设定模块的名称，才能让其他人通过这个模块名称引用。 使用ES6编写代码许多开发人员在他们的项目中使用Babel，以便他们可以使用未被浏览器和 Node.js 支持的将来版本的 JavaScript 特性。Rollup 虽然支持了解析 import 和 export 两种语法，但是不会解析其他不被支持 JavaScript 特性，使用 Babel 和 Rollup 的最简单方法是使用rollup-plugin-babel。 安装它：1$ npm i -D babel-core rollup-plugin-babel rollup-plugin-node-resolve 编写 Rollup 配置文件 rollup.config.js:12345678910111213141516171819// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'cjs' &#125;, plugins: [ json(), resolve(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;) ]&#125;; 这里有几个特别注意的地方。首先，我们设置 “modules”: false，否则 Babel 会在 Rollup 有机会做处理之前，将我们的模块转成 CommonJS，导致 Rollup 的一些处理失败。 其次，我们使用 external-helpers 插件，它允许 Rollup 在包的顶部只引用一次 “helpers”，而不是每个使用它们的模块中都引用一遍（这是默认行为）。 第三，我们将 .babelrc 文件放在 src 中，而不是根目录下。 这允许我们对于不同的任务有不同的 .babelrc 配置，比如像测试，如果我们以后需要的话 - 通常为单独的任务单独配置会更好。 现在，在我们运行 rollup 之前，我们需要安装 latest preset 和 external-helpers 插件： 1$ npm i -D babel-preset-latest babel-plugin-external-helpers 现在我们用 es6 编辑 src / main.js： 123456// src/main.jsimport &#123; version &#125; from '../package.json';export default () =&gt; &#123; console.log('version：' + version);&#125; 运行 Rollup npm run build，检查打包后的 bundle：1234567891011'use strict';var version = "0.0.1";// src/main.jsvar main$1 = (function () &#123; console.log('version：' + version);&#125;);module.exports = main$1; 配置文件配置参数external：为rollup设置外部模块和全局变量平时开发中，我们经常会引入一些第三方模块，但是在使用的时候，我们又不想把它们打包到一个文件里，想让它们作为单独的模块（或文件）来使用，方便浏览器进行缓存，这个时候就需要使用配置文件中的 external 属性了。 我们这边以 jquery 为例，在开始使用之前，我们先安装它：1$ npm i jquery --save-dev 编写 Rollup 配置文件 rollup.config.js，加入external配置:12345678910111213141516171819202122// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs'export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'cjs' &#125;, plugins: [ json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;) ], external: ['jquery']&#125;; external 用来表示一个模块是否要被当成外部模块使用，属性的值可以是一个字符串数组或一个方法，当传入的是一个字符串数组时，所有数组内的模块名称都会被当成是外部模块，不会被打包到最终文件中。当传入的是一个方法时，方法有一个参数 id，表示解析的模块的名称，我们可以自定义解析方式，若是要当做外部模块不打包到最终文件中，则返回 true，若要一起打包到最终文件中，则返回 false。 globalsglobals 的值是一个对象，key表示使用的模块名称（npm 模块名），value 表示在打包文件中引用的全局变量名，在这里我们就是把jquery模块的全局变量名设置为jQuery，重新打包。 编写 Rollup 配置文件 rollup.config.js，加入globals配置:1234567891011121314151617181920212223242526// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs'export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', name: 'result', format: 'iife', globals: &#123; jquery: 'jQuery' &#125; &#125;, plugins: [ json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;) ], external: ['jquery']&#125;; 运行 Rollup npm run build，检查打包后的 bundle： 1234567891011121314151617var result = (function (jQuery) &#123; 'use strict'; jQuery = jQuery &amp;&amp; jQuery.hasOwnProperty('default') ? jQuery['default'] : jQuery; var version = "0.0.1"; // src/main.js var main$1 = (function () &#123; console.log(jQuery); console.log('version：' + version); &#125;); return main$1;&#125;(jQuery)); 在重新打包出来的文件中，我们发现最后传入的参数已经由 $ 变为了 jQuery，而且 Rollup 也没有输出提示信息。 paths有时候我们可能会使用 CDN 上的 js 文件，但是又不想在本地安装一个相同的模块（也有可能没有对应的模块），可能在版本升级的时候会产生一些问题，这个时候我们就需要使用 Rollup 的 paths 属性了，这个属性可以帮你把依赖的文件地址注入到打包后的文件里。 编写 Rollup 配置文件 rollup.config.js，加入 paths 配置: 1234567891011121314151617181920212223242526272829// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs'export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', name: 'result', format: 'amd', globals: &#123; jquery: 'jQuery' &#125;, paths: &#123; jquery: 'https://cdn.bootcss.com/jquery/3.2.1/jquery.js' &#125; &#125;, plugins: [ json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;) ], external: ['jquery']&#125;; 运行 Rollup npm run build，检查打包后的 bundle： 12345678910111213141516define(['https://cdn.bootcss.com/jquery/3.2.1/jquery.js'], function (jQuery) &#123; 'use strict'; jQuery = jQuery &amp;&amp; jQuery.hasOwnProperty('default') ? jQuery['default'] : jQuery; var version = "0.0.1"; // src/main.js var main$1 = (function () &#123; console.log(jQuery); console.log('version：' + version); &#125;); return main$1;&#125;); 可以看到 Rollup 已经把我们需要的 CDN 地址作为依赖加入到了打包文件中。 插件使用插件随着构建更复杂的 bundle，通常需要更大的灵活性——引入 npm 安装的模块、通过 Babel 编译代码、和 JSON 文件打交道等。为此，我们可以用 插件(plugins) 在打包的关键过程中更改 Rollup 的行为。the Rollup wiki维护了可用的插件列表。 我们这边将以rollup-plugin-json的使用为例，它的作用是令 Rollup 从 JSON 文件中读取数据。 将 rollup-plugin-json 安装为开发依赖：1$ npm install --save-dev rollup-plugin-json 我们用的是 –save-dev 而不是 –save，因为实际执行的代码并不依赖这个插件——只是在打包时使用。 更新 src/main.js 文件，从 package.json 而非 src/foo.js 中读取数据：123456// src/main.jsimport &#123; version &#125; from '../package.json';export default function () &#123; console.log('version：' + version);&#125; 编写 Rollup 配置文件 rollup.config.js，加入 JSON 插件：1234567891011// rollup.config.jsimport json from 'rollup-plugin-json';export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'cjs' &#125;, plugins: [ json() ]&#125;; npm run build 执行 Rollup。结果如下：1234567891011'use strict';var version = "0.0.1";// src/main.jsfunction main$1 () &#123; console.log('version：' + version);&#125;module.exports = main$1; 插件列表rollup-plugin-commonjs有时候我们会引入一些其他模块的文件（第三方的或是自己编写的），但是目前，npm 中的大多数包都是以 CommonJS 模块的形式出现的。在它们更改之前，我们需要将CommonJS模块转换为 ES2015 供 Rollup 解析。这个rollup-plugin-commonjs插件就是用来将 CommonJS 转换成 ES2015 模块的。请注意，rollup-plugin-commonjs 应该用在其他插件转换你的模块之前 - 这是为了防止其他插件的改变破坏 CommonJS 的检测。 在我们使用之前，需要先安装它：1$ npm i rollup-plugin-commonjs --save-dev 编写 Rollup 配置文件 rollup.config.js: 123456789101112131415161718192021// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs'export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'cjs' &#125;, plugins: [ json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;) ]&#125;; 编写 cjs 模块的文件： 1234567exports.foo1 = function() &#123; console.log('function foo1')&#125;exports.foo2 = function() &#123; console.log('function foo2')&#125; npm run build 执行 Rollup。结果如下：1234567891011'use strict';var version = "0.0.1";// src/main.jsvar main$1 = (function () &#123; console.log('version：' + version);&#125;);module.exports = main$1; rollup-plugin-uglify代码发布时，我们经常会把自己的代码压缩到最小，以减少网络请求中的传输文件大小。Rollup rollup-plugin-uglify 就是来帮你压缩代码的，在使用之前，我们先安装它：1$ npm i rollup-plugin-uglify --save-dev 编写 Rollup 配置文件 rollup.config.js，加入 uglify 插件： 12345678910111213141516171819202122232425262728293031// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs';import &#123; uglify &#125; from 'rollup-plugin-uglify'export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', name: 'result', format: 'amd', globals: &#123; jquery: 'jQuery' &#125;, paths: &#123; jquery: 'https://cdn.bootcss.com/jquery/3.2.1/jquery.js' &#125; &#125;, plugins: [ json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;), uglify() ], external: ['jquery']&#125;; 运行打包命令，查看打包后的目标文件，发现代码已经被压缩了。但是，压缩过的代码在 debug 时会带来很大的不便，因此我们需要在压缩代码的同时生成一个 sourceMap 文件。幸运的是，Rollup 自己就支持 sourceMap 文件的生成，不需要我们去引入其他插件，只需要在配置文件中 output 选项加上以下代码即可： 12// rollup.config.jssourcemap: true 若是将 sourceMap 属性的值设置为 inline，则会将 sourceMap 的内容添加到打包文件的最后。 rollup-plugin-eslint在大型工程的团队开发中，我们需要保证团队代码风格的一致性，因此需要引入 eslint，而且在打包时需要检测源文件是否符合 eslint 设置的规范，若是不符合则抛出异常并停止打包。Rollup rollup-plugin-eslint 就是用于设置代码规范，使用之前我们先安装它： 1$ npm i eslint rollup-plugin-eslint --save-dev 编写 eslint 配置文件 .eslintrc： 1234567891011121314151617&#123; "env": &#123; "browser": true, "commonjs": true, "es6": true, "node": true &#125;, "parserOptions": &#123; "ecmaFeatures": &#123; "jsx": false &#125;, "sourceType": "module" &#125;, "rules": &#123; "semi": ["error","never"] &#125;&#125; 编写 Rollup 配置文件 rollup.config.js，加入 eslint 插件：123456789101112131415161718192021222324252627282930313233343536373839// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs';import &#123; uglify &#125; from 'rollup-plugin-uglify';import &#123; eslint &#125; from 'rollup-plugin-eslint';export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', name: 'result', format: 'amd', globals: &#123; jquery: 'jQuery' &#125;, paths: &#123; jquery: 'https://cdn.bootcss.com/jquery/3.2.1/jquery.js' &#125;, sourcemap: true &#125;, plugins: [ eslint(&#123; throwOnError: true, throwOnWarning: true, include: ['src/**'], exclude: ['node_modules/**'] &#125;), json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;), uglify() ], external: ['jquery']&#125;; 这里有两个属性需要特别说明下：throwOnError 和 throwOnWarning 设置为 true 时，如果在 eslint 的检查过程中发现了 error 或 warning，就会抛出异常，阻止打包继续执行（如果设置为 false，就只会输出 eslint 检测结果，而不会停止打包）。 如果我们使用IDE或编辑器的 eslint 插件，有时候这些插件会去检查打包完的文件，导致你的提示框里一直会有 eslint 检测到错误的消息，我们现在有两种解决方案，第一种是创建一个 .eslintignore 文件，将打包文件加进去，让 eslint 忽略这个文件，还有一种就是让 Rollup 在打包文件的开始和最后自动生成注释来阻止 eslint 检测代码，使用这种方法时，需要使用 Rollup 配置文件的两个属性：banner和footer，这两个属性会在生成文件的开头和结尾插入一段你自定义的字符串。我们利用这个属性，在打包文件的开头添加/*eslint-disable */注释，让 eslint 不检测这个文件。 添加banner和footer属性 1banner: '/*eslint-disable */' 如果说 banner 和 footer 是在文件开始和结尾添加字符串，那么 intro 和 outro 就是在被打包的代码开头和结尾添加字符串了，以 iife 模式来举例，如果我们配置了这四个属性，那么输出结果就会是：12345678910// banner字符串(function () &#123;'use strict';// intro字符串// 被打包的代码// outro字符串&#125;());// footer字符串 rollup-plugin-replace有时候我们会把开发/生产环境的信息直接写在源文件里面，这个时候用 intro/outro 来注入代码的方式就不适合了。这个时候我们就需要使用 rollup-plugin-replace 插件来对源代码的变量值进行替换，在使用之前，我们先安装它： 1$ npm i rollup-plugin-replace --save-dev 编写 Rollup 配置文件 rollup.config.js，加入 replace 插件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// rollup.config.jsimport json from 'rollup-plugin-json';import resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import commonjs from 'rollup-plugin-commonjs';import &#123; uglify &#125; from 'rollup-plugin-uglify';import &#123; eslint &#125; from 'rollup-plugin-eslint';import &#123; version &#125; from '../package.json';import replace from 'rollup-plugin-replace';const VERSION = process.env.VERSION || version;const copyright = new Date().getFullYear() &gt; 2018 ? '2018-' + new Date().getFullYear() : 2018;const banner = '/*!\n' + ' * idebug v' + VERSION + '\n' + ' * (c) ' + copyright + ' Weich\n' + ' * Released under the MIT License.\n' + ' */';// const weexFactoryPlugin = &#123;// intro () &#123;// return 'module.exports = function weexFactory (exports, document) &#123;'// &#125;,// outro () &#123;// return '&#125;'// &#125;// &#125;;export default &#123; input: 'src/main.js', output: &#123; banner: banner, footer: '/* my-library version ' + VERSION + ' */', file: 'dist/bundle.js', name: 'result', format: 'iife', globals: &#123; jquery: 'jQuery' &#125;, paths: &#123; jquery: 'https://cdn.bootcss.com/jquery/3.2.1/jquery.js' &#125;, sourcemap: true &#125;, plugins: [ // weexFactoryPlugin, replace(&#123; __VERSION__: VERSION &#125;), eslint(&#123; throwOnError: true, throwOnWarning: true, include: ['src/**'], exclude: ['node_modules/**'] &#125;), json(), resolve(), commonjs(), babel(&#123; exclude: 'node_modules/**' // 只编译我们的源代码 &#125;), uglify(&#123; output: &#123; comments: function(node, comment) &#123; var text = comment.value; var type = comment.type; if (type == "comment2") &#123; // multiline comment return /idebug|ENVIRONMENT/i.test(text); &#125; &#125; &#125; &#125;) ], external: ['jquery']&#125;; 接下来就可以直接在源码中使用 __VERSION__ 了，编写入口文件 index.js：1234567// src/main.jsimport jQuery from 'jquery'export default () =&gt; &#123; console.log(jQuery) console.log('version：__VERSION__' )&#125; 执行打包命令，并检查源文件里有没有被替换。 命令行命令行的参数-v/--version：打印已安装的Rollup版本号。 -w/--watch：我们在开发过程中，需要频繁对源文件进行修改，如果每次都自己手动输一遍打包命令，那真的是要烦死，因此，我们在 rollup 命令后面加上 -w/–watch 参数，就能让 rollup 监听文件变化，即时打包。 本文持续更新中]]></content>
      <categories>
        <category>rollup</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端(手机端)页面自适应解决方案—rem布局篇]]></title>
    <url>%2F2018%2F08%2F03%2Fmobile-rem-layout.html</url>
    <content type="text"><![CDATA[假设设计妹妹给我们的设计稿尺寸为750 * 1340。结合网易、淘宝移动端首页html元素上的动态font-size属性、设计稿尺寸、前端与设计之间协作流程一般分为下面两种： 一、网易做法：引入：页面开头处引入下面这段代码，用于动态计算font-size 12345678910111213141516171819202122232425(function(doc, win) &#123; var docEl = doc.documentElement, isIOS = navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), dpr = isIOS ? Math.min(win.devicePixelRatio, 3) : 1, dpr = window.top === window.self ? dpr : 1, //被iframe引用时，禁止缩放 dpr = 1, scale = 1 / dpr, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize'; docEl.dataset.dpr = dpr; var metaEl = doc.createElement('meta'); metaEl.name = 'viewport'; metaEl.content = 'initial-scale=' + scale + ',maximum-scale=' + scale + ', minimum-scale=' + scale; docEl.firstElementChild.appendChild(metaEl); var recalc = function() &#123; var width = docEl.clientWidth; if (width / dpr &gt; 750) &#123; width = 750 * dpr; &#125; // 乘以100，px : rem = 100 : 1 docEl.style.fontSize = 100 * (width / 750) + 'px'; &#125;; recalc() if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false);&#125;)(document, window); 使用：未引入前：1234body &#123; width: 750px; height: 640px;&#125; 引入后：除以100并将px换成rem 1234body &#123; width: 7.5rem; height: 6.4rem;&#125; 换算的依据： 123456789// 乘以100，px : rem = 100 : 1var recalc = function() &#123; var width = docEl.clientWidth; if (width / dpr &gt; 750) &#123; width = 750 * dpr; &#125; // 乘以100，px : rem = 100 : 1 docEl.style.fontSize = 100 * (width / 750) + 'px';&#125;; 二、淘宝做法（推荐做法，尤其是app内嵌页面）：引入：页面开头处引入下面这段代码，用于动态计算font-size，或者单独放入一个文件，引入文件也可以 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118;(function(win, lib) &#123; var doc = win.document; var docEl = doc.documentElement; var metaEl = doc.querySelector('meta[name="viewport"]'); var flexibleEl = doc.querySelector('meta[name="flexible"]'); var dpr = 0; var scale = 0; var tid; var flexible = lib.flexible || (lib.flexible = &#123;&#125;); if (metaEl) &#123; var match = metaEl.getAttribute('content').match(/initial\-scale=([\d\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125; &#125; else if (flexibleEl) &#123; var content = flexibleEl.getAttribute('content'); if (content) &#123; var initialDpr = content.match(/initial\-dpr=([\d\.]+)/); var maximumDpr = content.match(/maximum\-dpr=([\d\.]+)/); if (initialDpr) &#123; dpr = parseFloat(initialDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; if (maximumDpr) &#123; dpr = parseFloat(maximumDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; &#125; &#125; if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) &#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; &#125; docEl.setAttribute('data-dpr', dpr); if (!metaEl) &#123; metaEl = doc.createElement('meta'); metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(metaEl); &#125; else &#123; var wrap = doc.createElement('div'); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); &#125; &#125; function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; // 适配平板 if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem; &#125; win.addEventListener('resize', function() &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener('pageshow', function(e) &#123; if (e.persisted) &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); if (doc.readyState === 'complete') &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125; else &#123; doc.addEventListener('DOMContentLoaded', function(e) &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125;, false); &#125; refreshRem(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = refreshRem; flexible.rem2px = function(d) &#123; var val = parseFloat(d) * this.rem; if (typeof d === 'string' &amp;&amp; d.match(/rem$/)) &#123; val += 'px'; &#125; return val; &#125; flexible.px2rem = function(d) &#123; var val = parseFloat(d) / this.rem; if (typeof d === 'string' &amp;&amp; d.match(/px$/)) &#123; val += 'rem'; &#125; return val; &#125;&#125;)(window, window['lib'] || (window['lib'] = &#123;&#125;)); 使用： 未引入前： 1234body &#123; width: 750px; height: 640px;&#125; 引入后： 12345@font-size-base: 75;body &#123; width: 750rem/@font-size-base; height: 640rem/@font-size-base;&#125; 换算依据： 12345678910function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; // 适配平板 if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125; 这边是用的less，如果您没有用less，就需要手动计算，当然也可以转化为px : rem = 100 : 1。如果想转化为px : rem = 100 : 1，可以修改上面的refreshRem函数： 12345678910function refreshRem() &#123; var width = docEl.getBoundingClientRect().width // 适配平板 if (width / dpr &gt; 750) &#123; width = 750 * dpr &#125; var rem = 100 * (width / 750) docEl.style.fontSize = rem + 'px' flexible.rem = win.rem = rem;&#125; 使用： 未引入前： 1234body &#123; width: 750px; height: 640px;&#125; 引入后：除以100并将px换成rem 1234body &#123; width: 7.5rem; height: 6.4rem;&#125; 换算依据就是上面修改的代码： 12345678910function refreshRem() &#123; var width = docEl.getBoundingClientRect().width // 适配平板 if (width / dpr &gt; 750) &#123; width = 750 * dpr &#125; var rem = 100 * (width / 750) docEl.style.fontSize = rem + 'px' flexible.rem = win.rem = rem;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next、nuxt等服务端渲染框架如何在服务器部署，并用PM2守护程序]]></title>
    <url>%2F2018%2F08%2F03%2Flinux-nginx-ssr-deploy.html</url>
    <content type="text"><![CDATA[貌似从前几年，前后端分离逐渐就开始流行起来，把一些渲染计算的工作抛向前端以便减轻服务端的压力，但为啥现在又开始流行在服务端渲染了呢？如vue全家桶或者react全家桶，都推荐通过服务端渲染来实现路由。搞得我们慌得不行，不禁让我想起一句话：从来没有任何一门语言的技术栈像Javascript一样，学习者拼尽全力也不让精通。没办法，流行，咱们就得学！ 前断时间写了一篇vuejs、react如何在服务器部署？，结果反响不错！最近好多朋友私信或邀请问很多关于next.js和nuxt.js的问题，比如关于nextjs 和 nuxtjs如何部署，pm2如何配合…在这里我们就一起讨论下在服务器上使用PM2守护next.js、nuxt.js等服务端渲染框架构建的项目！该篇我们只讨论服务端渲染应用部署，静态应用部署就是我前段时间写的vuejs、react如何在服务器部署？。 Nginx配置既然是应用，我们就应该有域名，在这里我们以nginx配置为例，简单配置如下：Next域名：http://next.sosout.com/Nuxt域名：http://nuxt.sosout.com/123456789101112131415161718192021222324252627282930http &#123; .... # 省略其他配置 server &#123; listen 80; server_name *.sosout.com; if ($host ~* "^(.*?)\.sosout\.com$") &#123; set $domain $1; &#125; location / &#123; if ($domain ~* "next") &#123; root /mnt/html/next; &#125; if ($domain ~* "nuxt") &#123; root /mnt/html/nuxt; &#125; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; access_log /mnt/logs/nginx/access.log main; &#125; #tcp_nopush on; include /etc/nginx/conf.d/*.conf;&#125; Nginx反向代理由于服务端渲染的各个应用端口号各不相同，因此这个时候我们就需要反向代理了，配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#通过upstream nodejs 可以配置多台nodejs节点，做负载均衡#keepalive 设置存活时间。如果不设置可能会产生大量的timewait#proxy_pass 反向代理转发 http://nodejsupstream nodenext &#123; server 127.0.0.1:3001; #next项目 监听端口 keepalive 64;&#125;server &#123; listen 80; server_name next.sosout.com; location / &#123; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header Host $host; proxy_set_header X-Nginx-Proxy true; proxy_cache_bypass $http_upgrade; proxy_pass http://nodenext; #反向代理 &#125;&#125;upstream nodenuxt &#123; server 127.0.0.1:3002; #nuxt项目 监听端口 keepalive 64;&#125;server &#123; listen 80; server_name nuxt.sosout.com; location / &#123; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header Host $host; proxy_set_header X-Nginx-Proxy true; proxy_cache_bypass $http_upgrade; proxy_pass http://nodenuxt; #反向代理 &#125;&#125; 服务器的准备工作已完成，接下来我们就分别看看Next.js和Nuxt.js服务端渲染应用如何部署？ Next.js服务端渲染应用部署部署 Next.js 服务端渲染的应用不能直接使用next命令，而应该先进行编译构建，然后再启动 Next 服务，官方通过以下两个命令来完成：12$ next build$ next start 官方推荐的 package.json 配置如下： 1234567891011&#123; "name": "my-app", "dependencies": &#123; "next": "latest" &#125;, "scripts": &#123; "dev": "next", "build": "next build", "start": "next start" &#125;&#125; 而我更推荐如下配置，稍后你会发现这样和pm2一起使用更方便，自动化部署也方便: 1234567891011&#123; "name": "my-app", "dependencies": &#123; "next": "latest" &#125;, "scripts": &#123; "dev": "next", "start": "next start -p $PORT", "build": "next build &amp;&amp; PORT=3001 npm start" &#125;&#125; next.js服务端渲染应用部署这样就完成了，官方先后执行npm run build 、npm start即可完成部署。而我这边只要执行npm run build，其实我只是把两个合并成一个，并设置了端口以便区别其他应用，避免端口占用！ 接下来简单的说一下next这几个命令：next:启动一个热加载的Web服务器（开发模式）next build:利用webpack编译应用，压缩JS和CSS资源（发布用）。next start:以生成模式启动一个Web服务器 (next build 会先被执行)。 Nuxt.js服务端渲染应用部署其实部署 Nuxt.js 服务端渲染的应用和Next.js极其相似！在这里我就把代码粘粘贴贴，复复制制，改改写写。。。。Nuxt.js 服务端渲染的应用不能直接使用nuxt命令，而应该先进行编译构建，然后再启动 Nuxt 服务，官方通过以下两个命令来完成： 12$ nuxt build$ nuxt start 官方推荐的 package.json 配置如下： 1234567891011&#123; "name": "my-app", "dependencies": &#123; "nuxt": "latest" &#125;, "scripts": &#123; "dev": "nuxt", "build": "nuxt build", "start": "nuxt start" &#125;&#125; 而我更推荐如下配置，稍后你会发现这样和pm2一起使用更方便，自动化部署也方便: 1234567891011&#123; "name": "my-app", "dependencies": &#123; "nuxt": "latest" &#125;, "scripts": &#123; "dev": "nuxt", "start": "PORT=3002 nuxt start", "build": "nuxt build &amp;&amp; npm start" &#125;&#125; nuxt.js服务端渲染应用部署这样就完成了，官方先后执行npm run build 、npm start即可完成部署。而我这边只要执行npm run build，其实我只是把两个合并成一个，并设置了端口以便区别其他应用，避免端口占用！ 接下来简单的说一下nuxt这几个命令：nuxt:启动一个热加载的Web服务器（开发模式）nuxt build:利用webpack编译应用，压缩JS和CSS资源（发布用）。nuxt start:以生成模式启动一个Web服务器 (nuxt build 会先被执行)。 PM2守护程序Next.js使用pm2，进入对应的应用目录，执行以下命令： 1$ pm2 start npm --name "my-next" -- run build Nuxt.js使用pm2，进入对应的应用目录，执行以下命令： 1$ pm2 start npm --name "my-nuxt" -- run build 使用pm2时，把两个部署命令合成一个更方便！执行完pm2的启动命令后，我们用pm2 list查看一下进程列表，我截一下我个人服务器的pm2列表： 以后您就可以用pm2进行维护了，比如我们的next应用更改了代码，因为当时创建时给next应用命名的进程名称为my-next，因此我们可以直接使用pm2 reload my-next进行重载。接下来我就简单介绍一下pm2，如果有需要，我可以另写一篇关于pm2的文章！ pm2 简单介绍pm2是nodejs的一个带有负载均衡功能的应用进程管理器的模块，类似有Supervisor，forever，用来进行进程管理。 一、安装：1$ npm install pm2 -g 二、启动：1234$ pm2 start app.js$ pm2 start app.js --name my-api #my-api为PM2进程名称$ pm2 start app.js -i 0 #根据CPU核数启动进程个数$ pm2 start app.js --watch #实时监控app.js的方式启动，当app.js文件有变动时，pm2会自动reload 三、查看进程：12$ pm2 list$ pm2 show 0 或者 # pm2 info 0 #查看进程详细信息，0为PM2进程id 四、监控：1$ pm2 monit 五、停止：12$ pm2 stop all #停止PM2列表中所有的进程$ pm2 stop 0 #停止PM2列表中进程为0的进程 六、重载：12$ pm2 reload all #重载PM2列表中所有的进程$ pm2 reload 0 #重载PM2列表中进程为0的进程 七、重启：12$ pm2 restart all #重启PM2列表中所有的进程$ pm2 restart 0 #重启PM2列表中进程为0的进程 八、删除PM2进程：12$ pm2 delete 0 #删除PM2列表中进程为0的进程$ pm2 delete all #删除PM2列表中所有的进程 九、日志操作：123$ pm2 logs [--raw] #Display all processes logs in streaming$ pm2 flush #Empty all log file$ pm2 reloadLogs #Reload all logs 十、升级PM2：12$ npm install pm2@lastest -g #安装最新的PM2版本$ pm2 updatePM2 #升级pm2 十一、更多命令参数请查看帮助：1$ pm2 --help 十二、PM2目录结构： 1、默认的目录是：当前用于的家目录下的.pm2目录（此目录可以自定义，请参考：十三、自定义启动文件），详细信息如下：12345678$HOME/.pm2 #will contain all PM2 related files$HOME/.pm2/logs #will contain all applications logs$HOME/.pm2/pids #will contain all applications pids$HOME/.pm2/pm2.log #PM2 logs$HOME/.pm2/pm2.pid #PM2 pid$HOME/.pm2/rpc.sock #Socket file for remote commands$HOME/.pm2/pub.sock #Socket file for publishable events$HOME/.pm2/conf.js #PM2 Configuration 十三、自定义启动文件： 1、创建一个test.json的示例文件，格式如下： 12345678910111213141516&#123; "apps": &#123; "name": "test", "cwd": "/data/wwwroot/nodejs", "script": "./test.sh", "exec_interpreter": "bash", "min_uptime": "60s", "max_restarts": 30, "exec_mode" : "cluster_mode", "error_file" : "./test-err.log", "out_file": "./test-out.log", "pid_file": "./test.pid" "watch": false &#125;&#125; 2、参数说明： 123456789101112apps：json结构，apps是一个数组，每一个数组成员就是对应一个pm2中运行的应用name：应用程序的名称cwd：应用程序所在的目录script：应用程序的脚本路径exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejsmin_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量max_restarts：设置应用程序异常退出重启的次数，默认15次（从0开始计数）exec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是forkerror_file：自定义应用程序的错误日志文件out_file：自定义应用程序日志文件pid_file：自定义应用程序的pid文件watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件。 部署（以nuxt为例）基础模板的部署方式何为基础模板？使用了vue init nuxt-community/starter-template &lt;project-name&gt;进行搭建的！ 第一步，打包在执行npm run build的时候，nuxt会自动打包。 第二步，选择要部署的文件（社友最关心的步骤）： .nuxt/文件夹 package.json文件 nuxt.config.js文件(如果你配置proxy等，则需要上传这个文件，建议把它传上去) 第三步，启动你的nuxt：使用pm2启动你的nuxt.js： 12$ npm install // or yarn install 如果未安装依赖或依赖有更改$ pm2 start npm --name "my-nuxt" -- run start]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pm2</tag>
        <tag>nginx</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuejs、react如何在服务器部署？]]></title>
    <url>%2F2018%2F08%2F02%2Flinux-nginx-spa-deploy.html</url>
    <content type="text"><![CDATA[最近好多伙伴说，我用vue做的项目本地是可以的，但部署到服务器遇到好多问题：资源找不到，直接访问index.html页面空白，刷新当前路由404。。。用react做的项目也同样遇到类似问题。现在我们一起讨论下单页面如何部署到服务器？ 由于前端路由缘故，单页面应用应该放到nginx或者apache、tomcat等web代理服务器中，千万不要直接访问index.html，同时要根据自己服务器的项目路径更改react或vue的路由地址。 如果说项目是直接跟在域名后面的，比如:http://www.sosout.com，根路由就是/。如果说项目是直接跟在域名后面的一个子目录中的，比如:http://www.sosout.com/children ，根路由就是/children，不能直接访问index.html。 以配置nginx为例，配置过程大致如下： 我们首先假设以下两条规则：1. 项目文件目录： /mnt/html/spa（spa目录下的文件就是执行了npm run dist 后生成的dist目录下的文件）2. 访问域名：spa.sosout.com 进入nginx.conf新增如下配置： 123456789101112131415161718server &#123; listen 80; server_name spa.sosout.com; root /mnt/html/spa; index index.html; location ~ ^/favicon\.ico$ &#123; root /mnt/html/spa; &#125; location / &#123; try_files $uri $uri/ /index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; access_log /mnt/logs/nginx/access.log main;&#125; 注意事项：1、配置域名的话，需要80端口，成功后，只要访问域名即可访问的项目2、如果你使用了react-router的 browserHistory 模式或 vue-router的 history 模式，在nginx配置还需要重写路由： 12345678910111213141516171819202122server &#123; listen 80; server_name spa.sosout.com; root /mnt/html/spa; index index.html; location ~ ^/favicon\.ico$ &#123; root /mnt/html/spa; &#125; location / &#123; try_files $uri $uri/ @fallback; index index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; location @fallback &#123; rewrite ^.*$ /index.html break; &#125; access_log /mnt/logs/nginx/access.log main;&#125; 为什么要重写路由？因为我们的项目只有一个根入口，当输入类似/home的url时，如果找不到对应的页面，nginx会尝试加载index.html，这是通过react-router或vue-router就能正确的匹配我们输入的/home路由，从而显示正确的home页面，如果browserHistory模式或history模式的项目没有配置上述内容，会出现404的情况。 简单举两个例子，一个vue项目一个react项目： vue项目： 域名：http://tb.sosout.com 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import App from '../App'// 首页const home = r =&gt; require.ensure([], () =&gt; r(require('../page/home/index')), 'home')// 物流const logistics = r =&gt; require.ensure([], () =&gt; r(require('../page/logistics/index')), 'logistics')// 购物车const cart = r =&gt; require.ensure([], () =&gt; r(require('../page/cart/index')), 'cart')// 我的const profile = r =&gt; require.ensure([], () =&gt; r(require('../page/profile/index')), 'profile')// 登录界面const login = r =&gt; require.ensure([], () =&gt; r(require('../page/user/login')), 'login')export default [&#123; path: '/', component: App, // 顶层路由，对应index.html children: [&#123; path: '/home', // 首页 component: home &#125;, &#123; path: '/logistics', // 物流 component: logistics, meta: &#123; login: true &#125; &#125;, &#123; path: '/cart', // 购物车 component: cart, meta: &#123; login: true &#125; &#125;, &#123; path: '/profile', // 我的 component: profile &#125;, &#123; path: '/login', // 登录界面 component: login &#125;, &#123; path: '*', redirect: '/home' &#125;]&#125;] 12345678910111213141516171819202122232425262728293031323334############# 其他配置############http &#123; ############ # 其他配置 ############ server &#123; listen 80; server_name tb.sosout.com; root /mnt/html/tb; index index.html; location ~ ^/favicon\.ico$ &#123; root /mnt/html/tb; &#125; location / &#123; try_files $uri $uri/ @fallback; index index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; location @fallback &#123; rewrite ^.*$ /index.html break; &#125; access_log /mnt/logs/nginx/access.log main; &#125; ############ # 其他配置 ############ &#125; react项目： 域名：http://antd.sosout.com 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/*** 疑惑一：* React createClass 和 extends React.Component 有什么区别?* 之前写法：* let app = React.createClass(&#123;* getInitialState: function()&#123;* // some thing* &#125;* &#125;)* ES6写法(通过es6类的继承实现时state的初始化要在constructor中声明)：* class exampleComponent extends React.Component &#123;* constructor(props) &#123;* super(props);* this.state = &#123;example: 'example'&#125;* &#125;* &#125;*/import React, &#123;Component, PropTypes&#125; from 'react'; // react核心import &#123; Router, Route, Redirect, IndexRoute, browserHistory, hashHistory &#125; from 'react-router'; // 创建route所需import Config from '../config/index';import layout from '../component/layout/layout'; // 布局界面import login from '../containers/login/login'; // 登录界面/** * (路由根目录组件，显示当前符合条件的组件) * * @class Roots * @extends &#123;Component&#125; */class Roots extends Component &#123; render() &#123; // 这个组件是一个包裹组件，所有的路由跳转的页面都会以this.props.children的形式加载到本组件下 return ( &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; ) &#125;&#125;// const history = process.env.NODE_ENV !== 'production' ? browserHistory : hashHistory;// 快速入门const home = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/home/homeIndex').default) &#125;, 'home');&#125;// 百度图表-折线图const chartLine = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/charts/lines').default) &#125;, 'chartLine');&#125;// 基础组件-按钮const button = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/general/buttonIndex').default) &#125;, 'button');&#125;// 基础组件-图标const icon = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/general/iconIndex').default) &#125;, 'icon');&#125;// 用户管理const user = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/user/userIndex').default) &#125;, 'user');&#125;// 系统设置const setting = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/setting/settingIndex').default) &#125;, 'setting');&#125;// 广告管理const adver = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/adver/adverIndex').default) &#125;, 'adver');&#125;// 组件一const oneui = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/ui/oneIndex').default) &#125;, 'oneui');&#125;// 组件二const twoui = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../containers/ui/twoIndex').default) &#125;, 'twoui');&#125;// 登录验证const requireAuth = (nextState, replace) =&gt; &#123; let token = (new Date()).getTime() - Config.localItem('USER_AUTHORIZATION'); if(token &gt; 7200000) &#123; // 模拟Token保存2个小时 replace(&#123; pathname: '/login', state: &#123; nextPathname: nextState.location.pathname &#125; &#125;); &#125;&#125;const RouteConfig = ( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path="/home" component=&#123;layout&#125; onEnter=&#123;requireAuth&#125;&gt; &lt;IndexRoute getComponent=&#123;home&#125; onEnter=&#123;requireAuth&#125; /&gt; // 默认加载的组件，比如访问www.test.com,会自动跳转到www.test.com/home &lt;Route path="/home" getComponent=&#123;home&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/chart/line" getComponent=&#123;chartLine&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/general/button" getComponent=&#123;button&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/general/icon" getComponent=&#123;icon&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/user" getComponent=&#123;user&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/setting" getComponent=&#123;setting&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/adver" getComponent=&#123;adver&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/ui/oneui" getComponent=&#123;oneui&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;Route path="/ui/twoui" getComponent=&#123;twoui&#125; onEnter=&#123;requireAuth&#125; /&gt; &lt;/Route&gt; &lt;Route path="/login" component=&#123;Roots&#125;&gt; // 所有的访问，都跳转到Roots &lt;IndexRoute component=&#123;login&#125; /&gt; // 默认加载的组件，比如访问www.test.com,会自动跳转到www.test.com/home &lt;/Route&gt; &lt;Redirect from="*" to="/home" /&gt; &lt;/Router&gt;);export default RouteConfig; 1234567891011121314151617181920212223242526272829303132333435############# 其他配置############http &#123; ############ # 其他配置 ############ server &#123; listen 80; server_name antd.sosout.com; root /mnt/html/reactAntd; index index.html; location ~ ^/favicon\.ico$ &#123; root /mnt/html/reactAntd; &#125; location / &#123; try_files $uri $uri/ @router; index index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; location @router &#123; rewrite ^.*$ /index.html break; &#125; access_log /mnt/logs/nginx/access.log main; &#125; ############ # 其他配置 ############ &#125;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 选择器]]></title>
    <url>%2F2018%2F08%2F01%2Fcss-selector.html</url>
    <content type="text"><![CDATA[今天团队中一个正在交接的小弟出去面试，气冲冲的回来吐槽面试官不会面试，竟然会问CSS选择器，在我苦口婆心的劝说下，小弟终于意识到CSS选择器的重要性，为了让他能够找到一个好工作，我便写了这篇文章供他学习。 简介定义我们都知道一条CSS样式定义有两部分组成，形式如下：选择器 {}，在{}之前的部分就是选择器。选择器指明了{}中的样式的作用对象，也就是样式作用于网页中的哪些元素。 作用CSS选择器用于定位我们想要给予样式的 HTML 元素，但不只是在 CSS 中，JavaScript 对 CSS 的选择器也是支持的，比如document.querySelector、document.querySelectorAll。 分类基本选择器 选择器 名称 描述 版本 * 通配选择器 选择所有的元素 CSS2 element 元素选择器 选择指定的元素 CSS1 #idName id选择器 选择id属性等于idName的元素 CSS1 .className 类选择器 选择class属性包含className的元素 CSS1 通配符选择器「 * 」这个选择器是匹配页面中所有的元素，选择器也能选取另一个元素中的所有元素，不过这个选择器的效率比较低，一般用来清除浏览器的默认样式。123456789/* 清楚浏览器默认样式 */* &#123; margin: 0; padding: 0;&#125;div * &#123; color: red;&#125; 1234&lt;div&gt; &lt;span&gt;span&lt;/span&gt; &lt;p&gt;p&lt;/p&gt;&lt;/div&gt; span，p 都变红。 元素选择器「 element 」通过标签名来选择元素。123div &#123; color: red;&#125; 12345&lt;div&gt;div1&lt;/div&gt;&lt;p&gt; &lt;div&gt;div2&lt;/div&gt;&lt;/p&gt;&lt;div&gt;div3&lt;/div&gt; div1，div2，div3 都变红 id选择器「 #idName 」以id属性来命名，在页面中只能出现一次，具有唯一性，并且权重值最高，相当于一个人的身份证。注意：应用于多个元素，样式同样生效。12&lt;div id="box"&gt;div&lt;/div&gt;&lt;p id="box"&gt;p&lt;/p&gt; 123#box &#123; color: red;&#125; div，p都变红。 类选择器 「 .className 」class选择器/类选择器/用class属性给元素命名，在页面中可以出现很多次，相当于人的名字。12&lt;div class="box"&gt;div&lt;/div&gt;&lt;p class="box"&gt;p&lt;/p&gt; 123.box &#123; color: red;&#125; div，p 都变红。 组合选择器 选择器 名称 描述 版本 E,F 多元素选择器 同时匹配元素E或元素F CSS1 E F 后代选择器 匹配E元素所有的后代（不只是子元素、子元素向下递归）元素F CSS1 E &gt; F 子元素选择器 匹配E元素的所有直接子元素F CSS2 E + F 相邻兄弟选择器 匹配E元素之后的相邻的同级元素F CSS2 E ~ F 普通兄弟选择器 匹配E元素之后的同级元素F（无论直接相邻与否） CSS3 多元素选择器 「 E,F 」选择所有的E元素和F元素，中间用逗号隔开。12&lt;div&gt;div&lt;/div&gt;&lt;p&gt;p&lt;/p&gt; 1234// 同时匹配div标签和p标签div, p &#123; color: red;&#125; div，p 都变红。 后代选择器 「 E F 」选择所有被E元素包含的所有的F元素（包括子、孙），中间用空格隔开。1234567&lt;div&gt; &lt;span&gt;span1&lt;/span&gt; &lt;p&gt; &lt;span&gt;span2&lt;/span&gt; &lt;/p&gt; &lt;span&gt;span3&lt;/span&gt;&lt;/div&gt; 123div span &#123; color: red;&#125; span1，span2，span3 都变红。 子元素选择器 「 E &gt; F 」选择所有作为E元素的直接子元素F，对更深一层的元素不起作用，用 &gt; 表示。1234567&lt;div&gt; &lt;span&gt;span1&lt;/span&gt; &lt;p&gt; &lt;span&gt;span2&lt;/span&gt; &lt;/p&gt; &lt;span&gt;span3&lt;/span&gt;&lt;/div&gt; 123div &gt; span &#123; color: red;&#125; span1，span3 变红。 相邻兄弟选择器 「 E + F 」选择紧跟E元素后的F元素，用 + 表示，选择相邻的第一个兄弟元素。1234567&lt;p&gt;p1&lt;/p&gt;&lt;div&gt;div &lt;p&gt;p2&lt;/p&gt;&lt;/div&gt;&lt;p&gt;p3&lt;/p&gt;&lt;span&gt;span&lt;/span&gt;&lt;p&gt;p4&lt;/p&gt; 123div + p &#123; color: red;&#125; p3 变红。 普通兄弟选择器 「 E ~ F 」选择E元素之后的所有同级元素F（无论直接相邻与否），作用于多个元素，用 ~ 隔开。1234567&lt;p&gt;p1&lt;/p&gt;&lt;div&gt;div &lt;p&gt;p2&lt;/p&gt;&lt;/div&gt;&lt;p&gt;p3&lt;/p&gt;&lt;span&gt;span&lt;/span&gt;&lt;p&gt;p4&lt;/p&gt; 123div ~ p &#123; color: red;&#125; p3，p4 变红。 属性选择器 选择器 例子 例子描述 版本 [attribute] [target] 选择所有带有target属性元素。 CSS2 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素。 CSS2 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 CSS2 [attribute&#124;=value] [lang&#124;=en] 选择 lang 属性值以 “en” 开头的所有元素。 CSS2 [attribute^=value]] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 a 元素。 CSS3 [attribute$=value] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 a 元素。 CSS3 [attribute*=value] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 a 元素。 CSS3 伪类选择器 伪元素选择器 补充内容更多伪类、伪元素选择器，见如下截图： 优先级当创建的样式表越来越复杂时，一个标签的样式将会受到越来越多的影响，用户看到的其实是通过层叠计算得来的，通俗点讲就是先计算再重叠得来的。 计算指的是用户代理（浏览器只是用户代理的一种“实例”）在渲染HTML的时候，对CSS进行层叠计算的过程。 层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在CSS处于核心地位，CSS的全称层叠样式表正是强调了这一点。 说到这，我们就不得不说一下优先级。优先级是决定不同选择器的相同样式规则对同一元素的生效情况，优先级高的将覆盖优先级低的样式规则。而优先级又受到样式来源和选择器特殊性的影响。 特指度说到优先级，我们又需要讲一下另一个概念：特指度。特指度表示一个css选择器表达式的重要程度，可以通过一个公式来计算出一个数值，数越大，越重要。这个计算叫做“I-C-E”计算公式；1.I——Id：1002.C——Class（类 | 伪类 | 属性选择）：103.E——Element（标签 | 伪元素）：14. 通用选择器：0 即针对一个css选择器表达式，遇到一个id就往特指度数值中加100，遇到一个class就往特指度数值中加10，遇到一个element就往特指度数值中加1。 下面举几个css表达式的特指度计算结果： CSS选择器表达式 特指度计算结果 p 1 p.large 11 p#large 101 div p#large 102 div p#large ul.list 113 div p#large ul.list li 114 还有一个特别重要的点：!important优先级最高，高于上面一切。通配（*） 选择器最低，低于一切。 错误的说法在学习过程中，我们可能发现给选择器加权值的说法，即 ID 选择器权值为 100，类选择器权值为 10，标签选择器权值为 1，当一个选择器由多个 ID 选择器、类选择器或标签选择器组成时，则将所有权值相加，然后再比较权值。这种说法其实是有问题的。比如一个由 11 个类选择器组成的选择器和一个由 1 个 ID 选择器组成的选择器指向同一个标签，按理说 110 &gt; 100，应该应用前者的样式，然而事实是应用后者的样式。错误的原因是：选择器的权值不能进位。虽然 11 个类选择器组成的选择器的总权值为 110，但因为 11 个均为类选择器，所以其实总权值最多不能超过 100， 我们可以理解为 99.99，所以最终应用后者样式。 多重样式间的优先级w3school给出的优先级顺序从低到高是： 浏览器缺省设置外部样式表内部样式表（位于 head 标签内部）内联样式（在 HTML 元素内部） 但如果外部样式表放在内部样式表后面其实是会覆盖内部样式表的，举个例子： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; color: red; &#125; &lt;/style&gt; &lt;link rel="stylesheet" type="text/css" href="index.css" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123.box &#123; color: blue;&#125; 最终得到的是蓝色的字体，很明显，内部样式被放在后面的外部样式覆盖了。所以我更倾向于认为外部样式表和内部样式表具有相同的优先级。 除了选择器，样式自身还可以继承和提升优先级，规则如下：一：从祖先元素继承来的样式优先级低于通用选择器；甚至低于浏览器的缺省设置，比如最常见的，重置链接的默认样式时必须写在链接元素上，放在祖先元素中是没有卵用滴二：使用大杀器!important可将样式提升到最高等级，不管这个样式在哪个样式表或选择器中；如果在同一样式中出现了多个!important，就得看上面的权重规则进行pk了。 因此多重样式间遵循：继承来的样式 &lt; 浏览器缺省设置 &lt; 外部样式表 = 内部样式表 &lt; 内联样式 总结优先级正确的排序是： 1important &gt; 内联样式 &gt; ID &gt; 类 | 伪类 | 属性选择 &gt; 标签 | 伪元素 &gt; 继承 &gt; 通配符]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>selector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git clone 太慢的解决方式]]></title>
    <url>%2F2018%2F08%2F01%2Fgithub-do-slow.html</url>
    <content type="text"><![CDATA[众所周知，虽然github没有在国内被墙，但是依然访问很慢。在 clone 项目到本地时，如果项目很大（比如我clone antd的时候估算了一下大概有一百多兆），那就很麻烦了。这里介绍一些比较通用的解决方案。在我机器上 clone 速度从二十几k提高到二百多k，瞬间拽的不要不要的。 一、查找域名对应的ip地址，并修改hosts文件12151.101.76.249 github.global.ssl.fastly.net 192.30.253.112 github.com]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>git clone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 异步编程]]></title>
    <url>%2F2018%2F07%2F30%2Fjavascript-async-programme.html</url>
    <content type="text"><![CDATA[背景我们都知道，Javascript 语言的执行环境是“单线程”的。单线程在程序执行时，一次只能完成一个任务。如果有多个任务，就必须排队，前面一个任务完成，在执行后面一个任务，以此类推。 这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。 基于JavaScript的单线程语言执行环境及其不足，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。 同步，即任务一步一步执行，当前任务执行完毕后才能继续执行后续任务；异步则是后续任务不需等待前一个任务结束也可执行，当前任务执行结束后可以通过状态、通知或回调来通知调用者。 异步编程实现回调函数回调函数是异步编程最基本的方法。 假定有两个函数 f1 和 f2，f2 依赖 f1 的执行结果。 123f1();f2(); 如果 f1 是一个很耗时的任务，这时我就可以考虑把 f2 写出 f1 的回调函数。 12345678function f1(callback) &#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000);&#125;f1(f2); 采用回调函数，我们就把同步操作变成了异步操作，这样 f1 就不会堵塞主程序运行，相当于先执行主程序逻辑，将耗时的操作推迟执行。 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 事件监听采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 假定有两个函数 f1 和 f2，f1绑定一个 done 事件（这里采用的jQuery的写法）1f1.on('done', f2); 对 f1 进行改写： 123456function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger('done'); &#125;, 1000);&#125; 上述代码表示，执行完 f1 任务，立即触发 done 事件，当 f1 发生 done 事件，就执行 f2。 事件监听的优点是可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 数据类型]]></title>
    <url>%2F2018%2F07%2F29%2Fjavascript-types.html</url>
    <content type="text"><![CDATA[概述JavaScript 每一个值，都属于某一种数据类型，JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值）。 数值（number）：整数和小数（比如1和3.14）；字符串（string）：文本（比如Hello World）；布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）；undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值；null：表示空值，即此处的值为空；对象（object）：各种值组成的集合。 通常，数值、字符串、布尔值这三种类型，合称为原始数据类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成数据类型（complex type）的值，即引用数据类型，因为一个对象往往是多个原始类型的值的合成，对象可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。 基本数据类型JavaScript中有5种基本数据类型，分别是Number、String、Boolean、Undefined、Null。 基本数据类型存放在栈中基本数据类型是存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以自由分配。基本类型是直接按值存放的，所以我们可以直接操作保存在变量中的实际的值。 基本数据类型值不可变(immutable)性质基本类型是不可变的(immutable)，只有对象是可变的(mutable)。有时我们会尝试“改变”字符串的内容，但在JS中，任何看似对string值的”修改”操作，实际都是创建新的string值。任何方法都无法改变一个基本类型的值：12345678910var str = "abc";str[0] = "d";str.name = "efg";str.method = function() &#123;&#125;;console.log(str); // abcconsole.log(str[0]); // aconsole.log(str.name); // undefinedconsole.log(str.method); // undefined 基本类型的比较是值的比较基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如：123var a = 1;var b = 1;console.log(a === b); // true 比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如123var a = 1;var b = true;console.log(a == b); // true 引用数据类型引用数据类型存放在堆中引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配。 引用类型值可变引用类型的值是可变的。123456789var obj = &#123; x: 0&#125;;obj.x = 100;console.log(obj.x)// 100 被修改obj = &#123; // 等同于重新赋值，重新开辟内存，不是修改 x: 1000&#125;; console.log(obj.x)// 1000 被修改 引用类型的比较是引用的比较每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： 123var a = [1,2,3];var b = [1,2,3];console.log(a === b); // false 传值与传址 JavaScript 所有函数的参数都是按值传递的,也就是说把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 基本数据类型：在我们进行赋值或方法调用操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中，前后两个变量是两个独立相互不影响的变量，比如：123456var a = 10;var b = a;a ++ ;console.log(a); // 11console.log(b); // 10 引用数据类型：在引用类型的赋值或方法调用时，传递的是值的内存地址，也就是说传递前和传递后都指向栈中同一个引用（也就是同一个内存空间），这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响，比如1234567891011var person = &#123; name : "Tom"&#125;;function obj(peo) &#123; peo.name = "Jerry"; peo = &#123; // 等同于重新赋值，重新开辟内存，不是修改 name : "Jack" &#125;;&#125;obj(person);console.log(person.name); // Jerry 数据结构栈数据结构与C/C++不同，JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以简单粗暴的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思维来实现一些功能，比如JavaScript的执行上下文。执行上下文的执行顺序借用了栈数据结构的存取方式，因此理解栈数据结构的原理与特点十分重要。 要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析，如下图左侧： 这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。图中已经详细的表明了栈空间的存储原理。 堆数据结构堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似。 书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。 队列在JavaScript中，理解队列数据结构的目的主要是为了清晰的明白事件循环（Event Loop）的机制到底是怎么回事。 队列是一种先进先出（FIFO）的数据结构。正如排队过安检一样，排在队伍前面的人一定是最先过检的人，用以下的图示可以清楚的理解队列的原理： 引用数据类型与堆内存与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。 123456var a1 = 0; // 原始变量var a2 = 'this is string'; // 原始变量var a3 = null; // 原始变量var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。 在前端面试中我们常常会遇到这样一个类似的题目：123456// demo01.jsvar a = 20;var b = a;b = 30;// 这时a的值是多少？ 123456// demo02.jsvar m = &#123; a: 10, b: 20 &#125;var n = m;n.a = 15;// 这时m.a的值是多少 在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b = a执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。在demo02中，我们通过var n = m执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。 因此当我改变n时，m也发生了变化。这就是引用类型的特性。 拷贝首先深拷贝和浅拷贝只针对像 Object, Array 这样的复杂对象的。简单来说，浅拷贝只拷贝一层对象的属性，而深拷贝则递归拷贝了所有层级。 浅拷贝下面是一个简单的浅拷贝实现： 123456789101112var obj = &#123; a:1, arr: [2,3] &#125;;var shallowObj = shallowCopy(obj);function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125; 因为浅拷贝只会将对象的各个属性进行依次拷贝，并不会进行递归拷贝，而 JavaScript 存储对象都是存地址的，所以浅拷贝会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址，大概的示意图如下： 导致的结果就是： 12shallowObj.arr[1] = 5;obj.arr[1] // = 5 深拷贝而深拷贝则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深拷贝的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。 12var obj = &#123; a:1, arr: [1,2] &#125;;var obj2 = deepCopy(obj); 结果如下面的示意图所示： 需要注意的是，如果对象比较大，层级也比较多，深拷贝会带来性能上的问题。在遇到需要采用深拷贝的场景时，可以考虑有没有其他替代的方案。在实际的应用场景中，也是浅拷贝更为常用。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>types</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tree-shaking-tutorial]]></title>
    <url>%2F2018%2F07%2F28%2Ftree-shaking-tutorial.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>tree-shaking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 相等运算符]]></title>
    <url>%2F2018%2F07%2F26%2Fjavascript-equality-operator.html</url>
    <content type="text"><![CDATA[概述JavaScript中，相等运算符（==）是一个很让人头痛的运算符，它的语法行为多变，不符合直觉。比如下面这个表达式，它的值是什么？想知道答案或语言内部怎么处理，我们可以去查看规格。规格对每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现的算法细节。相等运算符的总体的行为描述：相等运算符用于比较两个值，返回true或false。 抽象比较算法 在执行抽象相等比较算法的过程中，会发现会将xy操作数进行隐式类型转化的，这也是==运算符副作用的体现。 ToPrimitive() toPrimitive方法的目的就是将输入的参数转化成非对象类型。 DefaultValue() 由于0的类型是数值，null的类型是 Null（这是规格4.3.13 小节的规定，是内部 Type 运算的结果，跟typeof运算符无关）。因此上面的前 11 步都得不到结果，要到第 12 步才能得到false。10 == null // 输出结果：false 解析：0 数值 null 对象 返回 false [] == false正确输出结果：true 当js引擎解析到[] == false 的时候，会解析执行左右表达式，并分别取出执行结果的值，上述分别为数组对象和false。然后将数组设置为x，false设置为y按抽象比较算法执行。在执行抽象相等比较算法的过程中，会发现会将xy操作数进行隐式类型转化的，这也是==运算符副作用的体现。 对于 [] == false的问题应该关注上述步骤的78910步骤。因为[]和false不是同一类型，所以执行到8的时候会将false调用toNumber()内部方法转化成数字，然后在执行抽象相等比较算法。toNumber（）会将false转化成+0. 然后将[] == +0.继续进行比较算法，执行到10 之后开始使用toPrimitive( )对[]进行转化。 [] == []正确输出结果：false 0 == null正确输出结果：false [] == {}正确输出结果：false 其他例子123456789null == undefined; // 如果x是null，y是undefined，返回true。1 == true // 如果Type(x)是布尔值，返回ToNumber(x) == y的结果，true转化为数值1，所以输出结果：true 2 == true // 如果Type(x)是布尔值，返回ToNumber(x) == y的结果，true转化为数值1，所以输出结果：false0 == false // 如果Type(x)是布尔值，返回ToNumber(x) == y的结果，true转化为数值0，所以输出结果：true0 == "" // 如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) == y的结果，""转化为数值0，所以输出结果：trueundefined == ""; // falsenull == false; // falseundefined == false; // false]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Equality operator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 函数]]></title>
    <url>%2F2018%2F07%2F24%2Fjavascript-function.html</url>
    <content type="text"><![CDATA[函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。 立即执行函数在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。 有时，我们需要在定义函数之后，立即调用该函数。这时，我们不能在函数的定义之后加上圆括号，这会产生语法错误。12function()&#123; /* code */ &#125;();// SyntaxError: Unexpected token ( 产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。12345// 语句function f() &#123;&#125;// 表达式var f = function f() &#123;&#125; 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做立即执行函数（Immediately-Invoked Function Expression），简称 IIFE。 注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。 123// 报错(function()&#123; /* code */ &#125;())(function()&#123; /* code */ &#125;()) 推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。123var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;(); 甚至像下面这样写，也是可以的。1234!function () &#123; /* code */ &#125;();~function () &#123; /* code */ &#125;();-function () &#123; /* code */ &#125;();+function () &#123; /* code */ &#125;(); 定义简单说立即执行函数就是声明一个匿名函数、马上调用这个匿名函数。 上面是一个典型的立即执行函数。首先，声明一个匿名函数 function(){alert(‘我是匿名函数’)}。然后，在匿名函数后面接一对括号 ()，调用这个匿名函数。 作用只有一个作用：创建一个独立的作用域。 这个作用域里面的变量，外面访问不到（即避免「变量污染」）。 以一个著名的面试题为例： 123456var liList = ul.getElementsByTagName('li')for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5 &#125;&#125; 为什么 alert 的总是 6 呢，因为 i 是贯穿整个作用域的，而不是给每个 li 分配了一个 i，如下： 那么怎么解决这个问题呢？用立即执行函数给每个 li 创造一个独立作用域即可：12345678var liList = ul.getElementsByTagName('li')for(var i=0; i&lt;6; i++)&#123; !function(ii)&#123; liList[ii].onclick = function()&#123; alert(ii) // 0、1、2、3、4、5 &#125; &#125;(i)&#125; 在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 打包后文件分析]]></title>
    <url>%2F2018%2F07%2F23%2Fwebpack-analyze-packaged-file.html</url>
    <content type="text"><![CDATA[版本：v4.17.1 前言Webpack 是目前使用最为火热的打包工具，没有之一，每月有数百万的下载量，为成千上万的网站和应用提供支持。我们网页拥有着复杂的JavaScript代码和一大堆依赖包，webpack 把我们的项目当做一个整体，通过一个给定的入口文件（如：index.js），Webpack将从这个文件开始分析我们的项目的所有依赖文件，然后经过一系列处理，最后打包为一个（或多个）浏览器可识别的JavaScript文件。可我们是否想过 Webpack 输出的 bundle.js 是什么样子的吗？ 为什么原来一个个的模块文件被合并成了一个单独的文件？为什么输出文件（如：bundle.js）能直接运行在浏览器中？现在我们就来详细的分析 webpack 打包后文件。 打包源码12345678910111213141516171819202122232425// webpack.config.jsconst path = require('path');module.exports = &#123; devtool: "source-map", mode: 'development', entry: './main.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;&#125;// main.jsimport helloWorld from './src/index1';import worldHello from './src/index2';console.log(helloWorld, worldHello);export default './main.js';// index1.jsexport default 'Hello World';// index2.jsexport default 'World Hello'; 分析打包后文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// webpackBootstrap 启动函数// modules 即为存放所有模块的对象，对象中的每一个属性都是一个函数(function(modules) &#123; // 安装过的模块都存放在这里面，作用是把已经加载过的模块缓存在内存中，提升性能 var installedModules = &#123;&#125;; // 加载参数对象中每一个模块，moduleId 为要加载模块对象的 key // 函数作用和 Node.js 中 require 语句相似 function __webpack_require__(moduleId) &#123; // 如果需要加载的模块已经被加载过，就直接从内存缓存中返回 if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // 如果缓存中不存在需要加载的模块，就新建一个模块，并把它存在缓存中 // webpack1的时候都是全称，现在估计为了省点空间，都变成了id =&gt; i, load =&gt; l var module = installedModules[moduleId] = &#123; // 加载模块对象的 key i: moduleId, // 该模块是否已经加载完毕 l: false, // 该模块的导出值 exports: &#123;&#125; &#125;; // 从 modules 中获取 key 为 moduleId 的模块对应的函数 // 再调用这个函数，同时把函数需要的参数传入 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 把这个模块标记为已加载 module.l = true; // 返回这个模块的导出值 return module.exports; &#125; // 在源文件中，直接使用__webpack_modules__，生成文件用__webpack_require__.m替换 __webpack_require__.m = modules; // 暴露module缓存 __webpack_require__.c = installedModules; // 为harmory exports 定义 getter function, configurable=false表明，此属性不能修改 // 例如export const，由于是常量，需要用__webpack_require__.d进行定义 __webpack_require__.d = function(exports, name, getter) &#123; if(!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125; &#125;; // define __esModule on exports __webpack_require__.r = function(exports) &#123; if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123; Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;); &#125; Object.defineProperty(exports, '__esModule', &#123; value: true &#125;); &#125;; // create a fake namespace object // mode &amp; 1: value is a module id, require it // mode &amp; 2: merge all properties of value into the ns // mode &amp; 4: return value when already ns object // mode &amp; 8|1: behave like require __webpack_require__.t = function(value, mode) &#123; if(mode &amp; 1) value = __webpack_require__(value); if(mode &amp; 8) return value; if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value; var ns = Object.create(null); __webpack_require__.r(ns); Object.defineProperty(ns, 'default', &#123; enumerable: true, value: value &#125;); if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key)); return ns; &#125;; // 兼容 non-harmony 模块，这些模块如果设了__esModule属性，则被标记为non-harmony __webpack_require__.n = function(module) &#123; var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module['default']; &#125; : function getModuleExports() &#123; return module; &#125;; __webpack_require__.d(getter, 'a', getter); return getter; &#125;; // Object.prototype.hasOwnProperty.call __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; // Webpack 配置中的 publicPath，用于加载被分割出去的异步代码 __webpack_require__.p = ""; // 使用 __webpack_require__ 去加载 key 为 ./main.js 的模块，并且返回该模块导出的内容 // key 为 ./main.js 的模块就是 main.js 对应的文件，也就是执行入口模块 // __webpack_require__.s 的含义是启动模块对应的 key return __webpack_require__(__webpack_require__.s = "./main.js");&#125;)(&#123;// 所有的模块都存放在了一个对象里，根据每个模块在对象的 key 来区分和定位模块"./main.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); var _src_index1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/index1.js"); var _src_index2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/index2.js"); console.log(_src_index1__WEBPACK_IMPORTED_MODULE_0__["default"], _src_index2__WEBPACK_IMPORTED_MODULE_1__["default"]); __webpack_exports__["default"] = ('./main.js'); &#125;),"./src/index1.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); __webpack_exports__["default"] = ('Hello World'); &#125;),"./src/index2.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); __webpack_exports__["default"] = ('World Hello'); &#125;)&#125;); 上面这段 js 就是使用 webpack 编译后的代码，其中就包含了 webpack 的运行时代码，其中就是关于模块的实现。 以上看上去复杂的代码其实是一个立即执行函数，可以简写为如下：123456789101112(function(modules) &#123; // 模拟 require 语句 function __webpack_require__() &#123; &#125; // 执行存放所有模块中 key 值为 ./main.js 的模块 __webpack_require__('./main.js');&#125;)(&#123; "./main.js": fn // 函数&#125;) 自执行函数的入参是个对象，这个对象包含了所有的模块，包裹在函数中。自执行函数体里的逻辑就是处理模块的逻辑。关键在于__webpack_require__函数，这个函数就是require或者是import的替代，我们可以看到在函数体内先定义了这个函数，然后调用了它。这里会传入一个moduleId，这个例子中是./main.js，也就是我们的入口模块main.js的内容。 我们再看__webpack_require__内执行了：12modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);return module.exports； 即从入参的 modules 对象中取第一个函数进行调用，并入参： module module.exports webpack_require 我们再看第一个函数（即入口模块）的逻辑： 12345678(function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); var _src_index1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/index1.js"); var _src_index2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/index2.js"); console.log(_src_index1__WEBPACK_IMPORTED_MODULE_0__["default"], _src_index2__WEBPACK_IMPORTED_MODULE_1__["default"]); __webpack_exports__["default"] = ('./main.js');&#125;) 我们可以看到入口模块又调用了__webpack_require__(&quot;./src/index1.js&quot;)和__webpack_require__(&quot;./src/index2.js&quot;)去引用入参数组里的第2和第3个函数。 然后会将入参的__webpack_exports__对象添加default属性，并赋值。这里的__webpack_exports__就是这个模块的module.exports通过对象的引用传参，间接的给module.exports添加属性，这就是webpack模块化的实现原理。 最后会将module.exports return出来。就完成了__webpack_require__函数的使命。比如在入口模块中又调用了__webpack_require__(&quot;./src/index1.js&quot;)，就会得到这个模块返回的module.exports。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>analysis package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lerna管理前端packages的最佳实践]]></title>
    <url>%2F2018%2F07%2F21%2Flerna-repo.html</url>
    <content type="text"><![CDATA[背景对于维护过多个package的同学来说，都会遇到一个选择：这些package是放在一个仓库里维护还是放在多个仓库里单独维护，数量较少的时候，多个仓库维护不会有太大问题，但是当package数量逐渐增多时，一些问题逐渐暴露出来：一、package之间相互依赖，开发人员需要在本地手动执行npm link，维护版本号的更替；二、issue难以统一追踪，管理，因为其分散在独立的repo里；三、每一个package都包含独立的node_modules，而且大部分都包含babel,webpack等开发时依赖，安装耗时冗余并且占用过多空间。 什么是lernalerna到底是什么呢？lerna官网上是这样描述的。 用于管理具有多个包的JavaScript项目的工具。这个介绍可以说很清晰了，引入lerna后，上面提到的问题不仅迎刃而解，更为开发人员提供了一种管理多packages javascript项目的方式。一、自动解决packages之间的依赖关系。二、通过git 检测文件改动，自动发布。三、根据git 提交记录，自动生成CHANGELOG 常用命令全局安装lernalerna 我们需要全局安装lerna工具。123$ npm i -g lerna# 或$ yarn global add lerna 为所有项目安装依赖，类似于npm/yarn i1$ lerna bootstrap 提交对项目的更新运行该命令会执行如下的步骤： 运行lerna updated来决定哪一个包需要被publish 如果有必要，将会更新lerna.json中的version 将所有更新过的的包中的package.json的version字段更新 将所有更新过的包中的依赖更新 为新版本创建一个git commit或tag 将包publish到npm上 123$ lerna publish # 用于发布更新$ lerna publish --skip-git # 不会创建git commit或tag$ lerna publish --skip-npm # 不会把包publish到npm上 使用lerna 初始化项目12$ lerna init # 固定模式(Fixed mode)默认为固定模式，packages下的所有包共用一个版本号(version)$ lerna init --independent # 独立模式(Independent mode)，每一个包有一个独立的版本号 为packages文件夹下的package安装依赖1234567$ lerna add &lt;package&gt;[@version] [--dev] # 命令签名# 例如$ lerna add module-1 --scope=module-2 # 将 module-1 安装到 module-2$ lerna add module-1 --scope=module-2 --dev # 将 module-1 安装到 module-2 的 devDependencies 下$ lerna add module-1 # 将 module-1 安装到除 module-1 以外的所有模块$ lerna add babel-core # 将 babel-core 安装到所有模块 卸载依赖12345$ lerna exec -- &lt;command&gt; [..args] # 在所有包中运行该命令# 例如$ lerna exec --scope=npm-list yarn remove listr # 将 npm-list 包下的 listr 卸载$ lerna exec -- yarn remove listr # 将所有包下的 listr 卸载 对包是否发生过变更123$ lerna updated# 或$ lerna diff 显示packages下的各个package的version1$ lerna ls 清理node_modules1$ lerna clean lerna run运行npm script，可以指定具体的package。12345678$ lerna run &lt;script&gt; -- [..args] # 在所有包下运行指定# 例如$ lerna run test # 运行所有包的 test 命令$ lerna run build # 运行所有包的 build 命令$ lerna run --parallel watch # 观看所有包并在更改时发报，流式处理前缀输出$ lerna run --scope my-component test # 运行 my-component 模块下的 test 参考 lerna.json解析1234567891011121314151617&#123; "version": "1.1.3", "npmClient": "npm", "command": &#123; "publish": &#123; "ignoreChanges": [ "ignored-file", "*.md" ] &#125;, "bootstrap": &#123; "ignore": "component-*", "npmClientArgs": ["--no-package-lock"] &#125; &#125;, "packages": ["packages/*"]&#125; version：当前库的版本npmClient： 允许指定命令使用的client， 默认是 npm， 可以设置成 yarncommand.publish.ignoreChanges：可以指定那些目录或者文件的变更不会被publishcommand.bootstrap.ignore：指定不受 bootstrap 命令影响的包command.bootstrap.npmClientArgs：指定默认传给 lerna bootstrap 命令的参数command.bootstrap.scope：指定那些包会受 lerna bootstrap 命令影响packages：指定包所在的目录 使用lerna的基本工作流环境配置 Git 在一个lerna工程里，是通过git来进行代码管理的。所以你首先要确保本地有正确的git环境。 如果需要多人协作开发，请先创建正确的git中心仓库的链接。 因此需要你了解基本的git操作，在此不再赘述。 npm仓库 无论你管理的package是要发布到官网还是公司的私有服务器上，都需要正确的仓库地址和用户名。 你可运行下方的命令来检查，本地的npm registry地址是否正确。 1$ npm config ls lerna 我们需要全局安装lerna工具 123$ npm i -g lerna# 或$ yarn global add lerna 初始化一个lerna工程 在这个例子中，我将在我本地d:/jobs 根目录下初始化一个lerna工程。1、在d:/jobs下创建一个空的文件夹，命名为lerna-demo：1$ mkdir lerna-demo 2、初始化 通过cmd进入相关目录，进行初始化12$ cd d:/jobs/lerna-demo$ lerna init 执行成功后，目录下将会生成这样的目录结构。123- packages(目录)- lerna.json(配置文件)- package.json(工程描述文件) 3、添加一个测试package 默认情况下，package是放在packages目录下的。12345678# 进入packages目录cd d:/jobs/lerna-demo/packages# 创建一个packge目录mkdir module-1# 进入module-1 package目录cd module-1# 初始化一个packagenpm init -y 执行完毕，工程下的目录结构如下:12345--packages --module-1 package.json--lerna.json--package.json 4、安装各packages依赖 这一步操作，官网上是这样描述的 在当前的Lerna仓库中引导包。安装所有依赖项并链接任何交叉依赖项。12$ cd d:/lerna-demo$ lerna bootstrap 在现在的测试package中，module-1是没有任何依赖的，因此为了更加接近真实情况。你可已在module-1的package.json文件中添加一些第三方库的依赖。 这样的话，当你执行完该条命令后，你会发现module-1的依赖已经安装上了。 5、发布 在发布的时候，就需要git工具的配合了。 所以在发布之前，请确认此时该lerna工程是否已经连接到git的远程仓库。你可以执行下面的命令进行查看。1234git remote -v// print logorigin git@github.com:meitianyitan/docm.git (fetch)origin git@github.com:meitianyitan/docm.git (push) 本篇文章的代码托管在Github上。因此会显示此远程链接信息。 如果你还没有与远程仓库链接，请首先在github创建一个空的仓库，然后根据相关提示信息，进行链接。1$ lerna publish 执行这条命令，你就可以根据cmd中的提示，一步步的发布packges了。实际上在执行该条命令的时候，lerna会做很多的工作。123456- Run the equivalent of `lerna updated` to determine which packages need to be published.- If necessary, increment the `version` key in `lerna.json`.- Update the `package.json` of all updated packages to their new versions.- Update all dependencies of the updated packages with the new versions, specified with a [caret (^)](https://docs.npmjs.com/files/package.json#dependencies).- Create a new git commit and tag for the new version.- Publish updated packages to npm. 到这里为止，就是一个最简单的lerna的工作流了。但是lerna还有更多的功能等待你去发掘。lerna有两种工作模式,Independent mode和Fixed/Locked mode，在这里介绍可能会对初学者造成困扰，但因为实在太重要了，还是有必要提一下的。lerna的默认模式是Fixed/Locked mode，在这种模式下，实际上lerna是把工程当作一个整体来对待。每次发布packges，都是全量发布，无论是否修改。但是在Independent mode下，lerna会配合Git，检查文件变动，只发布有改动的packge。 使用lerna提升开发流程体验接下来，我们从一个demo出发，了解基于lerna的开发流程。 项目初始化 我们需要维护一个UI组件库，其包含2个组件，分别为House（房子）和Window（窗户）组件，其中House组件依赖于Window组件。我们使用lerna初始化整个项目，并且在packages里新建了2个package，执行命令进行初始化：1$ lerna init 初始化化后目录结构如下所示：123456789101112.├── lerna.json├── package.json└── packages ├── house │ ├── index.js │ ├── node_modules │ └── package.json └── window ├── index.js ├── node_modules └── package.json 增加依赖 接下来，我们来为组件增加些依赖，首先House组件不能只由Window构成，还需要添加一些外部依赖（在这里我们假定为lodash）。我们执行：1$ lerna add lodash --scope=house 这句话会将lodash增添到House的dependencies属性里，这会儿你可以去看看package.json是不是发生变更了。 我们还需要将Window添加到House的依赖里，执行：1$ lerna add window --scope=house 就是这么简单，它会自动检测到window隶属于当前项目，直接采用symlink的方式关联过去。 symlink:符号链接，也就是平常所说的建立超链接，此时House的node_modules里的Window直接链接至项目里的Window组件，而不会再重新拉取一份，这个对本地开发是非常有用的。 发布到npm 接下来我们只需要简单地执行lerna publish，确认升级的版本号，就可以批量将所有的package发布到远程。 默认情况下会推送到系统目前npm对应的registry里，实际项目里可以根据配置leran.json切换所使用的npm客户端。 更新模块 接下来，我们变更了Window组件，执行一下lerna updated，便可以得知有哪些组件发生了变更。12345678→ lerna updatedlerna info version 2.9.1lerna info Checking for updated packages...lerna info Comparing with v1.0.9.lerna info Checking for prereleased packages...lerna info result- jx-house- jx-window 我们可以看到，虽然我们只变更了window组件，但是lerna能够帮助我们检查到所有依赖于它的组件，对于没有关联的组件，是不会出现在更新列表里的，这个对于相比之前人工维护版本依赖的更新，是非常稳健的。 集中版本号或独立版本号截止目前，我们已经成功发布了2个package，现在再新增一个Tree组件，它和其他2个package保持独立，随后我们执行lerna publish，它会提示Tree组件的版本号将会从0.0.0升级至1.0.0，但是事实上Tree组件仅仅是刚创建的，这点不利于版本号的语义化，lerna已经考虑到了这一点，它包含2种版本号管理机制。 fixed模式下，模块发布新版本时，都会升级到leran.json里编写的version字段 independent模式下，模块发布新版本时，会逐个询问需要升级的版本号，基准版本为它自身的package.json，这样就避免了上述问题。 如果需要各个组件维护自身的版本号，那么就使用independent模式，只需要去配置leran.json即可。 总结lerna不负责构建，测试等任务，它提出了一种集中管理package的目录模式，提供了一套自动化管理程序，让开发者不必再深耕到具体的组件里维护内容，在项目根目录就可以全局掌控，基于npm scripts，可以很好地完成组件构建，代码格式化等操作，并在最后一公里，用lerna变更package版本，将其上传至远端。 lerna最佳实践为了能够使lerna发挥最大的作用，根据这段时间使用lerna 的经验，总结出一个最佳实践。下面是一些特性。 采用Independent模式 根据Git提交信息，自动生成changelog eslint规则检查 prettier自动格式化代码 提交代码，代码检查hook 遵循semver版本规范大家应该也可以看出来，在开发这种工程的过程的，最为重要的一点就是规范。因为应用场景各种各样，你必须保证发布的packge是规范的，代码是规范的，一切都是有迹可循的。这点我认为是非常重要的。 工具整合在这里引入的工具都是为了解决一个问题，就是工程和代码的规范问题。 husky lint-staged prettier eslint yarn workspaces命令在根目录安装 npm 包，以 danger 为例：$ yarn add danger --dev -W]]></content>
      <categories>
        <category>lerna</category>
      </categories>
      <tags>
        <tag>package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 文本两边对齐有些文字的间距就被拉开了]]></title>
    <url>%2F2018%2F07%2F18%2Fcss-text-justify.html</url>
    <content type="text"><![CDATA[有时为了保持文章段落的美观，我们希望文章段落最好能够两边对齐，我们一般的解决办法是使用text-align: justify，但遇到中英混搭的段落时，文本之间距离被拉大。这个问题原因很简单，这个所谓的两端对齐，指的就是无论这一行当中有多少内容，都需要撑满整行（最后一行除外）。 如果我们希望实现的是左右两端都是比较整齐的，又是英文的状态，不希望出现右边有比较大空缺的话，可以使用正常的左对齐，然后配合word-break进行控制，word-break控制的是单词的切断方式，默认情况下，英文单词是不允许被随意中断的，但是如果我们添加以下代码：1word-break: break-all;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>justify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[danger 入门教程]]></title>
    <url>%2F2018%2F07%2F14%2Fdanger-tutorial.html</url>
    <content type="text"><![CDATA[背景在 Code Review 时，我们可能经常要去检查各种事情，比如 pr 是否提到了 develop 分支、commit 中是否有毒（存在 merge commit）、禁止某些文件在 pr 中有修改、pr 的描述是否正常等等各种事情。有时我们会忘记检查这些事情，merge 之后才发现，这个就非常尴尬了。 快速入门指南获取我们建议通过 Yarn 安装 Danger，当然我们也可以使用 npm CLI。 安装我们这边以 Yarn 为例：1yarn add danger --dev 创建 Danger 配置文件 dangerfile.js 或 dangerfile.ts]]></content>
      <categories>
        <category>danger</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件编程]]></title>
    <url>%2F2018%2F07%2F12%2Fsoftware-programm-method.html</url>
    <content type="text"><![CDATA[编程范式声明式编程(Declarative)声明式编程：告诉“机器”我们想要的是什么(what)，让机器想出如何去做(how)。比如react和vue，我们只负责想要什么数据、事件等等，具体怎么渲染那是react和vue的事情。 命令式编程(Imperative)命令式编程：命令“机器”如何去做事情(how)，不管我们想要的是什么(what)，它都会按照我们的命令实现。比如jquery命令式渲染，我们需要知道如何增加，删除、更改、插入等等，渲染工作需要自己完成！ 数据驱动所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。 脚本语言JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。]]></content>
      <categories>
        <category>programm</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA_HOME环境变量失效的解决办法]]></title>
    <url>%2F2018%2F07%2F09%2Fjava-dev-variable-failure.html</url>
    <content type="text"><![CDATA[今天团队中一个同事搭建java开发环境，遇到了一个很奇怪的问题。在cmd中输入java -version会报如下错误:1Error:could not open `D:\Java\jre7\lib\amd64\jvm.cfg' 原因是因为重装导致的。 解决办法： Path系统环境变量中，把%JAVA_HOME%\bin调整到最前面即可。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JAVA_HOME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-saga-source-analysis]]></title>
    <url>%2F2018%2F07%2F08%2Fredux-saga-source-analysis.html</url>
    <content type="text"></content>
      <categories>
        <category>redux-saga</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深聊import、require、export、module.exports]]></title>
    <url>%2F2018%2F07%2F05%2Fmodule-import-require.html</url>
    <content type="text"><![CDATA[前言ES6标准发布后，module成为标准，标准的使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口，甚至有时候也会常常看到两者互用的场景。只有把这些语法搞清楚才能在未来的标准编程游刃有余。 webpack 模块化webpack 本身维护了一套模块系统，这套模块系统兼容了所有前端历史进程下的模块规范，包括 amd commonjs es6 等，本文主要针对 commonjs es6 规范进行说明。模块化的实现其实就在最后编译的文件内。 我们以一个小 demo 为例12345678910111213141516171819202122232425// webpack.config.jsconst path = require('path');module.exports = &#123; devtool: "source-map", mode: 'development', entry: './main.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;&#125;// main.jsimport helloWorld from './src/index1';import worldHello from './src/index2';console.log(helloWorld, worldHello);export default './main.js';// index1.jsexport default 'Hello World';// index2.jsexport default 'World Hello'; demo 打包后文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// webpackBootstrap 启动函数// modules 即为存放所有模块的对象，对象中的每一个属性都是一个函数(function(modules) &#123; // 安装过的模块都存放在这里面，作用是把已经加载过的模块缓存在内存中，提升性能 var installedModules = &#123;&#125;; // 加载参数对象中每一个模块，moduleId 为要加载模块对象的 key // 函数作用和 Node.js 中 require 语句相似 function __webpack_require__(moduleId) &#123; // 如果需要加载的模块已经被加载过，就直接从内存缓存中返回 if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // 如果缓存中不存在需要加载的模块，就新建一个模块，并把它存在缓存中 // webpack1的时候都是全称，现在估计为了省点空间，都变成了id =&gt; i, load =&gt; l var module = installedModules[moduleId] = &#123; // 加载模块对象的 key i: moduleId, // 该模块是否已经加载完毕 l: false, // 该模块的导出值 exports: &#123;&#125; &#125;; // 从 modules 中获取 key 为 moduleId 的模块对应的函数 // 再调用这个函数，同时把函数需要的参数传入 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 把这个模块标记为已加载 module.l = true; // 返回这个模块的导出值 return module.exports; &#125; // 在源文件中，直接使用__webpack_modules__，生成文件用__webpack_require__.m替换 __webpack_require__.m = modules; // 暴露module缓存 __webpack_require__.c = installedModules; // 为harmory exports 定义 getter function, configurable=false表明，此属性不能修改 // 例如export const，由于是常量，需要用__webpack_require__.d进行定义 __webpack_require__.d = function(exports, name, getter) &#123; if(!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125; &#125;; // define __esModule on exports __webpack_require__.r = function(exports) &#123; if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123; Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;); &#125; Object.defineProperty(exports, '__esModule', &#123; value: true &#125;); &#125;; // create a fake namespace object // mode &amp; 1: value is a module id, require it // mode &amp; 2: merge all properties of value into the ns // mode &amp; 4: return value when already ns object // mode &amp; 8|1: behave like require __webpack_require__.t = function(value, mode) &#123; if(mode &amp; 1) value = __webpack_require__(value); if(mode &amp; 8) return value; if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value; var ns = Object.create(null); __webpack_require__.r(ns); Object.defineProperty(ns, 'default', &#123; enumerable: true, value: value &#125;); if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key)); return ns; &#125;; // 兼容 non-harmony 模块，这些模块如果设了__esModule属性，则被标记为non-harmony __webpack_require__.n = function(module) &#123; var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module['default']; &#125; : function getModuleExports() &#123; return module; &#125;; __webpack_require__.d(getter, 'a', getter); return getter; &#125;; // Object.prototype.hasOwnProperty.call __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; // Webpack 配置中的 publicPath，用于加载被分割出去的异步代码 __webpack_require__.p = ""; // 使用 __webpack_require__ 去加载 key 为 ./main.js 的模块，并且返回该模块导出的内容 // key 为 ./main.js 的模块就是 main.js 对应的文件，也就是执行入口模块 // __webpack_require__.s 的含义是启动模块对应的 key return __webpack_require__(__webpack_require__.s = "./main.js");&#125;)(&#123;// 所有的模块都存放在了一个对象里，根据每个模块在对象的 key 来区分和定位模块"./main.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); var _src_index1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/index1.js"); var _src_index2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/index2.js"); console.log(_src_index1__WEBPACK_IMPORTED_MODULE_0__["default"], _src_index2__WEBPACK_IMPORTED_MODULE_1__["default"]); __webpack_exports__["default"] = ('./main.js'); &#125;),"./src/index1.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); __webpack_exports__["default"] = ('Hello World'); &#125;),"./src/index2.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); __webpack_exports__["default"] = ('World Hello'); &#125;)&#125;); 上面这段 js 就是使用 webpack 编译后的代码，其中就包含了 webpack 的运行时代码，其中就是关于模块的实现。 以上看上去复杂的代码其实是一个立即执行函数，可以简写为如下：123456789101112(function(modules) &#123; // 模拟 require 语句 function __webpack_require__() &#123; &#125; // 执行存放所有模块中 key 值为 ./main.js 的模块 __webpack_require__('./main.js');&#125;)(&#123; "./main.js": fn // 函数&#125;) 自执行函数的入参是个对象，这个对象包含了所有的模块，包裹在函数中。自执行函数体里的逻辑就是处理模块的逻辑。关键在于__webpack_require__函数，这个函数就是require或者是import的替代，我们可以看到在函数体内先定义了这个函数，然后调用了它。这里会传入一个moduleId，这个例子中是./main.js，也就是我们的入口模块main.js的内容。 我们再看__webpack_require__内执行了：12modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);return module.exports； 即从入参的 modules 对象中取第一个函数进行调用，并入参： module module.exports webpack_require 我们再看第一个函数（即入口模块）的逻辑： 12345678(function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); var _src_index1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/index1.js"); var _src_index2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/index2.js"); console.log(_src_index1__WEBPACK_IMPORTED_MODULE_0__["default"], _src_index2__WEBPACK_IMPORTED_MODULE_1__["default"]); __webpack_exports__["default"] = ('./main.js');&#125;) 我们可以看到入口模块又调用了__webpack_require__(&quot;./src/index1.js&quot;)和__webpack_require__(&quot;./src/index2.js&quot;)去引用入参数组里的第2和第3个函数。 然后会将入参的__webpack_exports__对象添加default属性，并赋值。这里的__webpack_exports__就是这个模块的module.exports通过对象的引用传参，间接的给module.exports添加属性，这就是webpack模块化的实现原理。 最后会将module.exports return出来。就完成了__webpack_require__函数的使命。比如在入口模块中又调用了__webpack_require__(&quot;./src/index1.js&quot;)，就会得到这个模块返回的module.exports。 babel 的作用按理说 webpack 的模块化方案已经很好的将 es6 模块化转换成 webpack 的模块化，但是其余的 es6 语法还需要做兼容性处理。babel 专门用于处理 es6 转换 es5。当然这也包括 es6 的模块语法的转换。其实两者的转换思路差不多，区别在于 webpack 的原生转换 可以多做一步静态分析，使用tree-shaking 技术。 babel 能提前将 es6 的 import 等模块关键字转换成 commonjs 的规范。这样 webpack 就无需再做处理，直接使用 webpack 运行时定义的 webpack_require 处理。 导出模块es6 的导出模块写法：1234567export default 123;export const a = 123;const b = 3;const c = 4;export &#123; b, c &#125;; babel 会将这些统统转换成 commonjs 的 exports：12345exports.default = 123;exports.a = 123;exports.b = 3;exports.c = 4;exports.__esModule = true; babel 转换 es6 的模块输出逻辑非常简单，即将所有输出都赋值给 exports，并带上一个标志 __esModule 表明这是个由 es6 转换来的 commonjs 输出。 babel将模块的导出转换为commonjs规范后，也会将引入 import 也转换为 commonjs 规范。即采用 require 去引用模块，再加以一定的处理，符合es6的使用意图。 引入 default1import a from './a.js'; 在es6中 import a from ‘./a.js’ 的本意是想去引入一个 es6 模块中的 default 输出。 通过babel转换后得到var a = require(./a.js)，require得到的对象却是整个对象，肯定不是 es6 语句的本意，所以需要对 a 做些改变。 我们在导出提到，default 输出会赋值给导出对象的default属性。 1exports.default = 123; 所以 babel 加了个help _interopRequireDefault函数：12345678910function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; 'default': obj &#125;;&#125;var _a = require('assert');var _a2 = _interopRequireDefault(_a);var a = _a2['default']; 所以这里最后的 a 变量就是 require 的值的 default 属性。如果原先就是commonjs规范的模块，那么就是那个模块的导出对象。 引入 * 通配符我们使用import * as a from &#39;./a.js&#39;es6语法的本意是想将 es6 模块的所有命名输出以及defalut输出打包成一个对象赋值给a变量。 已知以 commonjs 规范导出：1234exports.default = 123;exports.a = 123;exports.b = 3;exports.__esModule = true; 那么对于 es6 转换来的输出通过 var a = require(‘./a.js’) 导入这个对象就已经符合意图。 所以直接返回这个对象：123if (obj &amp;&amp; obj.__esModule) &#123; return obj;&#125; 如果本来就是 commonjs 规范的模块，导出时没有default属性，需要添加一个default属性，并把整个模块对象再次赋值给default属性：12345678910111213141516function _interopRequireWildcard(obj) &#123; if (obj &amp;&amp; obj.__esModule) &#123; return obj; &#125; else &#123; var newObj = &#123;&#125;; // (A) if (obj != null) &#123; for (var key in obj) &#123; if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; &#125; &#125; newObj.default = obj; return newObj; &#125;&#125; import { a } from ‘./a.js’直接转换成 require(‘./a.js’).a 即可。 小结经过上面的转换分析，我们得知即使我们使用了 es6 的模块系统，如果借助 babel 的转换，es6 的模块系统最终还是会转换成 commonjs 的规范。所以我们如果是使用 babel 转换 es6 模块，混合使用 es6 的模块和 commonjs 的规范是没有问题的，因为最终都会转换成 commonjs。 babel5 &amp; babel6我们在上文 babel 对导出模块的转换提到，es6 的 export default 都会被转换成 exports.default，即使这个模块只有这一个输出。 我们经常会使用 es6 的 export default 来输出模块，而且这个输出是这个模块的唯一输出，我们会误以为这种写法输出的是模块的默认输出。12// a.jsexport default 123; 123// b.js 错误var foo = require('./a.js') 在使用require进行引用时，我们也会误以为引入的是a文件的默认输出。结果这里需要改成var foo = require(&#39;./a.js&#39;).default。 这个场景在写 webpack 代码分割逻辑时经常会遇到。12345require.ensure([], (require) =&gt; &#123; callback(null, [ require('./src/pages/profitList').default, ]);&#125;); 这是 babel6 的变更，在 babel5 的时候可不是这样的。 在 babel5 时代，大部分人在用 require 去引用 es6 输出的 default，只是把 default 输出看作是一个模块的默认输出，所以 babel5 对这个逻辑做了 hack，如果一个 es6 模块只有一个 default 输出，那么在转换成 commonjs 的时候也一起赋值给 module.exports，即整个导出对象被赋值了 default 所对应的值。 这样就不需要加 default，require(‘./a.js’) 的值就是想要的 default值。但这样做是不符合 es6 的定义的，在es6 的定义里，default 只是个名字，没有任何意义。 12export default = 123;export const a = 123; 这两者含义是一样的，分别为输出名为 default 和 a 的变量。 还有一个很重要的问题，一旦 a.js 文件里又添加了一个具名的输出，那么引入方就会出麻烦。 12345678910// a.jsexport default 123;export const a = 123; // 新增// b.js var foo = require('./a.js');// 由之前的 输出 123// 变成 &#123; default: 123, a: 123 &#125; 所以 babel6 去掉了这个hack，这是个正确的决定，升级 babel6 后产生的不兼容问题 可以通过引入babel-plugin-add-module-exports解决。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netlify 入门教程]]></title>
    <url>%2F2018%2F07%2F02%2Fnetlify-tutorial.html</url>
    <content type="text"><![CDATA[官网 快速入门指南部署简单通过持续部署，您可以通过推送到Git或通过webhook来触发构建。 支持HTTPS使用我们真正的一键式SSL设置保护您的网站或应用。Netlify自动与Let’s Encrypt集成，并自动配置，分发和更新您的证书。 支持命令行如果你住在终端，Netlify的命令行工具将是你最好的朋友。您可以直接从终端访问任何Netlify功能。 React 源码 netlify 的配置文件 netlify.toml：123456789[build] base = "" publish = "fixtures/dom/build" command = "yarn build --type=UMD_DEV &amp;&amp; cd fixtures/dom/ &amp;&amp; yarn &amp;&amp; yarn prestart &amp;&amp; yarn build"[[redirects]] from = "/*" to = "/index.html" status = 200]]></content>
      <categories>
        <category>netlify</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入探究 setTimeout]]></title>
    <url>%2F2018%2F07%2F01%2Fjavascript-setTimeout.html</url>
    <content type="text"><![CDATA[基本使用1setTimeout(function|string, number); setTimeout 方法接收两个参数，第一个参数为回调函数或字符串，第二个参数为触发时间（单位：毫秒） 123setTimeout( function() &#123; console.log('console after 1 second');&#125;, 1000); 上面这段代码将会在 1 秒后在控制台打印出 console after 1 second 1234setTimeout( 'console.log("console after 2 seconds")', 2000 ); 当第一个参数为字符串，而不是函数时会怎样呢？setTimeout 方法会将这个字符串解析为一段 js 代码，然后在 2 秒后执行这段代码。如果这个字符串无法被解析为 js 代码，将会报错。 接下来我们再看看另外一个例子，这是一位群友的疑惑点： 123456789101112131415161718192021222324252627// 示例一：先输出 setTimeout，然后每 1s 输出一次 setTimeoutfunction show() &#123; console.log('setTimeout'); setTimeout(show, 1000);&#125;show();// 示例二：先输出 setTimeout，然后每 1s 输出一次 setTimeoutfunction show() &#123; console.log('setTimeout'); setTimeout('show()', 1000);&#125;show();// 示例三：无任何输出function show() &#123; console.log('setTimeout'); setTimeout('show', 1000);&#125;show();// 示例四：show会被立刻执行，被延迟执行的是show执行后的返回值。所以show会不断的重复调用直到堆栈爆满，从而引发内存溢出function show() &#123; console.log('setTimeout'); setTimeout(show(), 1000);&#125;show(); 返回值12345678var timeout = setTimeout(function() &#123; console.log('this is a timeout')&#125;, 1000);console.log(timeout, typeof timeout);// 1, "number"// this is a timeout 用变量 timeout 接收 setTimeout() 的返回值，然后将 timeout 打印出来，会发现 timeout 的值是 1，类型是number 为什么 setTimeout() 的返回值会是一个数值类型呢？是不是每一个 setTimeout() 的返回值都会是1？ 12345678910111213141516171819var timeout1 = setTimeout(function() &#123; //&#125;, 1000);var timeout2 = setTimeout(function() &#123; //&#125;, 1000);var timeout3 = setTimeout(function() &#123; //&#125;, 1000);console.log('timeout1---', timeout1);console.log('timeout2---', timeout2);console.log('timeout3---', timeout3);// timeout1--- 1// timeout2--- 2// timeout3--- 3 从上面的代码中能够发现，每一个 setTimeout() 的返回值都不同，返回值并不都是1，而是都对应着唯一的一个值 这个值其实就是对应的 setTimtout() 的 ID，随着当前页面定时器的不断增多，当需要对某一个定时器做操作时，通过 ID 就能够确定到该定时器。 如何结束/阻止一个 setTimeout 的执行实际项目中，添加一个定时器以后，在其回调函数还未执行之前，满足某些条件时可能需要阻止该回调的执行，也就是取消一个定时器，那这时候该怎么做呢？javascript 已经为我们提供了现成的方法： 1clearTimeout( timeout ); 上面这个方法就可以阻止一个定时器的执行，它接收一个参数，这个参数就是需要取消的定时器的 ID，也就是该定时器的返回值 12345var timeout = setTimeout(function() &#123; alert('this is a timeout')&#125;, 1000);clearTimeout( timeout ); 上面代码中的定时器timeout在一秒后并不会执行，因为已经通过clearTimeout( timeout )取消了它的执行 实现异步编程我们使用异步编程很重要的一个目的就是为了不因为耗时任务而阻塞其他 js 代码的执行。我们知道 alert 会阻塞 js 代码的执行，这是因为 js 是单线程的，弹出框出现后如果不对其进行操作就无法执行后面的代码（类似的 confirm 也是） 123alert('this is an alert box');var test = 'this is a text string';console.log(test); 上面的代码在弹出框出现后如果不点击确定，将永远不会执行后面的代码 1234567setTimeout(function() &#123; alert('this is an alert box');&#125;, 1000);var test = 'this is a text string';console.log(test);// this is a text string 上面的代码将 alert 放在了一个延时 1 秒的定时器中，这样就会先打印出 test，过一秒后再显示弹出框。或许你会说，本身 alert 就延时了 1 秒执行，当然不会阻塞其他的代码执行。那么你可以试着将延时1000改为0，这就表示弹出框应该是没有延时立即执行，但是你会发现实际上还是先打印出 test，再执行了 alert。为什么会这样呢？我们下面再说 在实际项目中，我们可以利用 setTimeout 的异步特性，解决一些问题，比如某个对象还未实例化，为了保证该对象在使用到时能够确保已经被实例化，就可以通过 setTimeout 来实现 setTimeout 回调函数的执行时机现在我们来说说为什么延时设为 0 ，回调函数却没有立即执行的问题。我们知道浏览器是基于事件循环的，其中会有多个队列，页面的渲染是一个队列，js 代码的执行也是一个队列。js 代码执行时会创建一系列的任务，而这些任务秉承着先进先出的原则被加入到队列中。但是 setTimeout 是特殊的，当执行到 setTimeout 时，js会将其拿出来放到一个单独的特殊队列中，这个队列中的任务在 js 队列还有未执行完的任务时，永远不会被执行 举个不恰当的栗子，小明想玩游戏，但是作业还没做完，由于小明是单线程的，虽然现在很想玩游戏，但是他还是给自己设定了条件：作业不做完不能玩游戏，一做完立刻玩游戏（延时为0），于是玩游戏这个任务就被小明归置到了一个特殊的任务队列里面，在作业队列任务完成之前不执行特殊队列里面玩游戏的任务，作业完成小明闲下来后立刻开始玩游戏。所以只有浏览器的 js 引擎闲下来以后，才会执行所有 setTimeout，即使延时为 0。 123456var flag = true;setTimeout(function() &#123; flag = false;&#125;, 1000);while(flag) &#123;&#125;alert('this is an alert box'); 问：上面的代码什么时候会显示弹出框？ 答：永远都不会 上面的代码中，while是一个耗时函数，虽然setTimeout只延时了一秒执行，但是由于主队列中的while会永远的执行下去，所以setTimeout所在的队列永远不会被执行，代码会永远阻塞在while循环这边。当然，上面的这种无限循环在项目中不可能出现，而代码执行速度极快，只要不出现十分耗时的代码，定时器几乎还是能够按照我们的意愿在指定时间执行回调函数。 通过 setTimeout 优化用户体验既然setTimeout必须等到主队列中的任务执行完以后才会执行，那我们在碰到一些十分耗时的代码时，是不是可以通过它来放在页面的阻塞呢？当然是可以的，将耗时代码写进setTimeout的回调，时间设置为 0，这样只要 js 引擎空闲下来就回去执行这些耗时代码，就不会阻塞页面给用户造成卡顿的体验，从而提升用户体验。 不易察觉的危险——内存泄漏 什么是内存泄漏？ 一块内存在分配使用完毕以后，既不会被再次使用，又没有被及时回收，直到程序执行完毕都始终占据着这块内存。 setTimeout 什么情况会导致内存泄漏？ setTimeout的第一个参数可以是函数，也可以是字符串。当传入字符串时，就会有内存泄漏产生。先看下面两个例子 123456789setTimeout(function test1() &#123; var a = 1; console.log(a);&#125;, 0)setTimeout((function test2() &#123; var b = 1; console.log(b);&#125;).toString(), 0) 执行代码后，打开控制台，分别输入函数名test1和test2 12345test1// Uncaught ReferenceError: test1 is not definedtest2// ... (打印出 test2 的函数体) 会发现，当第一个参数为函数时，回调函数执行完毕后，test1函数被销毁，其所使用内存也被释放；当第一个参数为字符串时，test2却始终存在，它没有被销毁，始终占据着内存，也就造成了内存泄漏，所以让我们需要使用 setTimeout时，一定要注意，第一个参数必须传入一个函数。 面试题以下代码的运行结果： 题目一：1234567for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125;console.log(i); 运行结果：123456555555 题目二：123456for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 0); console.log(i);&#125; 运行结果：123456012333 我们来简化此题：12345setTimeout(function() &#123; console.log(1);&#125;, 0);console.log(2); 先打印2，后打印1。因为是setTimeout是异步的。正确的理解setTimeout的方式(注册事件)：有两个参数，第一个参数是函数，第二参数是时间值。调用setTimeout时，把函数参数，放到事件队列中。等主程序运行完，再调用。没啥不好理解的。就像我们给按钮绑定事件一样：123btn.onclick = function() &#123; alert(1);&#125;; 这么写完，会弹出1吗。不会！！只是绑定事件而已！必须等我们去触发事件，比如去点击这个按钮，才会弹出1。setTimeout也是这样的！只是绑定事件，等主程序运行完毕后，再去调用。setTimeout的时间值是怎么回事呢？比如：1setTimeout(fn, 2000) 我们可以理解为2000之后，再放入事件队列中，如果此时队列为空，那么就直接调用fn。如果前面还有其他的事件，那就等待。因此setTimeout是一个约会从来都不准时的童鞋。继续看：1234setTimeout(function() &#123; console.log(i);&#125;, 0);var i = 1; 程序会不会报错？不会！而且还会准确得打印1。为什么？因为真正去执行console.log(i)这句代码时，var i = 1已经执行完毕了！所以我们进行dom操作。可以先绑定事件，然后再去写其他逻辑。123456window.onload = function() &#123; fn();&#125;var fn = function() &#123; alert('hello')&#125;; 这么写，完全是可以的。因为异步！ es5中是没有块级作用域的12for (var i = 0; i &lt; 3; i++) &#123;&#125;console.log(i); 也就说i可以在for循环体外访问到。所以是没有块级作用域。但此问题在es6里终结了，因为es6，发明了let。 这回我们再来看看原题。原题使用了for循环。循环的本质是干嘛的？是为了方便我们程序员，少写重复代码。让我们倒退50年，原题等价于：12345678910111213141516var i = 0;setTimeout(function() &#123; console.log(i);&#125;, 0);console.log(i);i++;setTimeout(function() &#123; console.log(i);&#125;, 0);console.log(i);i++;setTimeout(function() &#123; console.log(i);&#125;, 0);console.log(i);i++; 因为setTimeout是注册事件。根据前面的讨论，可以都放在后面。原题又等价于如下的写法：12345678910111213141516var i = 0;console.log(i);i++;console.log(i);i++;console.log(i);i++;setTimeout(function() &#123; console.log(i);&#125;, 0);setTimeout(function() &#123; console.log(i);&#125;, 0);setTimeout(function() &#123; console.log(i);&#125;, 0); 这回你明白了为啥结果是0 1 2 3 3 3了吧。 如果原题也想setTimeout也弹出0，1，2的话，改成如下：12345678for (var i = 0; i &lt; 3; i++) &#123; setTimeout((function(i) &#123; return function() &#123; console.log(i); &#125;; &#125;)(i), 0); console.log(i);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux 源码全方位剖析]]></title>
    <url>%2F2018%2F06%2F29%2Fredux-source-analysis.html</url>
    <content type="text"><![CDATA[版本：v4.0.0 前言受2014年Facebook的Flux架构模式以及函数式编程语言Elm启发，Dan Abramov在2015年创建了 Redux。很快，Redux因其体小精悍（只有2kB）且没有任何依赖短时间内成为最热门的前端架构。 Redux 是可预测的状态管理框架，它很好的解决多交互，多数据源的诉求。Redux 设计之初，作者就严格遵循三个设计理念原则：单一数据源：整个应用的 state 都被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。store 可以看做是数据存储的一个容器，在这个容器里面，只会维护唯一一个 state tree。store 会给定4种基础操作API：dispatch(action)，getState()，replaceReducer(nextReducer)，subscribe(listener)。根据单一数据源原则，所有数据会通过store.getState()方法调用获取。state只读：根据 state 只读原则，数据变更会通过 store，dispatch(action) 方法，Action 可以理解为变更数据的信息载体，type 是变更数据的唯一标志，payload 是用来携带需要变更的数据，格式大致为：const action = { type: &#39;xxx&#39;, payload: &#39;yyy&#39; }；Reducer 是个纯函数，负责根据 action.type 获取需要变更的数据，然后计算 state 数值。格式为：reducer: prevState =&gt; action =&gt; newState。使用纯函数变更state值：Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。 正常的一个同步数据流为：view 层触发 actionCreator，actionCreator 通过 store.dispatch(action) 方法变更 reducer。但是面对多种多样的业务场景，同步数据流方式显然无法满足。对于改变reducer的异步数据操作，就需要用到中间件的概念，如图所示： 源码结构Redux 的源码结构很简单，源码都在 src 目录下，其目录结构如下：12345678src├── utils ---------------------------------------- 工具函数├── applyMiddleware.js --------------------------- 加载 middleware├── bindActionCreators.js ------------------------ 生成将 action creator 包裹在 dispatch 里的函数├── combineReducers.js --------------------------- 合并 reducer 函数├── compose.js ----------------------------------- 组合函数├── createStore.js ------------------------------- 创建一个 Redux store 来储存应用中所有的 state├── index.js ------------------------------------- 入口 js 源码入口index.js 是整个代码的入口，其代码如下：1234567891011121314151617181920212223242526272829303132import createStore from './createStore'import combineReducers from './combineReducers'import bindActionCreators from './bindActionCreators'import applyMiddleware from './applyMiddleware'import compose from './compose'import warning from './utils/warning'import __DO_NOT_USE__ActionTypes from './utils/actionTypes'function isCrushed() &#123;&#125;if ( process.env.NODE_ENV !== 'production' &amp;&amp; typeof isCrushed.name === 'string' &amp;&amp; isCrushed.name !== 'isCrushed') &#123; warning( 'You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.' )&#125;export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose, __DO_NOT_USE__ActionTypes&#125; 入口代码很简单，首先isCrushed函数主要是为了验证在非生产环境下Redux是否被压缩？如果被压缩了，isCrushed.name !== &#39;isCrushed&#39; 就等于 true，这样就会给开发者一个warn提示。最后暴露createStore、combineReducers、bindActionCreators、applyMiddleware、compose 这几个接口给开发者使用，接下来我们逐一解析这几个 API。 createStore.jscreateStore.js 是 Redux 最重要的一个 API ，它负责创建一个 Redux store 来储存应用中所有的 state，整个应用中应有且仅有一个 store。现在我们来看一下 createStore 源代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177import $$observable from 'symbol-observable'// 私有 actionimport ActionTypes from './utils/actionTypes'import isPlainObject from './utils/isPlainObject'export default function createStore(reducer, preloadedState, enhancer) &#123; // 判断接受的参数个数，来指定 reducer、preloadedState 和 enhancer if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; // 如果 enhancer 存在且是个合法的函数，就调用 enhancer，否则抛出错误提示 if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.') &#125; // 储存当前的 reducer let currentReducer = reducer // 储存当前的状态 let currentState = preloadedState // 储存当前的监听函数列表 let currentListeners = [] // 储存下一个监听函数列表 let nextListeners = currentListeners let isDispatching = false // 这个函数可以根据当前监听函数的列表生成新的下一个监听函数列表引用 function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; // 读取由 store 管理的状态树 function getState() &#123; if (isDispatching) &#123; throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) &#125; return currentState &#125; function subscribe(listener) &#123; // 判断传入的参数是否为函数 if (typeof listener !== 'function') &#123; throw new Error('Expected the listener to be a function.') &#125; if (isDispatching) &#123; throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; // 判断 action 是否有 type｛必须｝ 属性 if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?' ) &#125; // 如果正在 dispatch 则抛出错误 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; // 对抛出 error 的兼容，但是无论如何都会继续执行 isDispatching = false 的操作 try &#123; isDispatching = true // 使用 currentReducer 来操作传入 当前状态和 action，放回处理后的状态 currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; // 判断参数是否是函数类型 function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.REPLACE &#125;) &#125; function observable() &#123; const outerSubscribe = subscribe return &#123; subscribe(observer) &#123; if (typeof observer !== 'object' || observer === null) &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125; &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 这里我们首先要讲一下ActionTypes对象，它是 Redux 的私有 action，不允许外界触发，用来初始化 store 的状态树和改变 reducers 后初始化 store 的状态树。接下来我们从不同角度着重来讲一下 createStore 函数： 参数它可以接受三个参数：reducer、preloadedState、enhancer：reducer：函数，返回下一个状态，接受两个参数：当前状态 和 触发的 action；preloadedState：它是 state 的初始值，可以随意指定，比如服务端渲染的初始状态，但是如果使用 combineReducers 来生成 reducer，那必须保持状态对象的 key 和 combineReducers 中的 key 相对应，另外实际上它并不仅仅是扮演着一个 initialState 的角色，如果我们第二个参数是函数类型，createStore 会认为我们忽略了 preloadedState 而传入了一个enhancer；enhancer：可选参数，一个组合 store creator 的高阶函数，可以翻译成 store 的增强器，顾名思义，就是增强 store 的功能。一般指定为第三方的中间件，时间旅行，持久化等等，返回一个新的强化过的 store creator，这个函数通常用 Redux 提供的 applyMiddleware 函数来生成。 根据传入参数的个数和类型，判断 reducer、preloadedState、enhancer。 返回值调用完函数的返回值：dispatch、subscribe、getState、replaceReducer 和 [$$observable]，这就是我们开发中主要使用的几个接口。 enhancer如果enhancer参数存在且是个合法的函数，那么就调用enhancer函数。enhancer实际上是一个高阶函数，它的参数是创建store的函数createStore，返回值是一个可以创建功能更加强大的store的函数(enhanced store creator)，这和 React 中的高阶组件的概念很相似。store enhancer 函数的结构一般如下：123456function enhancerCreator() &#123; return createStore =&gt; (...args) =&gt; &#123; // do something based old store // return a new enhanced store &#125;&#125; 注意，enhancerCreator是用于创建enhancer store的函数，也就是说enhancerCreator的执行结果才是一个enhancer store。...args参数代表创建store所需的参数，也就是createStore接收的参数，实际上就是（reducer, [preloadedState], [enhancer]）。 现在，我们来创建一个enhancer store，用于输出发送的action的信息和state的变化：1234567891011121314// logging.js（store enhancer）export default function logging() &#123; return createStore =&gt; (reducer, initialState, enhancer) =&gt; &#123; const store = createStore(reducer, initialState, enhancer) function dispatch(action) &#123; console.log(`dispatch an action: $&#123;JSON.stringify(action)&#125;`); const res = store.dispatch(action); const newState = store.getState(); console.log(`current state: $&#123;JSON.stringify(newState)&#125;`); return res; &#125; return &#123;...store, dispatch&#125; &#125;&#125; logging()改变了store dispatch的默认行为，在每次发送action前后，都会输出日志信息，然后在创建store上，使用logging()这个store enhancer:12345678910111213// store.jsimport &#123; createStore, combineReducers &#125; from 'redux';import * as reducer from '../reducer';import logging from '../logging';//创建一个 Redux store 来以存放应用中所有的 state，应用中应有且仅有一个 store。var store = createStore( combineReducers(reducer), logging());export default store; getState123456789101112// 读取由 store 管理的状态树function getState() &#123; if (isDispatching) &#123; throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) &#125; return currentState&#125; 这个函数可以获取当前的状态，createStore 中的 currentState 储存当前的状态树，这是一个闭包，这个参数会持久存在，并且所有的操作状态都是改变这个引用，getState 函数返回当前的 currentState。 subscribe123456789101112131415161718192021222324252627282930313233343536373839function subscribe(listener) &#123; // 判断传入的参数是否为函数 if (typeof listener !== 'function') &#123; throw new Error('Expected the listener to be a function.') &#125; if (isDispatching) &#123; throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125;&#125; 这个函数可以给 store 的状态添加订阅监听函数，一旦调用dispatch，所有的监听函数就会执行；nextListeners就是储存当前监听函数的列表，调用subscribe，传入一个函数作为参数，那么就会给nextListeners列表push这个函数；同时调用subscribe函数会返回一个unsubscribe函数，用来解绑当前传入的函数，同时在subscribe函数定义了一个isSubscribed标志变量来判断当前的订阅是否已经被解绑，解绑的操作就是从nextListeners列表中删除当前的监听函数。 dispatch1234567891011121314151617181920212223242526272829303132333435function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; // 判断 action 是否有 type｛必须｝ 属性 if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?' ) &#125; // 如果正在 dispatch 则抛出错误 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; // 对抛出 error 的兼容，但是无论如何都会继续执行 isDispatching = false 的操作 try &#123; isDispatching = true // 使用 currentReducer 来操作传入 当前状态和 action，放回处理后的状态 currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; 这个函数是用来触发状态改变的，它接受一个 action 对象作为参数，然后 reducer 根据 action 的属性以及当前 store 的状态来生成一个新的状态，赋予当前状态，改变 store 的状态；即currentState = currentReducer(currentState, action)；这里的currentReducer是一个函数，它接受两个参数：当前状态 和 action，然后返回计算出来的新的状态；然后遍历nextListeners列表，调用每个监听函数。 replaceReducer123456789// 判断参数是否是函数类型function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.REPLACE &#125;)&#125; 这个函数可以替换 store 当前的 reducer 函数，首先直接用currentReducer = nextReducer替换；然后dispatch({ type: ActionTypes.INIT })，用来初始化替换后 reducer 生成的初始化状态并且赋予 store 的状态。 observable123456789101112131415161718192021222324function observable() &#123; const outerSubscribe = subscribe return &#123; subscribe(observer) &#123; if (typeof observer !== 'object' || observer === null) &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125;&#125; 对于这个函数，是不直接暴露给开发者的，它提供了给其他观察者模式/响应式库的交互操作。 初始化 store 的状态最后执行dispatch({ type: ActionTypes.INIT })，用来根据 reducer 初始化 store 的状态。 compose.jscompose可以接受一组函数参数，然后从右到左来组合多个函数（这是函数式编程中的方法），最后返回一个组合函数。现在我们来看一下 compose 源代码：123456789101112131415/** * For example, compose(f, g, h) is identical to doing * (...args) =&gt; f(g(h(...args))). */export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; compose其作用是把一系列的函数，组装生成一个新的函数，并且从后到前，后面参数的执行结果作为其前一个的参数，当需要把多个 store 增强器 依次执行的时候，需要用到它。 参数(…funcs)：需要合成的多个函数。每个函数都接收一个函数作为参数，然后返回一个函数。 返回值(Function)：从右到左把接收到的函数合成后的最终函数。 applyMiddleware.js It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer. 这是 redux 作者 Dan 对 middleware 的描述，middleware 提供了一个分类处理 action 的机会，在 middleware 中我们可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给我们改变 action 的机会。Redux middleware 的设计十分特殊，是一个层层包裹的匿名函数，实际上这是函数式编程中的柯里化，一种使用匿名单参数函数来实现多参数函数的方法，柯里化的 middleware 结构好处在于：一：易串联，柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，配合组合的方式，很容易形成 pipeline 来处理数据流。二：共享 store，在 applyMiddleware 执行过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middlewares 内部拿到的 store 是最新且相同的。 redux 提供了 applyMiddleware 这个 api 来加载 middleware。现在我们来看一下 applyMiddleware 源代码：123456789101112131415161718192021222324252627import compose from './compose'export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; // 暴漏 getState 和 dispatch 供第三方中间件使用 const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; // middlewareAPI 作为每个 middleware 的参数依次执行一遍，最终返回函数组成的数组 const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 用 compose 组合函数生成新的 dispatch dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 由上我们可以发现 applyMiddleware 的结构也是一个多层柯里化的函数，借助 compose，applyMiddleware 可以用来和其他插件一起加强 createStore 函数。 参数我们在 createStore 小节中其实就用提及过 applyMiddleware：12345678// 如果 enhancer 存在且是个合法的函数，就调用 enhancer，否则抛出错误提示if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState)&#125; 这里 enhancer 其实就等于 applyMiddleware(mid1, mid2, mid3, …)，因此我们创建一个 store 实际上就变成如下方式了：1applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, preloadedState); 由上述代码可知 applyMiddleware 陆续可以接受四个参数：[md1, mid2, mid3, …]： middlewares 数组；createStore：Redux 原生的 createStore；reducer：函数，返回下一个状态；preloadedState：state 的初始值。接下来，我们看一下 applyMiddleware 用这些参数都做了什么？12345678const store = createStore(...args)const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args)&#125;const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))dispatch = compose(...chain)(store.dispatch) applyMiddleware 利用 createStore 和 (reducer, preloadedState) 创建了一个 store，然后 store 的 getState 方法和 dispatch 方法又分别赋值给 middlewareAPI 变量，紧接着用 middlewareAPI 作为每个 middleware 的参数依次执行一遍，执行完后，最终获得数组 chain：[f1, f2, …, fn] 交给组合函数 compose 处理。compose 可以接受一组函数参数，然后从右到左来组合多个函数（这是函数式编程中的方法），最后返回一个组合函数，例如：1234// 调用dispatch = compose(f, g, h)(store.dispatch)// 返回dispatch = f(g(h(store.dispatch))) 这样通过调用新的 dispatch，每个 middleware 的代码就可以依次执行了。 返回值store：原来的store；dispatch：改变后的dispatch。 combineReducers.jsReducer 是管理 state 的一个模块，它主要做的事情就是当项目初始化时，返回 initalState，当用户用操作时，它会根据 action 进行相应地更新。需要注意的是它是一个纯函数，换言之，它不会改变传入的 state。现在我们来看一下 combineReducers 源码（源码有删减，删除了一些验证代码）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import ActionTypes from './utils/actionTypes'import warning from './utils/warning'import isPlainObject from './utils/isPlainObject'export default function combineReducers(reducers) &#123; // 根据 reducers 生成最终合法的 finalReducers：value 为 函数 const reducerKeys = Object.keys(reducers) const finalReducers = &#123;&#125; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key "$&#123;key&#125;"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers) let unexpectedKeyCache if (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125; &#125; let shapeAssertionError try &#123; assertReducerShape(finalReducers) &#125; catch (e) &#123; shapeAssertionError = e &#125; // 返回最终生成的 reducer return function combination(state = &#123;&#125;, action) &#123; if (shapeAssertionError) &#123; throw shapeAssertionError &#125; if (process.env.NODE_ENV !== 'production') &#123; const warningMessage = getUnexpectedStateShapeWarningMessage( state, finalReducers, action, unexpectedKeyCache ) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; // 遍历一遍验证下是否改变，然后返回原有状态值或者新的状态值 return hasChanged ? nextState : state &#125;&#125; 该函数最终返回 combination 函数，它就是真正 createStore 函数的 reducer，接受一个初始化状态和一个 action 参数；该函数每次调用大致执行以下几个操作：1、for (let i = 0; i &lt; finalReducerKeys.length; i++) { ... }：遍历 finalReducer（有效的 reducer 列表）；2、var previousStateForKey = state[key]：当前遍历项的之前状态，看到这里就应该明白传入的 reducers 组合为什么 key 要和 store 里面的 state 的 key 相对应了；3、var nextStateForKey = reducer(previousStateForKey, action)：当前遍历项的下一个状态；4、nextState[key] = nextStateForKey：将 当前遍历项的下一个状态添加到 nextState；5、hasChanged = hasChanged || nextStateForKey !== previousStateForKey：判断状态是否改变；6、return hasChanged ? nextState : state：如果没有改变就返回原有状态，如果改变了就返回新生成的状态对象。 参数reducers (Object): 一个对象，它的值（value）对应不同的 reducer 函数，这些 reducer 函数后面会被合并成一个。 返回值(Function)：它是真正 createStore 函数的 reducer，接受一个初始化状态和一个 action 参数；每次调用的时候会去遍历 finalReducer（有效的 reducer 列表），然后调用列表中每个 reducer，最终构造一个与 reducers 对象结构相同的 state 对象。 bindActionCreators.jsRedux 中的 bindActionCreators 是通过 dispatch 将 action 包裹起来，这样就可以通过 bindActionCreators 创建方法调用 dispatch(action)。现在我们来看一下 bindActionCreators 源代码：1234567891011121314151617181920212223242526272829303132function bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125;export default function bindActionCreators(actionCreators, dispatch) &#123; // 如果是一个函数，直接返回一个 bindActionCreator 函数，即调用 dispatch 触发 action if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; if (typeof actionCreators !== 'object' || actionCreators === null) &#123; throw new Error( `bindActionCreators expected an object or a function, instead received $&#123; actionCreators === null ? 'null' : typeof actionCreators &#125;. ` + `Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?` ) &#125; // 遍历对象，然后设置每个遍历项的 actionCreator 生成函数，最后返回这个对象 const keys = Object.keys(actionCreators) const boundActionCreators = &#123;&#125; for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const actionCreator = actionCreators[key] if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125; 由此可以看出 bindActionCreators 的实现逻辑比较简单：一、判断传入的参数是否是 object，如果是函数，就直接返回一个将 action creator 包裹在 dispatch 里的函数。二、如果是object，就根据相应的key，生成相应的将 action creator 包裹在 dispatch 里的函数。 为了方便理解，我们用一个 TODO 例子说明下：1234567891011121314// actions/todo.jsexport function addTodo(text) &#123; return &#123; type: 'ADD_TODO', text &#125;&#125;export function removeTodo(id) &#123; return &#123; type: 'REMOVE_TODO', id &#125;&#125; 我们 import 后会得到如下对象：1234567891011&#123; addTodo : text =&gt; &#123; type: 'ADD_TODO', text &#125;, removeTodo : id =&gt; &#123; type: 'REMOVE_TODO', id &#125;&#125; 经过 bindActionCreator 就会变成 key 相同，值为用 dispatch 将 action creator 包裹起来的函数的对象：1234&#123; addTodo : text =&gt; dispatch(addTodo('text')); removeTodo : id =&gt; dispatch(removeTodo('id'));&#125; 由此我们发现可以通过 bindActionCreators 创建方法直接调用 dispatch(action)。 参数它可以接收两个参数：actionCreators、dispatchactionCretors：可以是一个对象，也可以是一个单个函数dispatch：dispatch 函数，从 store 实例中获取，用于包裹 action creator 如果只是传入一个 function，返回的也是一个 function，例如：1234567// actions/todo.jsexport const toggleTodo = (id) =&gt; &#123; return &#123; type: 'TOGGLE_TODO', id &#125;;&#125;; 经过 bindActionCreator：1const boundActionCreators = bindActionCreators(toggleTodo, dispatch); 由于 bindActionCreators 第一个参数是一个函数，结果就会变为：1const boundActionCreators = (id) =&gt; dispatch(toggleTodo(id)); 返回值单个函数，或者是一个对象。 总结通过阅读 Redux 的源码，我们发现 Redux 设计的实在是太精妙了，完全函数式编程，依赖少，耦合低。]]></content>
      <categories>
        <category>redux</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex 源码全方位剖析]]></title>
    <url>%2F2018%2F06%2F29%2Fvuex-source-analysis.html</url>
    <content type="text"><![CDATA[背景Vue 火不火？我们看 github stars 就知道，现在已超越 React 了，国民的力量还是很强大的。我们在使用 Vue.js 开发应用时，经常会遇到多个组件共享同一个状态，也或者多个组件去更新同一个状态。对于简单的应用，我们可以]]></content>
      <categories>
        <category>vuex</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux 源码全方位剖析]]></title>
    <url>%2F2018%2F06%2F27%2Freact-redux-source-analysis.html</url>
    <content type="text"><![CDATA[前言作为前端攻城狮，我们大多都有使用过 Redux，即便没有使用，我相信听肯定听说过。Redux 是一款可预测的状态管理框架，主要提供一个数据存储中心，供外部访问、修改等，因此 Redux 本身和 React 没有什么本质关系。那么我们如何比较优雅的在 React 使用 Redux？传统方法我们可以在应用初始化时，将 store 挂载在 window 上：window.store = createStore(reducer)，然后在需要的地方使用 Redux API：store.getState()、store.dispatch、store.subscribe。。。现在虽然各个子组件都能够访问 store 了，但这里 store 就变成了全局变量。由于全局变量有诸多的缺点，我们不妨换个思路，把 store 直接集成到 React 应用的顶层 props 里面，然后通过 React 钩子 Context，各个子组件就能访问到顶层 props，例如：1234567// 入口文件 index.jsReactDOM.render( &lt;WrapComponent store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/WrapComponent&gt;, document.getElementById('root'))); 现在各个子组件就能够访问到 store 了，这就是我们 react-redux 的设计思路。react-redux 库提供了顶层组件：Provider，然后通过 React 钩子 Context 向应用注入 store，同时它还利用 connect 高阶方法把 Redux API：store.getState()、store.dispatch、store.subscribe等封装起来，使子组件对 store 毫无感知，就好像没有 store 存在一样，然后根据 store state 和组件自身 props 计算得到新props。我们稍后会详细分析 react-redux 的具体实现，在分析源码之前，我们先看一下 react-redux 的源码结构。 源码结构react-redux 的源码结构很简单，源码都在 src 目录下，其目录结构如下：123456789101112131415161718192021src├── components ----------------------------------- 工具函数│ ├── connectAdvanced.js ----------------------- git钩子的目录│ ├── Provider.js ------------------------------ 别名配置文件├── connect -------------------------------------- 加载 middleware│ ├── connect.js ------------------------------- git钩子的目录│ ├── mapDispatchToProps.js -------------------- 别名配置文件│ ├── mapStateToProps.js ----------------------- Rollup 构建文件│ ├── mergeProps.js ---------------------------- Rollup 构建配置的文件│ ├── selectorFactory.js ----------------------- 生成发布通知│ ├── verifySubselectors.js -------------------- 获取 weex 版本│ ├── wrapMapToProps.js ------------------------ 自动发布新版本weex脚本├── utils ---------------------------------------- 生成将 action creator 包裹在 dispatch 里的函数│ ├── isPlainObject.js ------------------------- git钩子的目录│ ├── PropTypes.js ----------------------------- 别名配置文件│ ├── shallowEqual.js -------------------------- Rollup 构建文件│ ├── Subscription.js -------------------------- Rollup 构建配置的文件│ ├── verifyPlainObject.js --------------------- 生成发布通知│ ├── warning.js ------------------------------- 获取 weex 版本│ ├── wrapActionCreators.js -------------------- 自动发布新版本weex脚本├── index.js ------------------------------------- 入口 js 源码入口index.js 是整个代码的入口，其代码如下：12345import Provider, &#123; createProvider &#125; from './components/Provider'import connectAdvanced from './components/connectAdvanced'import connect from './connect/connect'export &#123; Provider, createProvider, connectAdvanced, connect &#125; 入口代码很简单，暴露 Provider，createProvider，connectAdvanced，connect 这几个接口给开发者使用，接下来我们逐一解析这几个 API。 Provider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; Component, Children &#125; from 'react'import PropTypes from 'prop-types'import &#123; storeShape, subscriptionShape &#125; from '../utils/PropTypes'import warning from '../utils/warning'let didWarnAboutReceivingStore = falsefunction warnAboutReceivingStore() &#123; if (didWarnAboutReceivingStore) &#123; return &#125; didWarnAboutReceivingStore = true warning( '&lt;Provider&gt; does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reduxjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.' )&#125;export function createProvider(storeKey = 'store') &#123; const subscriptionKey = `$&#123;storeKey&#125;Subscription` class Provider extends Component &#123; getChildContext() &#123; return &#123; [storeKey]: this[storeKey], [subscriptionKey]: null &#125; &#125; constructor(props, context) &#123; super(props, context) this[storeKey] = props.store; &#125; render() &#123; return Children.only(this.props.children) &#125; &#125; if (process.env.NODE_ENV !== 'production') &#123; Provider.prototype.componentWillReceiveProps = function (nextProps) &#123; if (this[storeKey] !== nextProps.store) &#123; warnAboutReceivingStore() &#125; &#125; &#125; Provider.propTypes = &#123; store: storeShape.isRequired, children: PropTypes.element.isRequired, &#125; Provider.childContextTypes = &#123; [storeKey]: storeShape.isRequired, [subscriptionKey]: subscriptionShape, &#125; return Provider&#125;export default createProvider()]]></content>
      <categories>
        <category>redux</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 开发汇总]]></title>
    <url>%2F2018%2F06%2F12%2Freact-tutorial.html</url>
    <content type="text"><![CDATA[教程React v16北京时间2017 组件复用Mixin 混入模式最原始的一种复用方式应该就是 Mixin。通过将公用逻辑封装为一个 Mixin，通过注入的方式进行组件间的复用。「ps: 该方式不仅用于组件，也流行于各种 css 预处理器中」。 在 React 中，通过React.createClass()方式创建的组件可使用 Mixin 模式，而在 ES6 的伪类模式下，并不支持 Mixin 模式，官方推荐用组合或者高阶组件方式实现复用，废话不多说，使用方式如下：1234567891011121314151617//mixinconst mixinPart = &#123; mixinFunc() &#123; console.log('this mixin!'); return 'this mixin!'; &#125;&#125;;const Contacts = React.createClass(&#123; mixins: [mixinPart], render() &#123; return ( &lt;div&gt;&#123;this.mixinFunc()&#125;&lt;/div&gt; ); &#125;&#125;);// =&gt; 'this mixin!'; 而在 Vue 中，使用逻辑类似：123456789101112//mixinconst mixinPart = &#123; created() &#123; console.log('this mixin!'); return 'this mixin!'; &#125;&#125;;const Component = Vue.extend(&#123; mixins: [mixinPart]&#125;);const component = new Component(); // =&gt; "this mixin!" Mixin 模式给予组件公共抽象与复用能力，但另一方面也具有大量的局限性。由于 Mixin 是侵入式的，因此修改了 Mixin 相当于修改了原组件。其次，在混入过程中，对于相同键值对象与函数的相互覆盖与合并，容易导致各种意外产生。因此使用过程中必须对 Mixin 内部实现有一定了解。强大的灵活性导致了在大型项目中 Mixin 的难维护。 高阶组件高阶组件（High Order Component）这个概念最早是 React 社区提出，借鉴函数式中的高阶函数，提出通过传入一个组件，操作后返回一个新组件的方式进行复用。 在 React 中的使用非常便捷，官方博客中就有相关介绍：12345678910111213141516171819const HOC = (WrappedComponent) =&gt; &#123; const HOC_Component = (props) =&gt; &#123; return ( &lt;React.Fragment&gt; &lt;WrappedComponent &#123;...props&#125; name="WrappedComponent" /&gt; &lt;div&gt;This comes from HOC Component&lt;/div&gt; &lt;/React.Fragment&gt; ); &#125;; HOC_Component.displayName = 'HOC_Component'; return HOC_Component;&#125;const Component = (props) =&gt; &#123; return &lt;div&gt;This message comes from Component: &#123;props.name&#125;&lt;/div&gt;;&#125;const Result = HOC(Component);ReactDOM.render(&lt;Result /&gt;, document.getElementById('root'));// =&gt; This message comes from Component: WrappedComponent// =&gt; This comes from HOC Component Vue 虽然没有官方示例，但与 React 进行类比，Vue 中的组件最终的展现形式是函数，但在过程中，实际上是一个个对象。因此，Vue 中的高阶组件，应当是传入一个对象，最后传出一个对应对象。我们可以简单实现个上例对应的 HOC 功能：12345678910111213141516171819const HOC = (WrappedComponent) =&gt; &#123; const HOC_Component = (props) =&gt; &#123; return ( &lt;React.Fragment&gt; &lt;WrappedComponent &#123;...props&#125; name="WrappedComponent" /&gt; &lt;div&gt;This comes from HOC Component&lt;/div&gt; &lt;/React.Fragment&gt; ); &#125;; HOC_Component.displayName = 'HOC_Component'; return HOC_Component;&#125;const Component = (props) =&gt; &#123; return &lt;div&gt;This message comes from Component: &#123;props.name&#125;&lt;/div&gt;;&#125;const Result = HOC(Component);ReactDOM.render(&lt;Result /&gt;, document.getElementById('root'));// =&gt; This message comes from Component: WrappedComponent// =&gt; This comes from HOC Component Vue 虽然没有官方示例，但与 React 进行类比，Vue 中的组件最终的展现形式是函数，但在过程中，实际上是一个个对象。因此，Vue 中的高阶组件，应当是传入一个对象，最后传出一个对应对象。我们可以简单实现个上例对应的 HOC 功能：123456789101112131415161718192021const HOC = (WrappedComponent) =&gt; &#123; return &#123; components: &#123; 'wrapped-component': WrappedComponent &#125;, template: ` &lt;div&gt; &lt;wrapped-component name="WrappedComponent" v-bind="$attrs" /&gt; &lt;div&gt;This comes from HOC Component&lt;/div&gt; &lt;/div&gt; ` &#125;;&#125;const Component = &#123; props: ['name'], template: '&lt;div&gt;This message comes from Component: &#123;&#123; name &#125;&#125;&lt;/div&gt;'&#125;;new Vue(HOC(Component)).$mount('#root')// =&gt; This message comes from Component: WrappedComponent// =&gt; This comes from HOC Component 高阶组件用途十分广泛，主要可以分为属性代理和反向继承两种。属性代理具体为高阶组件可以直接获取外部传入的参数，根据需求完成变更后重新传给被包含的组件。如上例中就在原始props基础上为WrappedComponent增加了一个name属性，同时在原始渲染基础上增添了一行信息渲染。12345678// 最基本的反向继承const HOC = (WrappedComponent) =&gt; &#123; return class extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125;&#125; 反向继承因为继承于 WrappedComponent，因而能够获取其 state, render 等各种组件数据，从而做到对组件的渲染和 state 状态等的干预。反向继承虽然在日常使用中遇到情况较少，但无疑是高阶组件中笔者认为的一个闪光点 ( 貌似其它方式中暂时没有可以替代的方案 )。例如，在 Vue 中有着 keep-alive 作为组件缓存，而在 React 中官方暂无类似功能，应用 data =&gt; view 的原则，一个常用的替代实现是进行状态保存，然后在需要的时候进行状态还原，在这种情况下，反向继承就是一个很好的工具。123456789101112131415const withStateCached = (WrappedComponent) =&gt; &#123; return class extends WrappedComponent &#123; static getDerivedStateFromProps(nextProps, state) &#123; // 进行数据的存储等 &#125; componentDidMount() &#123; // 进行缓存数据的读取 &#125; render() &#123; return super.render(); &#125; &#125;&#125; 在笔者的实际项目中，更多的把高阶组件看作是一个组件工厂或者装饰者模式的应用，例如对一个基础表格元素进行多次的高阶组件的包装，添加分页、工具栏等功能，形成一个个更符合具体业务需求的新组件，达到组件复用的目的。当然，高阶组件也不是全能的，首先其对于业务耦合度较高，更适合封装一些日常业务中常用的组件。其次最重要的弊端是因为内部产生的的 Props 值固定，容易被外部传入值覆盖。如例子中，当外部也传入了一个 name 属性值时，就会根据组件的写法产生不同的覆盖方式而导致错误。 渲染属性/函数子组件为了解决高阶组件存在的问题，一种新的「Render Props」的方案被提出。该方案提供了一个叫做 render 的函数作为 Props 参数传入，在内部处理完毕后，将所需的组件信息，数据作为 render 的参数传出，从而实现更加灵活的复用逻辑。123456789const RenderProps = (&#123; render, ...props &#125;) =&gt; render(props, 'RenderPropComponent');const Component = () =&gt; ( &lt;RenderProps render=&#123;(originProps, componentName) =&gt; (&lt;div&gt;From &#123;componentName&#125;&lt;/div&gt;)&#125; /&gt;);ReactDOM.render(&lt;Component /&gt;, document.getElementById('root'));// =&gt; From RenderPropComponent 在该例中，我们通过 render 函数传入了原 Props 和一个新的 name 属性，在实际使用中，重新命名 name 为 componentName，由此避开了高阶组件的弊端。 由此理念，在 React 中，延伸出函数子组件的概念，将 children 作为函数使用，更加贯彻了一切皆为组件的概念。同时在 React@16.3 版本中，FB 官方的 Context 新 API 的实现也采用了函数子组件的方式。1234567const RenderProps = (&#123; children, ...props &#125;) =&gt; children(props, name = 'RenderPropComponent');const Component = () =&gt; (&lt;RenderProps&gt; &#123;(originProps, componentName) =&gt; (&lt;div&gt;From &#123;componentName&#125;&lt;/div&gt;)&#125;&lt;/RenderProps&gt;);ReactDOM.render(&lt;Component /&gt;, document.getElementById('root'));// =&gt; From RenderPropComponent 而在 Vue@2.5 后的版本中，slot-scope 的概念也有点渲染属性的影子。123456789101112131415161718const RenderProps = &#123; template: `&lt;div&gt;&lt;slot v-bind="&#123; name: 'RenderPropComponent' &#125;"&gt;&lt;/slot&gt;&lt;/div&gt;`&#125;;const vm = new Vue(&#123; el: '#root', components: &#123; 'render-props': RenderProps &#125;, template: ` &lt;render-props&gt; &lt;template slot-scope="&#123; name &#125;"&gt; &lt;div&gt;From Component&lt;/div&gt; From &#123;&#123; name &#125;&#125; &lt;/template&gt; &lt;/render-props&gt; `&#125;);// =&gt; From Component// =&gt; From RenderPropComponent 组件注入组件注入（Component Injection）的概念有些类似渲染属性，都是传递一个类似 render 的函数属性，区别在于组件注入将该函数作为 React 中的无状态组件使用，而非原始的函数。12345const RenderProps = (&#123; Render, ...props &#125;) =&gt; &lt;Render &#123;...props&#125; name='RenderPropComponent' /&gt;;const Component = () =&gt; (&lt;RenderProps Render=&#123;(&#123; name &#125;) =&gt; (&lt;div&gt;From &#123;name&#125;&lt;/div&gt;)&#125; /&gt;);ReactDOM.render(&lt;Component /&gt;, document.getElementById('root'));// =&gt; From RenderPropComponent 与渲染属性相比，组件注入能在 devTool 的组件树上直观的展现出内嵌的组件结构。但在另一方面，由于所有属性都被打包成了 props 传出，反而失去了渲染属性的多参数的灵活性。 常见问题render 中使用箭头函数或绑定会导致子组件重新渲染问题：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import React from 'react';import &#123; render &#125; from 'react-dom';import User from './User';class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; users: [ &#123; id: 1, name: 'Cory' &#125;, &#123; id: 2, name: 'Meg' &#125;, &#123; id: 3, name: 'Bob' &#125; ] &#125;; &#125; deleteUser = id =&gt; &#123; this.setState(prevState =&gt; &#123; return &#123; users: prevState.users.filter( user =&gt; user.id !== id) &#125; &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Users&lt;/h1&gt; &lt;ul&gt; &#123; this.state.users.map( user =&gt; &#123; return &lt;User key=&#123;user.id&#125; name=&#123;user.name&#125; onDeleteClick=&#123;() =&gt; this.deleteUser(user.id)&#125; /&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;export default App;render(&lt;App /&gt;, document.getElementById('root'));// user.jsimport React from 'react';// Note how the debugger below gets hit when *any* delete// button is clicked. Why? Because the parent component// uses an arrow function, which means this component//class User extends React.PureComponent &#123; render() &#123; const &#123;name, onDeleteClick &#125; = this.props console.log(`$&#123;name&#125; just rendered`); return ( &lt;li&gt; &lt;input type="button" value="Delete" onClick=&#123;onDeleteClick&#125; /&gt; &#123;name&#125; &lt;/li&gt; ); &#125;&#125;export default User; 以上例子中，在 render 函数中使用了一个箭头函数将一个值传递给了 deleteUser 函数，这就是问题的所在。 每次 render 调用时，控制台上都会打印日志。User 已经被声明为 PureComponent。所以 User 应该只在 props 或者 state 改变时才会重新 render。但是，当你点击 delete 按钮时，对于每一个 User 实例，都会调用 render。 原因在于：父组件在 props 中传递了一个箭头函数。箭头函数在每次 render 时都会重新分配（和使用 bind 的方式相同）。所以，尽管我将 User 声明为 PureComponent，User 的父组件中的箭头函数导致 User 组件为所有的用户实例传递了一个新的函数。所以当点击任何删除按钮时，每个用户实例都会重新 render。 结论：避免在 render 中使用箭头函数和绑定。否则会打破 shouldComponentUpdate 和 PureComponent 的性能优化。 解决办法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import React from 'react';import &#123; render &#125; from 'react-dom';import User from './User';class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; users: [ &#123; id: 1, name: 'Cory' &#125;, &#123; id: 2, name: 'Meg' &#125;, &#123; id: 3, name: 'Bob'&#125; ], &#125;; &#125; deleteUser = id =&gt; &#123; this.setState(prevState =&gt; &#123; return &#123; users: prevState.users.filter(user =&gt; user.id !== id) &#125;; &#125;); &#125;; renderUser = user =&gt; &#123; return &lt;User key=&#123;user.id&#125; user=&#123;user&#125; onClick=&#123;this.deleteUser&#125; /&gt;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Users&lt;/h1&gt; &lt;ul&gt; &#123;this.state.users.map(this.renderUser)&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;render(&lt;App /&gt;, document.getElementById('root'));import React from "react";import PropTypes from "prop-types";// Note that the console.log below isn't called// when delete is clicked on a user.// That's because pureComponent's shallow// comparison works properly here because// the parent component isn't passing down// an arrow function (which would cause this// component to see a new function on each render)class User extends React.PureComponent &#123; onDeleteClick = () =&gt; &#123; // No bind needed since we can compose the relevant data for this item here this.props.onClick(this.props.user.id); &#125;; render() &#123; console.log(`$&#123;name&#125; just rendered`); return ( &lt;li&gt; &lt;input type="button" value="Delete" onClick=&#123;this.onDeleteClick&#125; /&gt; &#123;this.props.user.name&#125; &lt;/li&gt; ); &#125;&#125;User.propTypes = &#123; user: PropTypes.object.isRequired, onClick: PropTypes.func.isRequired&#125;;export default User; 在 User.js 中，onDeleteClick 调用了在 props 中传递的 onClick 函数，并传递了相应的 user.id。 当你再次点击 delete 按钮时，其他的用户再也不会调用 render 了！ 总结为了最佳性能：1、避免在 render 中使用箭头函数和绑定。2、怎么做？提取子组件，或者直接传递数据给 HTML 元素。 函数作为React组件的方法时, 箭头函数和普通函数的区别是什么问题：123456789class App extends Component &#123; a() &#123; console.log(1) &#125; a = () =&gt; &#123; console.log(1) &#125;&#125; 里面的两个 a 的定义有什么区别？第一个 a 不必说，是原型方法的定义，很显然第一个写法是非法的。宽松模式下对应 ES5 就是：1App.prototype.a = function() &#123;&#125; 第二个是 Stage 2 Public Class Fields 里面的写法，babel 下需要用 Class properties transform Plugin 进行转义。相当于：12345678class App extends Component &#123; constructor (...args) &#123; super(...args) this.a = () =&gt; &#123; console.log(1) &#125; &#125;&#125; 为什么需要第二种写法？ 在 React 里面，要将类的原型方法通过 props 传给子组件，传统写法需要 bind(this)，否则方法执行时 this 会找不到：123&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/button&gt;// 或&lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;&lt;/button&gt; 这种写法难看不说，还会对 React 组件的 shouldComponentUpdate 优化造成影响。 这是因为 React 提供了 shouldComponentUpdate 让开发者能够控制避免不必要的 render，还提供了在 shouldComponentUpdate 自动进行 Shallow Compare 的 React.PureComponent, 继承自 PureComponent 的组件只要 props 和 state 中的值不变，组件就不会重新 render。 然而如果用了 bind this，每次父组件渲染，传给子组件的 props.onClick 都会变，PureComponent 的 Shallow Compare 基本上就失效了，除非你手动实现 shouldComponentUpdate. 使用 Public Class Fields 的这种写法，就解决了这个问题。另外还有其他若干种办法，比如先定义原型方法，然后在 constructor 里面 bind 一遍；或者使用 decorator 进行 bind 等：1234567891011class A &#123; constructor() &#123; this.a = this.a.bind(this) &#125; a() &#123;&#125; // or @bindthis b() &#123;&#125;&#125; 优秀写法子组件事件父组件定义12345678910111213141516171819202122232425262728class Parent extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; &#125; &#125; getData = () =&gt; &#123; // 子类的方法在父类直接使用 // 子类的方法在父类直接使用 &#125; render() &#123; return ( &lt;div className='parent-container'&gt; &lt;Child onClick=&#123;this.getData&#125; /&gt; &lt;/div&gt; ) &#125;&#125;class Child extends Component &#123; render() &#123; const that = this; const &#123; ...others &#125; = that.props; return ( &lt;div className='child-container' &#123;...others&#125;&gt; &lt;div className='short-icon'&gt;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQl 开发笔记]]></title>
    <url>%2F2018%2F06%2F05%2Fmysql-tutorial.html</url>
    <content type="text"><![CDATA[常用命令 1、查看Mysql服务运行状态 1ps aux |grep mysqld 2、检测mysql是否已经启动 1service mysqld status 3、登陆数据库 12mysql -uroot -p然后再输入密码]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天两分钟，了解一个流行 NPM 库]]></title>
    <url>%2F2018%2F06%2F01%2Fnpm-tutorial.html</url>
    <content type="text"><![CDATA[每天两分钟，了解一个流行NPM库，废话少说，直接上npm库。 控制台signaleSignale 是一个优雅漂亮的控制台日志输出工具，其核心是可扩展和可配置的，可将其用于日志记录、状态报告以及处理其他 Node 模块和应用的输出渲染方式。 chokidar像 webpack/grunt/gulp 等工具都提供watch模式，当磁盘文件变化后自动重新运行打包。今天我们要学习的chokidar就是一款专门用于文件监控的库。 serialize-javascript将JavaScript序列化为JSON的超集，其中包括正则表达式，日期和函数。 memory-fs一个简单的内存文件系统。在javascript对象中保存数据。 webpack-dev-middleware它就是一个用来组织包装 webpack 使其可以中介软体或称中间件的容器。回想一下 express 我们大概可以明白关于 middleware 的用途，就是在输入到输出的过程中加工的一种手段。单纯说 middleware 的话，我们可以想成一系列任务。 webpack-hot-middlewarewebpack-hot-middleware 是用来进行页面的热重载的,刷新浏览器 一般和 webpack-dev-middleware 配合使用，实现热加载功能。 globglob模式是指 shell 所使用的简化了的正则表达式。 upathpath的代理，将\替换为/，用于添加，更改，默认，修剪文件扩展名的所有结果和方法。 minimist 轻量级的命令行参数解析引擎chalk 命令行彩色输出esm 零依赖ES模块加载器pify 一个专门用来将callback样式的库转化为Promise风格接口的库，除此之外别无任何其他功能hash-sum 快速唯一 hash 生成器netlify 静态网站托管服务平台]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript Promise]]></title>
    <url>%2F2018%2F05%2F25%2Fpromise.html</url>
    <content type="text"><![CDATA[背景从JavaScript中的异步任务说起，典型的异步任务，是一个setTimeout调用。123setTimeout(() =&gt; &#123; // 爱干啥干啥&#125;, 1000) 通常用JS写异步任务的时候，会分成两个部分：主过程和后续过程，在主过程执行成功后，触发后续过程执行。比如，在实际编程中经常需要使用AJAX向服务器请求数据，成功获取到数据后，才开始处理数据。于是代码分成获取数据部分和处理数据部分，像下面这样：123getData((data) =&gt; &#123; // 处理data&#125;) 上面这两个处理异步任务的编程方式都是采用的回调函数的形式。现在假设有多个异步任务，且任务间有依赖关系（一个任务需要拿到另一个任务成功后的结果才能开始执行）的时候，回调的方式写出来的代码就会像下面这样：1234567891011getData1(data1 =&gt; &#123; getData2(data1, data2 =&gt; &#123; getData3(data2, data3 =&gt; &#123; getData4(data3, data4 =&gt; &#123; getData5(data4, data5 =&gt; &#123; // 终于取到data5了 &#125;) &#125;) &#125;) &#125;)&#125;) 这种代码被称为回调地狱或者回调金字塔。假设上面的任务，想要换一下执行顺序，代码修改起来，就比较麻烦了。如果内容复杂，阅读代码的时候跳来跳去，也让人头大。如果用promise改写一下：1234567891011// 先把getData们都转成返回promise对象的函数// 然后getData1().then(getData2).then(getData3).then(getData4).then(getData5).then(data =&gt; &#123; // 取到最终data了&#125;) 这样的代码，是线性的，符合人的阅读习惯，代码表示的流程清晰，便于阅读。 Promise 概念Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。从写法上说，Promise 就是一种用来写JavaScript编程中的异步代码的方式。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 特点 对象的状态不受外界影响。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 用法首先要认清最基本的用法。一般学习Promise看到的第一段代码是这样：123456789101112131415let p = new Promise((resolve, reject) =&gt; &#123; // 做一些事情 // 然后在某些条件下resolve，或者reject if (/* 条件随便写^_^ */) &#123; resolve() &#125; else &#123; reject() &#125;&#125;)p.then(() =&gt; &#123; // 如果p的状态被resolve了，就进入这里&#125;, () =&gt; &#123; // 如果p的状态被reject&#125;) 第一段调用了Promise构造函数，第二段是调用了promise实例的.then方法。构造实例 构造函数接受一个函数作为参数 调用构造函数得到实例p的同时，作为参数的函数会立即执行 参数函数接受两个回调函数参数resolve和reject 在参数函数被执行的过程中，如果在其内部调用resolve，会将p的状态变成fulfilled，或者调用reject，会将p的状态变成rejected 调用.then 调用.then可以为实例p注册两种状态回调函数 当实例p的状态为fulfilled，会触发第一个函数执行 当实例p的状态为rejected，则触发第二个函数执行 上面这样构造promise实例，然后调用.then.then.then的编写代码方式，就是promise。其基本模式是： 将异步过程转化成promise对象 对象有3种状态 通过.then注册状态的回调 已完成的状态能触发回调 采用这种方式来处理编程中的异步任务，就是在使用promise了，所以promise就是一种异步编程模式。 Promise 状态首先，promise实例有三种状态： pending（待定） fulfilled（已执行） rejected（已拒绝）fulfilled和rejected有可以说是已成功和已失败，这两种状态又归为已完成状态 resolve和reject调用resolve和reject能将分别将promise实例的状态变成fulfilled和rejected，只有状态变成已完成（即fulfilled和rejected之一），才能触发状态的回调。 Promise APIpromise的内容分为构造函数、实例方法和静态方法： 1个构造函数： new Promise 2个实例方法：.then、.catch、finally 4个静态方法：Promise.all、Promise.race、Promise.resolve、Promise.reject和Promise.try 下面逐个讲下他们的作用： new Promise能将一个异步过程转化成promise对象。先有了promise对象，然后才有promise编程方式。 .then用于为promise对象的状态注册回调函数。它会返回一个promise对象，所以可以进行链式调用，也就是.then后面可以继续.then。在注册的状态回调函数中，可以通过return语句改变.then返回的promise对象的状态，以及向后面.then注册的状态回调传递数据；也可以不使用return语句，那样默认就是将返回的promise对象resolve。 .catch用于注册rejected状态的回调函数，同时该回调也是程序出错的回调，即如果前面的程序运行过程中出错，也会进入执行该回调函数。同.then一样，也会返回新的promise对象。 调用Promise.resolve会返回一个状态为fulfilled状态的promise对象，参数会作为数据传递给后面的状态回调函数。 Promise.reject与Promise.resolve同理，区别在于返回的promise对象状态为rejected。]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下登录MySQL]]></title>
    <url>%2F2018%2F05%2F22%2Fmysql-login.html</url>
    <content type="text"><![CDATA[格式：mysql -h主机地址 -u用户名－p用户密码 一、连接到本机上的MYSQL： 1、开启MySQL服务后，一般可以直接键入命令mysql -uroot -p，回车后提示你输密码：1mysql -uroot -p 二、连接到远程主机上的MySQL： 1、假设远程主机的IP为：10.0.0.1，用户名为root,密码为123。则键入以下命令（注：u与root可以不用加空格，其它也一样）： 1mysql -h10.0.0.1 -uroot -p123]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>login</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 组件注册时什么情况在require后面加上default]]></title>
    <url>%2F2018%2F05%2F20%2Fvue-require-component-way.html</url>
    <content type="text"><![CDATA[今天团队内部一起回顾之前项目时，发现两个记忆中相同配置的项目，但其中一个项目可以直接用这样的代码注册组件：1Vue.component('Menu', require("./components/common/Menu.vue")); 然而另外一个项目却需要这样注册组件：1Vue.component('Menu', require("./components/common/Menu.vue").default); 否则的话就会报错:1Failed to mount component: template or render function not defined 这到底是怎么回事？ 首先 webpack 支持 CommonJS、AMD 和 ES6模块打包。当我们用 .vue 单文件写组件时，在 script 标签内使用的是 ES6 的语法且使用 export default 进行默认导出。然而，require 是 CommonJS 的模块导入方式，不支持模块的默认导出，因此导入的结果其实是一个含 default 属性的对象，因此需要使用 .default 来获取实际的组件，当然我们也可以使用 ES6 的 import 语句，如果使用 import，需要给定一个变量名，所有 import 语句必须统一放在模块的开头。相反，如果 .vue 文件中使用 CommonJS 或 AMD 模块化语法，使用 module.exports 对象进行导出，那么使用 require 导入时就不需要使用 .default 来获取。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>require</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESlint 开发汇总]]></title>
    <url>%2F2018%2F05%2F12%2Feslint-tutorial.html</url>
    <content type="text"><![CDATA[前言ESLint 最初是由 Nicholas C. Zakas 于2013年6月创建的开源项目。它是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，目标是保证代码的一致性和避免错误。在许多方面，它和 JSLint、JSHint 相似，除了少数的例外：一：ESLint 使用Espree解析 JavaScript。二：ESLint 使用 AST 去分析代码中的模式。三：ESLint 是完全插件化的。每一个规则都是一个插件并且我们可以在运行时添加更多的规则。 安装在安装 ESLint 之前请确保满足以下几个条件：Node.js（&gt; = 4.x），npm version 2+。有两种方式安装 ESLint： 全局安装和本地安装。我们建议全局安装 ESLint：1$ npm install -g eslint 接下来设置一个 eslint 配置文件：1$ eslint --init 配置规则root默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果我们想要所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在我们项目根目录下的package.json文件或者.eslintrc.*文件里的eslintConfig字段下设置&quot;root&quot;: true。ESLint 一旦发现配置文件中有&quot;root&quot;: true，它就会停止在父级目录中寻找。 parserOptions解析器选项可以在.eslintrc.*文件使用parserOptions属性设置。可用的选项有：sourceType - 设置为&quot;script&quot;（默认）或&quot;module&quot;（如果我们的代码是 ECMAScript 模块)。 parser指定一个不同的解析器，以下解析器与 ESLint 兼容：1、Esprima2、Babel-ESLint一个对Babel解析器的包装，使其能够与 ESLint 兼容。3、typescript-eslint-parser一个把 TypeScript 转换为 ESTree 兼容格式的解析器 注意，在使用自定义解析器时，为了让 ESLint 在处理非 ECMAScript 5 特性时正常工作，配置属性 parserOptions 仍然是必须的。解析器会被传入 parserOptions，但是不一定会使用它们来决定功能特性的开关。 env环境变量，可用的环境包括：browser：浏览器环境中的全局变量。node：Node.js 全局变量和 Node.js 作用域。jest：Jest 全局变量。 extends继承一些标准库 常见问题eslint 支持async、await1$ npm install babel-eslint --save-dev 在eslint的配置文件中增加&quot;parser&quot;: &quot;babel-eslint&quot;。 Do not use ‘new’ for side effects代码如下：123456new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 报错： 原因：刪除了以下注释。这句注释可以绕过规则检测： 1/* eslint-disable no-new */ 在new Vue()上方加上句注釋即可：1234567/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) vue-cli构建的项目，eslint一直报CRLF/LF的linebreak错误如题，vue在构建项目的时候选择了airbnb规则，同时项目构建后被windows的unix bash工具pull并且push过，这之后在windows上进行开发，就开始一直报 1Expected linebreaks to be 'CRLF' but found 'LF' 这样的错误，后经查是一种强制统一方式，并且解决方法是 1linebreak-style: ["error", "windows"] 强制使用windows方式，我将之添加到了项目根目录下的 .eslintrc.js 文件中的rule字段下：12345678910111213141516// add your custom rules here 'rules': &#123; // don't require .vue extension when importing 'import/extensions': ['error', 'always', &#123; 'js': 'never', 'vue': 'never' &#125;], // allow optionalDependencies 'import/no-extraneous-dependencies': ['error', &#123; 'optionalDependencies': ['test/unit/index.js'] &#125;], // try to fix the line break problem 'linebreak-style': ["error", "windows"], // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0 &#125; 结果无效，现有问题二个： 是否是因为系统环境不同而造成了某种强制转换才会引发如上的错误？ 如何选择性的关闭eslint某个功能（linebreak检查）？ 问题1:*不同的操作系统下，甚至是不同编辑器，不同工具处理过的文件可能都会导致换行符的改变。 问题2： 项目根目录下有.eslintrc.js文件，在配置文件中修改rule配置项，如下： 123// 统一换行符，"\n" unix(for LF) and "\r\n" for windows(CRLF)，默认unix// off或0: 禁用规则'linebreak-style': 'off']]></content>
      <categories>
        <category>eslint</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa 源码全方位剖析]]></title>
    <url>%2F2018%2F05%2F10%2Fkoa-source-analysis.html</url>
    <content type="text"><![CDATA[前言Koa 基于 Node.js 平台的下一代 web 开发框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。使用 Koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 源码结构Koa 的源码结构很简单，源码都在 lib 目录下，其目录结构如下：12345lib├── application.js ------------------------------- 入口文件，也是骨架文件，创建一个服务├── context.js ----------------------------------- app 的 context 对象，传入中间件的上下文对象├── request.js ----------------------------------- app 的请求对象，包含请求相关的一些属性├── response.js ---------------------------------- app 的响应对象，包含响应相关的一些属性]]></content>
      <categories>
        <category>koa</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 开发汇总]]></title>
    <url>%2F2018%2F05%2F08%2Fwebpack-tutorial.html</url>
    <content type="text"><![CDATA[webpack 教程require.contextrequire.context：创建自己的（模块）上下文，这个方法有 3 个参数：要搜索的文件夹目录，是否还应该搜索它的子目录，以及一个匹配文件的正则表达式。1require.context(directory, useSubdirectories = false, regExp = /^\.\//) 1234567891011121314151617/*** 创建一个* 包含了 test 文件夹* 不包含子目录下面的* 所有文件名以 `.test.js` 结尾的、* 能被 require 请求到的文件的上下文。*/require.context("./test", false, /\.test\.js$/);/*** 创建一个* 包含了父级文件夹* 包含子目录下面的* 所有文件名以 `.stories.js` 结尾的* 能被 require 请求到的文件的上下文。*/require.context("../", true, /\.stories\.js$/); require.context模块导出（返回）一个（require）函数，这个函数可以接收一个参数：request 函数 – 这里的 request 应该是指在 require() 语句中的表达式。require.context 第一个参数不能是变量，webpack在编译阶段无法定位目录。导出的方法有 3 个属性： resolve, keys, id。resolve：函数，它返回请求被解析后得到的模块 id。keys：函数，它返回一个数组，由所有可能被上下文模块处理的请求组成。id：上下文模块里面所包含的模块 id. 它可能在你使用 module.hot.accept 的时候被用到。 示例一：引入多张图片123import img1 from '../../assets/img1.jpeg';import img2 from '../../assets/img2.jpeg';import img3 from '../../assets/img3.jpeg'; 上面页面上需要的图片很多，这样做太麻烦了，有没有批量引入的办法呢？12const requireContext = require.context("../../assets", false, /^\.\/.*\.jpeg$/);const images = requireContext.keys().map(requireContext); 示例二：多个js文件12const context = require.context('./', false, /\.js$/);const models = context.keys().filter(item =&gt; item !== './index.js').map(context); Node 环境变量 process.env.NODE_ENV 之webpack应用文档中说： DefinePlugin 在原始的源码中执行查找和替换操作，在导入的代码中，任何出现 process.env.NODE_ENV的地方都会被替换为”production”。因此，形如if (process.env.NODE_ENV !== ‘production’) console.log(‘……’) 的代码就会等价于 if (false) console.log(‘……’) 并且最终通过UglifyJS等价替换掉。也就是说，webpack config文件中定义的变量：123new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('production')&#125;) 是为了我们将要打包的文件中用的。那如何在webpack config文件中使用 process.env.NODE_ENV 呢？答案是corss-env。 接下来进入主题，开始配置 webpack.config.js:12345678910111213141516const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const config = &#123; entry:path.join(__dirname,"src/app.js"), output:&#123; path:path.join(__dirname,"dist"), filename:"bundle.js" &#125;, plugins:[ new HtmlWebpackPlugin() ]&#125;module.exports = configconsole.log("process.env.NODE_ENV 的值是(webpack.config.js)："+ process.env.NODE_ENV) 然后新建文件 src/app.js：123console.log("app test")console.log("process.env.NODE_ENV 的值是(app.js)："+ process.env.NODE_ENV) 一切准备好后，给package.json加一行 ：”build”: “webpack”123"scripts": &#123; "build":"webpack"&#125; 由于没有进行任何配置，所以上面的输出中给出的信息是：1process.env.NODE_ENV 的值是(webpack.config.js)：undefined 通过浏览器访问/dist/index.html，控制台有如下信息输出：12app test process.env.NODE_ENV 的值是(app.js)：undefined 也就是说，在/src/app.js里，process.env.NODE_ENV 也未定义。 通过webpack -p参数控制在package.json里增加一行：1234"scripts": &#123; "build":"webpack", "build-p":"webpack -p"&#125; 然后执行： npm run build-p 命令行输出没有任何变化，仍然是：1process.env.NODE_ENV 的值是(webpack.config.js)：undefined 但通过浏览器访问/dist/index.html，控制台有如下信息输出：12app test process.env.NODE_ENV 的值是(app.js)：production 也就是说，通过webpack -p，然process.env.NODE_ENV值传递给app.js了（webpack.config.js并未获取到~） 通过 webpack.DefinePlugin 定义接着看，假设webpack.config.js是基本定义，针对上线产品，额外定义了webpack.config.prod.js，然后通过webpack-merge合并两个配置文件webpack.config.prod.js如下：12345678910111213141516const webpack = require('webpack')const merge = require('webpack-merge')const config = require("./webpack.config.js")module.exports = merge(config,&#123; plugins:[ new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: process.env.NODE_ENV === 'production' &#125;) ]&#125;)console.log("process.env.NODE_ENV 的值是(webpack.config.prod.js)："+ process.env.NODE_ENV) 可以看到，在这个文件里，我们通过webpack.DefinePlugin定义了process.env.NODE_ENV，现在在package.json里增加一行，并通过–config指定配置文件：12345"scripts": &#123; "build":"webpack", "build-p":"webpack -p", "build-prod":"webpack --config webpack.config.prod.js"&#125;, 然后执行：npm run build-prod，命令行里有如下输出：12process.env.NODE_ENV 的值是(webpack.config.js)：undefined process.env.NODE_ENV 的值是(webpack.config.prod.js)：undefined 通过浏览器访问/dist/index.html，控制台有如下信息输出：12app test process.env.NODE_ENV 的值是(app.js)：production 这次没有用webpack -p参数，而是在webpack.config.prod.js里通过webpack.DefinePlugin定义了process.env.NODE_ENV，取得了相当的效果。 在config文件里获取NODE_ENV值解决了在app.js获取NODE_ENV的值，如何在webpack配置文件里获取NODE_ENV的值呢，这样就可以根据不同的值定义相关的参数了，如上所述，答案是：corss-env，在package.json里增加一行：123456"scripts": &#123; "build":"webpack", "build-p":"webpack -p", "build-prod":"webpack --config webpack.config.prod.js", "build-cross-env":"cross-env NODE_ENV=production webpack"&#125; 这里执行：npm run build-cross-env，命令行里会得到：1process.env.NODE_ENV 的值是(webpack.config.js)：production 通过浏览器访问/dist/index.html，控制台有如下信息输出：12app test process.env.NODE_ENV 的值是(app.js)：undefined 可以看到，通过cross-env NODE_ENV=production，然信息传递给了webpack的配置文件，但app.js并没有获取到。 很自然的想到，如果里要在配置文件里和业务代码里，都获取到NODE_ENV，那将3、4结合起来：1234567"scripts": &#123; "build":"webpack", "build-p":"webpack -p", "build-prod":"webpack --config webpack.config.prod.js", "build-cross-env":"cross-env NODE_ENV=production webpack", "build-cross-env-with-prod":"cross-env NODE_ENV=production webpack --config webpack.config.prod.js"&#125; 运行： npm run build-cross-env-with-prod，命令行中有显示：12process.env.NODE_ENV 的值是(webpack.config.js)：production process.env.NODE_ENV 的值是(webpack.config.prod.js)：production 通过浏览器访问/dist/index.html，控制台有如下信息输出：12app test process.env.NODE_ENV 的值是(app.js)：production Webpack Code Splitting首先说，code splitting指什么。我们打包时通常会生成一个大的bundle.js(或者index,看你如何命名)文件，这样所有的模块都会打包到这个bundle.js文件中，最终生成的文件往往比较大。code splitting就是指将文件分割为块(chunk)，webpack使我们可以定义一些分割点(split point)，根据这些分割点对文件进行分块，并实现按需加载。 code splitting的意义1、第三方类库单独打包。由于第三方类库的内容基本不会改变，可以将其与业务代码分离出来，这样就可以将类库代码缓存在客户端，减少请求。2、按需加载。webpack支持定义分割点，通过require.ensure进行按需加载。3、通用模块单独打包。我们代码中可能会有一些通用模块，比如弹窗、分页、通用的方法等等。其他业务代码模块常常会有引用这些通用模块。若按照2中做，则会造成通用模块重复打包。这时可以将通用模块单独打包出来。 如何进行code spliting第三方类库我们项目中常常会用到一些第三方的类库，比如jquery,bootstrap等。可以配置多入口来将第三方类库单独打包，如下： 12345678910//在entry中添加入口entry: &#123; index: './index', vendor: ['jquery', 'bootstrap']&#125;,//在plugins中配置plugins: [ new webpack.optimize.CommonsChunkPlugin("vendor", "vendor.bundle.js"),] 说明 CommonsChunkPlugin提供两个参数，第一个参数为对应的chunk名（chunk指文件块，对应entry中的属性名），第二个参数为生成的文件名。这个插件做了两件事：1、将vendor配置的模块（jquery,bootstrap）打包到vendor.bundle.js中。2、将index中存在的jquery, bootstrap模块从文件中移除。这样index中则只留下纯净的业务代码。 按需加载以基于backbone的单页面应用为例，可以在router中进行配置实现按需加载，如下： 1234567891011121314151617181920212223// router.jsvar Router = Backbone.Router.extend(&#123; routes: &#123; 'a': 'a', 'b': 'b' &#125;, a: function() &#123; require.ensure(['./a'], (require) =&gt; &#123; let a = require('./a'); //do something &#125;) &#125;, b: function() &#123; require.ensure(['./b'], (require) =&gt; &#123; let b = require('./b'); //do something &#125;) &#125;&#125;) 说明如上方式将打出两个文件，a.js和b.js（当然名字会有所不同），且为按需加载。只有在访问a时，a.js才会被加载，b同理。但是这种做法存在两个问题：1、若路由分配不合理，会打包出很多很小的文件，每个文件或许只有几k，却多了很多网络请求，得不偿失。2、会造成通用模块的重复打包，比如a模块和b模块都引用了c模块， 12345// aimport 'c' from './c'// bimport 'c' from './c' 这样我们会发现打包出的a.js和b.js中都包含c模块的代码，造成了代码冗余。 对于问题1，可以通过webpack提供的插件来解决： 1234//在plugins中添加该插件：plugins: [ new webpack.optimize.AggressiveMergingPlugin()] 对于问题2:可以按照下文中所说方式解决。 常见问题webpack-cli（v4）Q：由于webpack-cli从webpack包里面分离出来了，未安装webpack-cli会产生以下错误：1234567One CLI for webpack must be installed. These are recommended choices, delivered as separate packages: - webpack-cli (https://github.com/webpack/webpack-cli) The original webpack full-featured CLI. - webpack-command (https://github.com/webpack-contrib/webpack-command) A lightweight, opinionated webpack CLI.We will use &quot;npm&quot; to install the CLI via &quot;npm install -D&quot;.Which one do you like to install (webpack-cli/webpack-command): A：1$ npm install webpack-cli -D mode（v4）Q：未设置mode属性123WARNING in configurationThe &apos;mode&apos; option has not been set, webpack will fallback to &apos;production&apos; for this value. Set &apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults for each environment.You can also set it to &apos;none&apos; to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/ A：development：开发模式，webpack会默认配置常用于开发的参数，如输出运行时的错误信息等production：产品模式，webpack会默认配置常用语产品构建的餐宿，如压缩代码等12345678// 配置文件module.exports = &#123; mode: 'development' // mode: 'production'&#125;// 命令行webpack --mode developmentwebpack --mode production loader 加载顺序loader 的加载顺序是从右往左的。为啥是从右往左，而不从左往右，那是因为Webpack选择了compose方式，而不是pipe的方式而已。123compose : require("style-loader!css-loader!sass-loader!./my-styles.sass");pipe : require("./my-styles.sass!sass-loader!css-loader!style-loader");]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode 使用汇总]]></title>
    <url>%2F2018%2F05%2F05%2Fvscode-tutorial.html</url>
    <content type="text"><![CDATA[基本使用常用命名ctrl + k 清空终端内容 设置设置tab的空格数方案一：文件 -&gt; 首选项 -&gt; 设置。将 editor.tabSize 改为 2。注意：复制到右侧修改。 插件Setting Sync 插件 使用插件将目前配置保存到GitHub上，以后只需要从GitHub上获取，就可以一次性安装插件配置信息。 适用于电脑更换时还要一个个去搜索插件安装，公司电脑和个人电脑同步。 注册申请github账号 安装了git 步骤如下首先在VSCode里面搜索Setting Sync插件，安装好后重新加载激活 Upload Key : Shift + Alt + U Download Key : Shift + Alt + D Shift + Alt + U 这一步好像在有文件打开时才有用 在跳出来的页面点击 generate new tooken 将生成的key输入vscode命令框里 上传完成后会生成一个ID，要记下来ID和key不同 使用Shift + Alt + D，输入ID，即可开始同步配置常见问题ES6 及以上vscode中使用Experimental Decorators报错在vscode中使用es7的新语法decorator会报错： 1对修饰器的实验支持是一项将在将来版本中更改的功能。设置 "experimentalDecorators" 选项以删除此警告 这个错误来自与vscode的JS support，只要在项目根目录下创建一个jsconfig.json文件，添加如下内容：12345&#123; "compilerOptions": &#123; "experimentalDecorators": true &#125;&#125; 添加好了有可能需要重启才能生效。 css 相关vscode 使用 postcss 语法并且对其支持emmet安装postcss-sugar-language插件。将css文件视作postcss（为了方便.css文件使用postcss语法不被报错），以及让emmet支持postcss文件。在settings中的配置：12345678"files.associations": &#123; "*.css": "postcss"&#125;,"emmet.includeLanguages": &#123; "vue-html": "html", "javascript": "javascriptreact", "postcss": "css"&#125;, vue 相关使用vscode，新建vue模板文件 –&gt; 首选项 –&gt; 用户代码片段 –&gt; 输入vue，选择vue –&gt;复制 以下内容保存：123456789101112131415161718192021222324&#123; "Print to console": &#123; "prefix": "vue", "body": [ "&lt;template&gt;", " &lt;div class=\"\"&gt;\n", " &lt;/div&gt;", "&lt;/template&gt;\n", "&lt;script type=\"text/ecmascript-6\"&gt;", "export default &#123;", " name: '',", " data() &#123;", " return &#123;&#125;", " &#125;,", " components: &#123;&#125;", "&#125;", "&lt;/script&gt;\n", "&lt;style scoped lang=\"stylus\"&gt;", "&lt;/style&gt;", "$2" ], "description": "Log output to console" &#125;&#125; 新建vue文件，输入vue，按下tab键即可。]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM依赖包版本号~和^的区别及最佳实践]]></title>
    <url>%2F2018%2F05%2F01%2Fnpm-package-version.html</url>
    <content type="text"><![CDATA[我们经常发现项目的依赖包版本号前面有的是 ~，有的是 ^，我们以 angular 为例： 那么 ~ 和 ^ 有什么作用和区别？ ~：匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0。 ^：匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0。 实际项目中我们该如何选择呢？ 固定版本：首先我们可以指定特定的版本号，直接写1.2.3，前面什么前缀都没有，这样固然没问题，但是如果依赖包发布新版本修复了一些小bug，那么需要手动修改package.json文件。^版本：^版本虽然不需要手动修改package.json文件就可享用修复后的依赖包，但^版本之间跨越比较大，更甚至有些高版本于低版本不兼容。~版本：^版本不仅不需要手动修改package.json文件，也不像^版本之间跨越比较大，这样可以保证项目不会出现大的问题，也能保证包中的小bug可以得到修复。*版本：*版本意味着时刻安装最新版本的依赖包，缺点同^版本，可能会造成版本不兼容。 综上所述，实际项目中我们推荐用 ~ 版本。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟dom]]></title>
    <url>%2F2018%2F04%2F30%2Fvirtual-dom.html</url>
    <content type="text"></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>virtual dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 开发汇总]]></title>
    <url>%2F2018%2F04%2F28%2Fnodejs-tutorial.html</url>
    <content type="text"><![CDATA[前言什么是NodeJS？JavaScript是一门脚本语言，它需要一个运行环境。就好像PHP需要Apache，Java需要Tomcat等等，而NodeJS之前，JavaScript运行环境是浏览器，也就是JavaScript在网页中才能跑起来。NodeJS之后JavaScript又多了一个运行环境，就是NodeJS。NodeJS 是基于Chrome V8引擎的 JavaScript 运行环境。NodeJS使用事件驱动，非阻塞型I/O。NodeJS的包管理生态是 NPM，是现在世界上最大的开源程序包库。由于NodeJS的最底层是Chrome的V8引擎，然后libuv封装了一些I/O的线程池管理和网络的I/O操作，这部分是C/C++写的。简单来说NodeJS可以控制系统文件的读写，网络的输入输出，所以NodeJS又可以被单纯的认为是一个可以运行 JavaScript 的服务器。 NodeJS和VueJS，ReactJS，还有AngularJS的区别这些工具的起源和诞生几乎浓缩了前端的发展历程，因为 NodeJS 可以读写文件，监听网络输入输出，所以 NodeJS 和 VueJS、ReactJS、AngularJS 有非常本质的区别。NodeJS 是可以运行 JavaScript 的环境，剩下三个是用 JavaScript 写的库。 一般NodeJS被用在哪里？至于纯前端，大多用于辅助开发。我们所用的vue-cli等脚手架，或者webpack，gulp，grunt等构建工具都是用node写得。它为我们提升效率、打包、构建、维护等。 NodeJS 还能做啥？用JS做服务器： Express / EggJS / HAPI / Koa 等。 用JS做移动端混合应用：PhoneGap / Cordova / Ionic 等。 用JS做移动端原生应用：React-Native / NativeScript / WEEX 等。 常见用法Node.js —— 实现修改完代码自动重启nodemon使用第三方命令行工具解决频繁修改代码重启服务器问题：nodemon。nodemon是一个基于Node.js开发的第三方命令行工具。 全局安装nodemon：1$ npm install -g nodemon 使用：把输入cmd的node改为nodemon，比如node app.js改为ndoemon app.js。只要是通过nodemon启动的服务，它会监视文件变化，当文件发生变化时会自动重启服务器。 module.filename、filename、dirname、process.cwd()和require.main.filename 解惑module.filename：开发期间，该行代码所在的文件。__filename：始终等于 module.filename。__dirname：开发期间，该行代码所在的目录。process.cwd()：运行node的工作目录，可以使用 cd /d 修改工作目录。require.main.filename：用node命令启动的module的filename, 如 node xxx，这里的filename就是这个xxx。 require()方法的坐标路径是：module.filename；fs.readFile()的坐标路径是：process.cwd()。 常见问题bash: /usr/local/bin: Permission denied原因：数据权限问题 解决办法：123$ sudo chmod 755 /usr/local/bin$ sudo chmod -R 755 /usr/local/bin # 递归下面 Node.js 连接MySQL时 出现 connect ECONNREFUSED 127.0.0.1:3306原因：数据库服务没有打开。 解决办法：开启 MySQL服务。 nodemon 不断重启解决办法：以管理员身份打开命令行执行命令，如果没有帮助，重启电脑。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 组件间通信方式]]></title>
    <url>%2F2018%2F04%2F25%2Fvue-component-communication.html</url>
    <content type="text"><![CDATA[Vue 组件通信包括：父子组件和兄弟组件间的通信。在组件化系统构建中，组件间通信必不可少的。 父组件向子组件通信props父组件核心传递数据代码如下：123456789101112131415161718&lt;template&gt; &lt;child :msg="message"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from './child.vue';export default &#123; components: &#123; child &#125;, data () &#123; return &#123; message: 'I am Father！' &#125; &#125;&#125;&lt;/script&gt; 子组件核心接收数据代码如下：1234567891011121314&lt;template&gt; &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; msg: &#123; type: String, required: true &#125; &#125;&#125;&lt;/script&gt; msg 为父组件给子组件设置的额外属性值，属性值需在子组件中设置 props，子组件中可直接使用 msg 变量。 实例方法父组件通过 $children 可以访问所有直接子组件（父组件的子组件的子组件不是直接子组件）。注意 $children 并不保证顺序，也不是响应式的。 子组件向父组件通信事件子组件核心传递数据代码如下：12345678910111213141516171819&lt;template&gt; &lt;button @click="handleClick"&gt;传递数据&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; msg: &#123; type: String, required: true &#125; &#125;, methods () &#123; handleClick () &#123; this.$emit("sonMsg", "I am Son！"); &#125; &#125;&#125;&lt;/script&gt; 父组件核心接收数据代码如下：123456789101112131415161718&lt;template&gt; &lt;child @sonMsg="getSonMsg"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from './child.vue';export default &#123; components: &#123; child &#125;, methods: &#123; getSonMsg (msg) &#123; console.log(msg); // I am Son！ &#125; &#125;&#125;&lt;/script&gt; 父组件向子组件传递事件方法，子组件通过 $emit 触发事件，回调给父组件。sonMsg 为子组件触发的事件名称，父组件中 @sonMsg 为向子组件传递的事件名称，getSonMsg 为父组件事件回调方法。 ref设置子组件 ref 属性的值，比如：12&lt;!-- 子组件。 ref的值是组件引用的名称 --&gt;&lt;child-component ref="aName"&gt;&lt;/child-component&gt; 父组件中通过$refs.组件名来获得子组件，也就可以调用子组件的属性和方法了。123const child = this.$refs.aNamechild.属性child.方法() 实例方法子组件通过 $parent 访问父组件。 Bus中央通信目前中央通信是解决兄弟间通信，祖父祖孙间通信的最佳方法，不仅限于此，也可以解决父组件子组件间的相互通信。如下图（盗图）： 各组件可自己定义好组件内接收外部组件的消息事件即可，不用理会是哪个组件发过来；而对于发送事件的组件，亦不用理会这个事件到底怎么发送给我需要发送的组件。 先设置Bus：123// bus.js import Vue from 'vue'export default new Vue(); 发送事件的组件：123import bus from '@/bus';// 方法内执行下面动作bus.$emit('child-message', this.data); 组件内监听事件：123456789101112import bus from '@/bus';export default &#123; name: 'child', methods: &#123; &#125;, created() &#123; bus.$on('child-message', function(data) &#123; console.log('I get it'); &#125;); &#125;&#125;; Bus中央通信的方案各种情况下都可用，比较方便。 复杂的单页应用数据管理当应用足够复杂情况下，我们要使用vuex进行数据管理。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块加载机制详解]]></title>
    <url>%2F2018%2F04%2F22%2Fmodule-loading.html</url>
    <content type="text"><![CDATA[require方式的加载模块模块定义上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个moudle对象，它代表模块自身，而exports是moudle的属性。在NodeJS中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出方式。每个 node 进程只有一个 VM 的上下文, 不会跟浏览器相差多少, 模块机制在文档中也描述的非常清楚了:1234567891011121314function require(...) &#123; var module = &#123; exports: &#123;&#125; &#125;; ((module, exports) =&gt; &#123; // Your module code here. In this example, define a function. function some_func() &#123;&#125;; exports = some_func; // At this point, exports is no longer a shortcut to module.exports, and // this module will still export an empty default object. module.exports = some_func; // At this point, the module will now export some_func, instead of the // default object. &#125;)(module, module.exports); return module.exports;&#125; 每个单独的 .js 文件并不意味着单独的上下文, 在某个 .js 文件中污染了全局的作用域一样能影响到其他的地方。 模块的类型和导入过程在NodeJS中引入模块，需要经历如下3个步骤：（1）路径分析（2）扩展名分析（3）编译执行模块主要分为两类：核心模块和文件模块 核心模块：Node提供的模块，已经是编译后二进制文件，部分核心模块直接加载进内存，在步骤1中优先执行，且2、3可省略，所以它的加载速度最快 文件模块：用户编写的模块，运行时动态加载，需要1，2，3完整的过程，速度比核心模块慢优先从缓存加载 Node引入过的模块都会进行缓存，而且缓存的是编译和执行之后的对象。无论是核心模块还是文件模块，require的方式对相同模块的二次加载都一律采用缓存优先的方式。 且核心模块的缓存检查优先于文件模块的缓存检查。 优先级：缓存加载 &gt; 核心模块 &gt; 路径形式文件模块 &gt; 自定义文件模块 路径分析其中文件模块还包括路径形式文件模块（如.、..和./开头的标识符）和自定义文件模块（第三方npm包）。 自定义文件模块的查找最耗时也是最慢的一种，查找顺序为： 当前目录下node_modules目录父目录下node_modules目录向上逐级递归直到根目录下下node_modules目录类似于JS的原型链查找，文件路径越深，模块查找越耗时，这就是它慢的原因 扩展名分析不加扩展名的时候，会按.js、.json、.node的次序补足扩展名，依次尝试。 在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。 因为node单线程特性，为了提高一定的性能问题，有两个解决方案： (1) 加扩展名(2) 同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷 文件定位（路径+扩展名分析）过程小结require有可能通过文件扩展名之后没有找到对应的文件，但会得到一个目录，Node会将此目录当做一个包处理。 Node也一定程度上遵循了CommonJS规范，过程如下： Node会在当前目录下查找package.json文件（JSON.parse解析），查找main字段指定的文件第一步不成功则会一次查找index.js、index.json、index.node遍历下一个模块路径还是没有则抛出查找失败的异常。 思考如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111 能否在 a 中直接打印出来?a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?既然可以通过新的上下文来避免污染, 那么为什么 Node.js 不给每一个.js文件以独立的上下文来避免作用域被污染?]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨页面通信的几种方法]]></title>
    <url>%2F2018%2F04%2F20%2Fwindows-communication.html</url>
    <content type="text"><![CDATA[localStorage通过监听window对象的“onstorage”事件，其他窗口获取到本窗口发送的消息，注意，必须是同一款浏览器，并且在同一个域名下。 发送消息页面：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Page A&lt;/title&gt; &lt;script&gt; function setTime() &#123; localStorage.setItem('currentTime', (new Date()).getTime()); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button onClick="setTime()"&gt;设置时间&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 接收消息页面：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Page B&lt;/title&gt;&lt;/head&gt;&lt;script&gt; document.addEventListener('DOMContentLoaded', function() &#123; document.getElementById('message').innerText = localStorage.getItem('currentTime') || '暂无数据'; /*当存储空间中数据发生变化的时候*/ window.onstorage = function(ev) &#123; /*获取正在变化的数据*/ document.getElementById('message').innerText = localStorage.getItem(ev.key) || '暂无数据'; &#125;; &#125;, false);&lt;/script&gt; &lt;body&gt; &lt;div id="message"&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 注意：onload：当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。DOMContentLoaded：当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。开发中我们经常需要给一些元素的事件绑定处理函数，将绑定的函数放在这两个事件的回调中，保证能在页面的某些元素加载完毕之后再绑定事件的函数。相比之下 DOMContentLoaded 机制更加合理，因为我们可以容忍图片，flash延迟加载，却不可以容忍看见内容后页面不可交互。 Window.postMessage()定义window.postMessage 是 HTML5 引入的API，postMessage() 方法允许来自不同源的脚本采用异步方式进行有效的通信，可以实现跨文本文档，多窗口，跨域消息传递。多用于窗口间数据通信，这也使它成为跨域通信的一种有效的解决方案。 postMessage发送消息在需要发送消息的源窗口调用 postMessage 方法即可发送消息。 源窗口源窗口可以是全局的window对象，也可以是以下类型的窗口:文档窗口中的iframe：12var iframe = document.getElementById('my-iframe');var win = iframe.documentWindow; JavaScript打开的弹窗：1var win = window.open(); 当前文档窗口的父窗口：1var win = window.parent; 打开当前文档的窗口：1var win = window.opener(); 找到源window对象后，即可调用postMessage API向目标窗口发送消息：1win.postMessage('Hello', 'ttp://jhssdemo.duapp.com/'); postMessage函数接收两个参数：第一个为将要发送的消息，第二个为源窗口的源。 注：只有当目标窗口的源与postMessage函数中传入的源参数值匹配时，才能接收到消息。 接收postMessage消息要想接收到之前源窗口通过postMessage发出的消息，只需要在目标窗口注册message事件并绑定事件监听函数，就可以在函数参数中获取消息。123456789101112131415161718window.onload = function() &#123; var text = document.getElementById('txt'); function receiveMsg(e) &#123; console.log("Got a message!"); console.log("nMessage: " + e.data); console.log("nOrigin: " + e.origin); // console.log("Source: " + e.source); text.innerHTML = "Got a message!&lt;br&gt;" + "Message: " + e.data + "&lt;br&gt;Origin: " + e.origin; &#125; if (window.addEventListener) &#123; //为窗口注册message事件，并绑定监听函数 window.addEventListener('message', receiveMsg, false); &#125;else &#123; window.attachEvent('message', receiveMsg); &#125;&#125;; message事件监听函数接收一个参数，Event对象实例，该对象有三个属性：data；发送的具体消息。origin：发送消息源。source：发送消息窗口的window对象引用。 说明1、可以将postMessage函数第二个参数设为*，在发送跨域消息时会跳过对发送消息的源的检查。2、postMessage只能发送字符串信息。 实例源窗口：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Html5 postMessage&lt;/title&gt; &lt;style&gt; #otherWin &#123; width: 600px; height: 400px; background-color: #cccccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="btn"&gt;open&lt;/button&gt; &lt;button id="send"&gt;send&lt;/button&gt; &lt;!-- 通过 iframe 嵌入子页面(接收消息目标窗口) --&gt; &lt;iframe id="otherWin" src="http://localhost:8080/b.html"&gt;&lt;/iframe&gt; &lt;br/&gt; &lt;br/&gt; &lt;input type="text" id="message" /&gt; &lt;input type="button" value="Send to child.com" id="sendMessage" /&gt; &lt;script&gt; window.onload = function() &#123; var btn = document.getElementById('btn'); var btn_send = document.getElementById('send'); var sendBtn = document.getElementById('sendMessage'); var win; btn.onclick = function() &#123; //通过window.open打开接收消息目标窗口 win = window.open('http://localhost:8080/b.html', 'popUp'); &#125; btn_send.onclick = function() &#123; // 通过 postMessage 向子窗口发送数据 win.postMessage('Hello', 'http://localhost:8080/'); &#125; function sendIt(e)&#123; // 通过 postMessage 向子窗口发送数据 document.getElementById("otherWin").contentWindow .postMessage( document.getElementById("message").value, "http://localhost:8080/"); &#125; sendBtn.onclick = function(e) &#123; sendIt(e); &#125;; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 目标窗口：1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Html5 postMessage&lt;/title&gt; &lt;style&gt; #txt &#123; width: 500px; height: 300px; background-color: #cccccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;The New Window&lt;/h1&gt; &lt;div id="txt"&gt;&lt;/div&gt; &lt;script&gt; window.onload = function() &#123; var text = document.getElementById('txt'); //监听函数，接收一个参数--Event事件对象 function receiveMsg(e) &#123; console.log("Got a message!"); console.log("nMessage: " + e.data); console.log("nOrigin: " + e.origin); text.innerHTML = "Got a message!&lt;br&gt;" + "Message: " + e.data + "&lt;br&gt;Origin: " + e.origin; &#125; if (window.addEventListener) &#123; //为window注册message事件并绑定监听函数 window.addEventListener('message', receiveMsg, false); &#125;else &#123; window.attachEvent('message', receiveMsg); &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; WebSocket所有的WebSocket都监听同一个服务器地址，利用send发送消息，利用onmessage获取消息的变化，不仅能窗口，还能跨浏览器，兼容性最佳，只是需要消耗点服务器资源。123456789var ws = new WebSocket("ws://www.example.com/socketserver");ws.onopen = function (event) &#123; // 或者把此方法注册到其他事件中，即可与其他服务器通信 ws.send(&#123;username : 'yiifaa', now : Date.now()&#125;); // 通过服务器中转消息&#125;;ws.onmessage = function (event) &#123; // 消费消息 console.log(event.data);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F04%2F19%2Fdesign-pattern-tutorial.html</url>
    <content type="text"><![CDATA[设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。设计模式是一种思想，常见的生活例子如：盖房子的设计图纸，古代战争的孙子兵法。设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式的目的： 设计模式是优秀的使用案例，使用设计模式可提高代码的重用性、让代码更容易被他人理解、保证代码可靠性。 java基本模式有23种：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式….，下面分别介绍一下设计模式： 单例模式Singleton保证整个应用中某个实例有且只有一个。常见的生活例子有：古代皇帝有且只有一个、中国的一妻一夫制… 开发中，有些对象我们只需要一个，比如：配置文件、工具类、线程池、缓存、日志对象等，如果创造出多个实例，就会导致许多问题，比如占用过多资源，不一致的结果等。 应用场合：有些对象只需要一个就足够了，如古代皇帝、老婆作用：保证整个应用程序中某个实例有且只有一个类型：饿汉模式、懒汉模式 单例模式的饿汉式实现单例类：1234567891011121314151617package com.sosout;/*** 饿汉模式*/public class Singleton &#123; // 1、将构造方法私有化，不允许外部直接创建对象 private Singleton() &#123; &#125; // 2、创建类的唯一实例，使用private static修饰 private static Singleton instance = new Singleton(); // 3、提供一个用于获取实例的方法，使用public static 修饰 public static Singleton getInstance() &#123; return instance; &#125;&#125; 测试类：123456789101112package com.sosout;public class Test &#123; public static void main(String[] args) &#123; Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); if (s1 == s2) &#123; System.out.println("s1和s2是同一个实例"); &#125; else &#123; System.out.println("s1和s2不是同一个实例"); &#125; &#125;&#125; 单例模式的懒汉式实现单例类：1234567891011121314151617181920package com.sosout;/*** 懒汉模式*/public class Singleton2 &#123; // 1、将构造方法私有化，不允许外部直接创建对象 private Singleton2() &#123; &#125; // 2、创建类的唯一实例，使用private static修饰 private static Singleton2 instance; // 3、提供一个用于获取实例的方法，使用public static 修饰 public static Singleton2 getInstance() &#123; if (instance == null) &#123; instance = new Singleton2(); &#125; return instance; &#125;&#125; 测试类：12345678910111213141516171819202122package com.sosout;public class Test &#123; public static void main(String[] args) &#123; // 饿汉模式 Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); if (s1 == s2) &#123; System.out.println("s1和s2是同一个实例"); &#125; else &#123; System.out.println("s1和s2不是同一个实例"); &#125; // 懒汉模式 Singleton2 s3 = Singleton2.getInstance(); Singleton2 s4 = Singleton2.getInstance(); if (s3 == s4) &#123; System.out.println("s3和s4是同一个实例"); &#125; else &#123; System.out.println("s3和s4不是同一个实例"); &#125; &#125;&#125; 饿汉模式和懒汉模式区别饿汉模式的特点是加载类时比较慢，但运行时获取对象的速度比较快，线程安全的，懒汉模式的特点是加载类时比较快，但运行时获取对象的速度比较慢，线程不安全的。 在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。 在JavaScript里，实现单例的方式有很多种，其中最简单的一个方式是使用对象字面量的方法，其字面量里可以包含大量的属性和方法：1234567var mySingleton = &#123; property1: "something", property2: "something else", method1: function () &#123; console.log('hello world'); &#125;&#125;; 如果以后要扩展该对象，你可以添加自己的私有成员和方法，然后使用闭包在其内部封装这些变量和函数声明。只暴露你想暴露的public成员和方法，样例代码如下：1234567891011121314151617181920var mySingleton = function () &#123; /* 这里声明私有变量和方法 */ var privateVariable = 'something private'; function showPrivate() &#123; console.log(privateVariable); &#125; /* 公有变量和方法（可以访问私有变量和方法） */ return &#123; publicMethod: function () &#123; showPrivate(); &#125;, publicVar: 'the public can see this!' &#125;;&#125;;var single = mySingleton();single.publicMethod(); // 输出 'something private'console.log(single.publicVar); // 输出 'the public can see this!' 上面的代码很不错了，但如果我们想做到只有在使用的时候才初始化，那该如何做呢？为了节约资源的目的，我们可以另外一个构造函数里来初始化这些代码，如下：123456789101112131415161718192021222324var Singleton = (function () &#123; var instantiated; function init() &#123; /*这里定义单例代码*/ return &#123; publicMethod: function () &#123; console.log('hello world'); &#125;, publicProperty: 'test' &#125;; &#125; return &#123; getInstance: function () &#123; if (!instantiated) &#123; instantiated = init(); &#125; return instantiated; &#125; &#125;;&#125;)();/*调用公有的方法来获取实例:*/Singleton.getInstance().publicMethod(); 工厂模式什么是工厂模式？实例化对象，用工厂方法代替new操作。工厂模式包括工厂方法模式和抽象工厂模式。抽象工厂模式是工厂方法模式的扩展。 策略模式定义定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 优点1、策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句。2、策略模式提供了开放-封闭原则，使代码更容易理解和扩展。3、策略模式中的代码可以复用。 示例：使用策略模式计算奖金比如公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍；现在我们使用一般的编码方式会如下这样编写代码： 一般方式1234567891011121314var calculateBouns = function(salary,level) &#123; if(level === 'A') &#123; return salary * 4; &#125; if(level === 'B') &#123; return salary * 3; &#125; if(level === 'C') &#123; return salary * 2; &#125;&#125;;// 调用如下：console.log(calculateBouns(4000,'A')); // 16000console.log(calculateBouns(2500,'B')); // 7500 第一个参数为薪资，第二个参数为等级；代码缺点如下：1、calculateBouns 函数包含了很多if-else语句。2、calculateBouns 函数缺乏弹性，假如还有D等级的话，那么我们需要在calculateBouns 函数内添加判断等级D的if语句；3、算法复用性差，如果在其他的地方也有类似这样的算法的话，但是规则不一样，我们这些代码不能通用。 组合函数组合函数是把各种算法封装到一个个的小函数里面，比如等级A的话，封装一个小函数，等级为B的话，也封装一个小函数，以此类推；如下代码：1234567891011121314151617181920212223var performanceA = function(salary) &#123; return salary * 4;&#125;;var performanceB = function(salary) &#123; return salary * 3;&#125;; var performanceC = function(salary) &#123; return salary * 2;&#125;;var calculateBouns = function(level,salary) &#123; if(level === 'A') &#123; return performanceA(salary); &#125; if(level === 'B') &#123; return performanceB(salary); &#125; if(level === 'C') &#123; return performanceC(salary); &#125;&#125;;// 调用如下console.log(calculateBouns('A',4500)); // 18000 代码看起来有点改善，但是还是有如下缺点：calculateBouns 函数有可能会越来越大，比如增加D等级的时候，而且缺乏弹性。 策略模式传统面向对象策略模式指的是 定义一系列的算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，实际就是将算法的使用和实现分离出来；算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数，而算法的实现是根据绩效对应不同的绩效规则；一个基于策略模式的程序至少由2部分组成，第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，该Context接收客户端的请求，随后把请求委托给某一个策略类。我们先使用传统面向对象来实现；如下代码：12345678910111213141516171819202122232425262728293031323334353637var performanceA = function()&#123;&#125;;performanceA.prototype.calculate = function(salary) &#123; return salary * 4;&#125;; var performanceB = function()&#123;&#125;;performanceB.prototype.calculate = function(salary) &#123; return salary * 3;&#125;;var performanceC = function()&#123;&#125;;performanceC.prototype.calculate = function(salary) &#123; return salary * 2;&#125;;// 奖金类var Bouns = function()&#123; this.salary = null; // 原始工资 this.levelObj = null; // 绩效等级对应的策略对象&#125;;Bouns.prototype.setSalary = function(salary) &#123; this.salary = salary; // 保存员工的原始工资&#125;;Bouns.prototype.setlevelObj = function(levelObj)&#123; this.levelObj = levelObj; // 设置员工绩效等级对应的策略对象&#125;;// 取得奖金数Bouns.prototype.getBouns = function()&#123; // 把计算奖金的操作委托给对应的策略对象 return this.levelObj.calculate(this.salary);&#125;;var bouns = new Bouns();bouns.setSalary(10000);bouns.setlevelObj(new performanceA()); // 设置策略对象console.log(bouns.getBouns()); // 40000 bouns.setlevelObj(new performanceB()); // 设置策略对象console.log(bouns.getBouns()); // 30000 如上代码使用策略模式重构代码，可以看到代码职责更新分明，代码变得更加清晰。 Javascript代码如下：123456789101112131415var obj = &#123; "A": function(salary) &#123; return salary * 4; &#125;, "B": function(salary) &#123; return salary * 3; &#125;, "C": function(salary) &#123; return salary * 2; &#125; &#125;;var calculateBouns =function(level,salary) &#123; return obj[level](salary);&#125;;console.log(calculateBouns('A',10000)); // 40000 可以看到代码更加简单明了；策略模式指的是定义一系列的算法，并且把它们封装起来，但是策略模式不仅仅只封装算法，我们还可以对用来封装一系列的业务规则，只要这些业务规则目标一致，我们就可以使用策略模式来封装它们； 示例：使用策略模式进行表单校验我们经常来进行表单验证，比如注册登录对话框，我们登录之前要进行验证操作：1、用户名不能为空。2、密码长度不能小于6位。3、手机号码必须符合格式。。。。 比如HTML代码如下：1234567891011121314&lt;form action = "http://www.baidu.com" id="registerForm" method = "post"&gt; &lt;p&gt; &lt;label&gt;请输入用户名：&lt;/label&gt; &lt;input type="text" name="userName"/&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;请输入密码：&lt;/label&gt; &lt;input type="text" name="password"/&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;请输入手机号码：&lt;/label&gt; &lt;input type="text" name="phoneNumber"/&gt; &lt;/p&gt;&lt;/form&gt; 一般方式我们正常的编写表单验证代码如下：123456789101112131415var registerForm = document.getElementById("registerForm");registerForm.onsubmit = function()&#123; if(registerForm.userName.value === '') &#123; alert('用户名不能为空'); return; &#125; if(registerForm.password.value.length &lt; 6) &#123; alert("密码的长度不能小于6位"); return; &#125; if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123; alert("手机号码格式不正确"); return; &#125;&#125; 但是这样编写代码有如下缺点：1、registerForm.onsubmit 函数比较大，代码中包含了很多if语句；2、registerForm.onsubmit 函数缺乏弹性，如果增加了一种新的效验规则，或者想把密码的长度效验从6改成8，我们必须改registerForm.onsubmit 函数内部的代码。违反了开放-封闭原则。3、算法的复用性差，如果在程序中增加了另外一个表单，这个表单也需要进行一些类似的效验，那么我们可能又需要复制代码了； 策略模式第一步我们先来封装策略对象，如下代码：12345678910111213141516171819var strategy = &#123; isNotEmpty: function(value,errorMsg) &#123; if(value === '') &#123; return errorMsg; &#125; &#125;, // 限制最小长度 minLength: function(value,length,errorMsg) &#123; if(value.length &lt; length) &#123; return errorMsg; &#125; &#125;, // 手机号码格式 mobileFormat: function(value,errorMsg) &#123; if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125; &#125;; 接下来我们准备实现Validator类，Validator类在这里作为Context，负责接收用户的请求并委托给strategy 对象，如下代码：123456789101112131415161718192021var Validator = function()&#123; this.cache = []; // 保存效验规则&#125;;Validator.prototype.add = function(dom,rule,errorMsg) &#123; var str = rule.split(":"); this.cache.push(function()&#123; // str 返回的是 minLength:6 var strategy = str.shift(); str.unshift(dom.value); // 把input的value添加进参数列表 str.push(errorMsg); // 把errorMsg添加进参数列表 return strategys[strategy].apply(dom,str); &#125;);&#125;;Validator.prototype.start = function()&#123; for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123; var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息 if(msg) &#123; return msg; &#125; &#125;&#125;; Validator类在这里作为Context，负责接收用户的请求并委托给strategys对象。上面的代码中，我们先创建一个Validator对象，然后通过validator.add方法往validator对象中添加一些效验规则，validator.add方法接收3个参数，如下代码：validator.add(registerForm.password,’minLength:6’,’密码长度不能小于6位’)registerForm.password：校验的input输入框dom节点；minLength:6：是以一个冒号隔开的字符串，冒号前面的minLength代表客户挑选的strategys对象，冒号后面的数字6表示在效验过程中所必须验证的参数，minLength:6的意思是效验 registerForm.password 这个文本输入框的value最小长度为6位；如果字符串中不包含冒号，说明效验过程中不需要额外的效验信息；第三个参数：当效验未通过时返回的错误信息； 当我们往validator对象里添加完一系列的效验规则之后，会调用validator.start()方法来启动效验。如果validator.start()返回了一个errorMsg字符串作为返回值，说明该次效验没有通过，此时需要registerForm.onsubmit方法返回false来阻止表单提交。下面我们来看看初始化代码如下：123456789101112131415161718var validateFunc = function()&#123; var validator = new Validator(); // 创建一个Validator对象 /* 添加一些效验规则 */ validator.add(registerForm.userName,'isNotEmpty','用户名不能为空'); validator.add(registerForm.password,'minLength:6','密码长度不能小于6位'); validator.add(registerForm.userName,'mobileFormat','手机号码格式不正确'); var errorMsg = validator.start(); // 获得效验结果 return errorMsg; // 返回效验结果&#125;;var registerForm = document.getElementById("registerForm");registerForm.onsubmit = function()&#123; var errorMsg = validateFunc(); if(errorMsg)&#123; alert(errorMsg); return false; &#125;&#125; 下面是所有的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var strategys = &#123; isNotEmpty: function(value,errorMsg) &#123; if(value === '') &#123; return errorMsg; &#125; &#125;, // 限制最小长度 minLength: function(value,length,errorMsg) &#123; if(value.length &lt; length) &#123; return errorMsg; &#125; &#125;, // 手机号码格式 mobileFormat: function(value,errorMsg) &#123; if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125; &#125;;var Validator = function()&#123; this.cache = []; // 保存效验规则&#125;;Validator.prototype.add = function(dom,rule,errorMsg) &#123; var str = rule.split(":"); this.cache.push(function()&#123; // str 返回的是 minLength:6 var strategy = str.shift(); str.unshift(dom.value); // 把input的value添加进参数列表 str.push(errorMsg); // 把errorMsg添加进参数列表 return strategys[strategy].apply(dom,str); &#125;);&#125;;Validator.prototype.start = function()&#123; for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123; var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息 if(msg) &#123; return msg; &#125; &#125;&#125;;var validateFunc = function()&#123; var validator = new Validator(); // 创建一个Validator对象 /* 添加一些效验规则 */ validator.add(registerForm.userName,'isNotEmpty','用户名不能为空'); validator.add(registerForm.password,'minLength:6','密码长度不能小于6位'); validator.add(registerForm.userName,'mobileFormat','手机号码格式不正确'); var errorMsg = validator.start(); // 获得效验结果 return errorMsg; // 返回效验结果&#125;;var registerForm = document.getElementById("registerForm");registerForm.onsubmit = function()&#123; var errorMsg = validateFunc(); if(errorMsg)&#123; alert(errorMsg); return false; &#125;&#125;;]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2018%2F04%2F18%2Fdata-structure-and-algorithm.html</url>
    <content type="text"><![CDATA[数组数组的标准定义是：一个存储元素的线性集合（collection），元素可以通过索引来任意存取，索引通常是数字，用来计算元素之间存储位置的偏移量。几乎所有的编程语言都有类似的数据结构。然而 JavaScript 的数组却略有不同。JavaScript 中的数组是一种特殊的对象，用来表示偏移量的索引是该对象的属性，索引可能是整数。然而，这些数字索引在内部被转换为字符串类型，这是因为 JavaScript 对象中的属性名必须是字符串。数组在 JavaScript 中只是一种特殊的对象，所以效率上不如其他语言中的数组高。JavaScript 中的数组，严格来说应该称作对象，是特殊的 JavaScript 对象，在内部被归类为数组。由于 Array 在 JavaScript 中被当作对象，因此它有许多属性和方法可以在编程时使用。 双向链表双向链表属于链表的一种，也叫双链表，双向即是说它的链接方向是双向的，它由若干个节点组成，每个节点都包含下一个节点和上一个节点的指针，所以从双向链表的任意节点开始，都能很方便访问它的前驱结点和后继节点。 特点1、创建双链表时无需指定链表的长度。2、比起单链表，双链表需要多一个指针用于指向前驱节点，所以需要存储空间比单链表多一点。3、双链表的插入和删除需要同时维护 next 和 prev 两个指针。4、双链表中的元素访问需要通过顺序访问，即要通过遍历的方式来寻找元素。 执行过程图解创建创建一个空链表： 插入链尾将the monster is coming这些单词按顺序分别插入尾部，创建“the”节点： 连接起来： 创建“monster”节点： 再连接起来： 以此类推，将剩下的节点全部创建并连接起来： 创建迭代器迭代器的 current 指针初始指向head： 执行两次 next 操作， current 指针指向索引为2的节点： 此时的节点值为： 设置 current 指针指向索引为3的节点： 插入节点在索引1后面插入“big”节点。先将 current 指针指向索引为1的节点，创建一个”big”新节点： 插入到 current 指向位置： 删除节点将“big”节点删除，移动当前指针 current 到“big”节点位置： 执行删除操作，断掉“big”节点与前后两节点的 next 和 prev 指针，然后将“the”节点与“monster”节点关联起来： 双向循环链表前面的双向链表的 head 节点和链尾没有连接关系，所以如果要访问最后一个节点的话需要从头开始遍历，直到最后一个节点。在双向链表基础上改进一下，把 header 节点的 prev 指针指向最后一个节点，而最后一个节点的 next 指针指向 header 节点，于是便构成双向循环链表。 实现细节我们的链表将包括两个构造函数：Node 和 DoublyList。看看它们是怎样运作的。 Nodedata：存储数据。next：指向链表中下一个节点的指针。previous：指向链表中前一个节点的指针。 DoublyList_length：保存链表中节点的个数。head：指定一个节点作为链表的头节点。head：tail 指定一个节点作为链表的尾节点。add(value)：向链表中添加一个节点。searchNodeAt(position)：找到在列表中指定位置 n 上的节点。remove(position)：删除链表中指定位置上的节点。 节点模板在实现中，将会创建一个名为Node的构造函数：12345function Node(value) &#123; this.data = value; this.previous = null; this.next = null;&#125; 想要实现双向链表的双向遍历，我们需要指向链表两个方向的属性。这些属性被命名为previous和next。 接下来，我们需要实现DoublyList并添加三个属性：_length，head和tail。与单链表不同，双向链表包含对链表开头和结尾节点的引用。 由于DoublyList刚被实例化时并不包含任何节点，所以head和tail的默认值都被设置为null。12345function DoublyList() &#123; this._length = 0; this.head = null; this.tail = null;&#125; 操作节点接下来我们讨论以下方法：add(value)，remove(position)和searchNodeAt(position)。所有这些方法都用于单链表，然而，它们必须被重写为可以双向遍历。 方法1/3 add(value)12345678910111213141516DoublyList.prototype.add = function(value) &#123; var node = new Node(value); if (this._length) &#123; this.tail.next = node; node.previous = this.tail; this.tail = node; &#125; else &#123; this.head = node; this.tail = node; &#125; this._length++; return node;&#125;; 在这个方法中，存在两种可能。首先，如果链表是空的，则给它的head和tail分配节点。其次，如果链表中已经存在节点，则查找链表的尾部并把新节点分配给tail.next；同样，我们需要配置新的尾部以供进行双向遍历。换句话说，我们需要把tail.previous设置为原来的尾部。 方法2/3: searchNodeAt(position)创建一个名为searchNodeAt(position)的方法，它接受一个名为position的参数。这个参数是个整数，用来表示链表中的位置n。12345678910111213141516171819DoublyList.prototype.searchNodeAt = function(position) &#123; var currentNode = this.head, length = this._length, count = 1, message = &#123;failure: 'Failure: non-existent node in this list.'&#125;; // 1st use-case: an invalid position if (length === 0 || position &lt; 1 || position &gt; length) &#123; throw new Error(message.failure); &#125; // 2nd use-case: a valid position while (count &lt; position) &#123; currentNode = currentNode.next; count++; &#125; return currentNode;&#125;; 在if中检查第一种情况：参数非法。如果传给searchNodeAt(position)的索引是有效的，那么我们执行第二种情况 —— while循环。 在while的每次循环中，指向头的currentNode被重新指向链表中的下一个节点。这个循环不断执行，一直到count等于position。 方法3/3: remove(position)理解这个方法是最具挑战性的。我先写出代码，然后再解释它。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950DoublyList.prototype.remove = function(position) &#123; var currentNode = this.head, length = this._length, count = 1, message = &#123;failure: 'Failure: non-existent node in this list.'&#125;, beforeNodeToDelete = null, nodeToDelete = null, deletedNode = null; // 1st use-case: an invalid position if (length === 0 || position &lt; 1 || position &gt; length) &#123; throw new Error(message.failure); &#125; // 2nd use-case: the first node is removed if (position === 1) &#123; this.head = currentNode.next; // 2nd use-case: there is a second node if (!this.head) &#123; this.head.previous = null; // 2nd use-case: there is no second node &#125; else &#123; this.tail = null; &#125; // 3rd use-case: the last node is removed &#125; else if (position === this._length) &#123; this.tail = this.tail.previous; this.tail.next = null; // 4th use-case: a middle node is removed &#125; else &#123; while (count &lt; position) &#123; currentNode = currentNode.next; count++; &#125; beforeNodeToDelete = currentNode.previous; nodeToDelete = currentNode; afterNodeToDelete = currentNode.next; beforeNodeToDelete.next = afterNodeToDelete; afterNodeToDelete.previous = beforeNodeToDelete; deletedNode = nodeToDelete; nodeToDelete = null; &#125; this._length--; return message.success;&#125;; remove(position)处理以下四种情况：1、如果remove(position)的参数传递的位置存在, 将会抛出一个错误。2、如果remove(position)的参数传递的位置是链表的第一个节点（head），将把head赋值给deletedNode ，然后把head重新分配到链表中的下一个节点。 此时，我们必须考虑链表中否存在多个节点。 如果答案为否，头部将被分配为null，之后进入if-else语句的if部分。 在if的代码中，还必须将tail设置为null —— 换句话说，我们返回到一个空的双向链表的初始状态。如果删除列表中的第一个节点，并且链表中存在多个节点，那么我们输入if-else语句的else部分。 在这种情况下，我们必须正确地将head的previous属性设置为null —— 在链表的头前面是没有节点的。3、如果remove(position)的参数传递的位置是链表的尾部，首先把tail赋值给deletedNode，然后tail被重新赋值为尾部之前的那个节点，最后新尾部后面没有其他节点，需要将其next值设置为null。4、这里发生了很多事情，所以我将重点关注逻辑，而不是每一行代码。 一旦CurrentNode指向的节点是将要被remove(position)删除的节点时，就退出while循环。这时我们把nodeToDelete之后的节点重新赋值给beforeNodeToDelete.next。相应的，把nodeToDelete之前的节点重新赋值给afterNodeToDelete.previous。——换句话说，我们把指向已删除节点的指针，改为指向正确的节点。最后，把nodeToDelete 赋值为null。 最后，把链表的长度减1，返回deletedNode。 完整代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100function Node(value) &#123; this.data = value; this.previous = null; this.next = null;&#125; function DoublyList() &#123; this._length = 0; this.head = null; this.tail = null;&#125; DoublyList.prototype.add = function(value) &#123; var node = new Node(value); if (this._length) &#123; this.tail.next = node; node.previous = this.tail; this.tail = node; &#125; else &#123; this.head = node; this.tail = node; &#125; this._length++; return node;&#125;; DoublyList.prototype.searchNodeAt = function(position) &#123; var currentNode = this.head, length = this._length, count = 1, message = &#123;failure: 'Failure: non-existent node in this list.'&#125;; // 1st use-case: an invalid position if (length === 0 || position &lt; 1 || position &gt; length) &#123; throw new Error(message.failure); &#125; // 2nd use-case: a valid position while (count &lt; position) &#123; currentNode = currentNode.next; count++; &#125; return currentNode;&#125;; DoublyList.prototype.remove = function(position) &#123; var currentNode = this.head, length = this._length, count = 1, message = &#123;failure: 'Failure: non-existent node in this list.'&#125;, beforeNodeToDelete = null, nodeToDelete = null, deletedNode = null; // 1st use-case: an invalid position if (length === 0 || position &lt; 1 || position &gt; length) &#123; throw new Error(message.failure); &#125; // 2nd use-case: the first node is removed if (position === 1) &#123; this.head = currentNode.next; // 2nd use-case: there is a second node if (!this.head) &#123; this.head.previous = null; // 2nd use-case: there is no second node &#125; else &#123; this.tail = null; &#125; // 3rd use-case: the last node is removed &#125; else if (position === this._length) &#123; this.tail = this.tail.previous; this.tail.next = null; // 4th use-case: a middle node is removed &#125; else &#123; while (count &lt; position) &#123; currentNode = currentNode.next; count++; &#125; beforeNodeToDelete = currentNode.previous; nodeToDelete = currentNode; afterNodeToDelete = currentNode.next; beforeNodeToDelete.next = afterNodeToDelete; afterNodeToDelete.previous = beforeNodeToDelete; deletedNode = nodeToDelete; nodeToDelete = null; &#125; this._length--; return message.success;&#125;;]]></content>
      <categories>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[threejs 开发汇总]]></title>
    <url>%2F2018%2F04%2F15%2Fthreejs-tutorial.html</url>
    <content type="text"><![CDATA[适用于网站背景css3d_panorama canvas_particles_sprites webgl_panorama_equirectangular webgl_panorama_dualfisheye canvas_geometry_panorama_fisheye canvas_geometry_panorama canvas_particles_random canvas_particles_waves]]></content>
      <categories>
        <category>threejs</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 实用工具库]]></title>
    <url>%2F2018%2F04%2F12%2Fjavascript-util-libs.html</url>
    <content type="text"><![CDATA[精确类型检查1234function typeOf (obj) &#123; const toString = Object.prototype.toString; return toString.call(obj).slice(8, -1)&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router-source-analysis]]></title>
    <url>%2F2018%2F04%2F10%2Fvue-router-source-analysis.html</url>
    <content type="text"></content>
      <categories>
        <category>vue-router</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router-source-analysis]]></title>
    <url>%2F2018%2F04%2F10%2Freact-router-source-analysis.html</url>
    <content type="text"></content>
      <categories>
        <category>react-router</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel 开发汇总]]></title>
    <url>%2F2018%2F04%2F08%2Fbabel-tutorial.html</url>
    <content type="text"><![CDATA[问题指南npm startQ：由于 babel@7 升级导致的 break change，transform-decorators-legacy 无需引入了，如果引入就会报以下错误：123456789$ npm startStarting the development server...Failed to compile../src/routes/orders/AllPaidOrderListPage.jsModule build failed: TypeError: Property right of AssignmentExpression expected node to be of a type [&quot;Expression&quot;] but instead got nullat Array.map (&lt;anonymous&gt;) A：将.webpackrc.js中的transform-decorators-legacy进行删除。 问题详情：]]></content>
      <categories>
        <category>babel</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用PM2守护Nodejs命令行程序]]></title>
    <url>%2F2018%2F04%2F06%2Fnode-pm2.html</url>
    <content type="text"><![CDATA[pm2是nodejs的一个带有负载均衡功能的应用进程管理器的模块，类似有Supervisor，forever，用来进行进程管理。 安装1npm install pm2 -g 启动1234pm2 start app.jspm2 start app.js --name my-api #my-api为PM2进程名称pm2 start app.js -i 0 #根据CPU核数启动进程个数pm2 start app.js --watch #实时监控app.js的方式启动，当app.js文件有变动时，pm2会自动reload 查看进程12pm2 listpm2 show 0 或者 # pm2 info 0 #查看进程详细信息，0为PM2进程id 监控1pm2 monit 停止12pm2 stop all #停止PM2列表中所有的进程pm2 stop 0 #停止PM2列表中进程为0的进程 重载12pm2 reload all #重载PM2列表中所有的进程pm2 reload 0 #重载PM2列表中进程为0的进程 重启12pm2 restart all #重启PM2列表中所有的进程pm2 restart 0 #重启PM2列表中进程为0的进程 删除PM2进程12pm2 delete 0 #删除PM2列表中进程为0的进程pm2 delete all #删除PM2列表中所有的进程 日志操作123pm2 logs [--raw] #Display all processes logs in streamingpm2 flush #Empty all log filepm2 reloadLogs #Reload all logs 升级PM212npm install pm2@lastest -g #安装最新的PM2版本pm2 updatePM2 #升级pm2 更多命令参数请查看帮助1pm2 --help PM2目录结构 1、默认的目录是：当前用于的家目录下的.pm2目录（此目录可以自定义，请参考：十三、自定义启动文件），详细信息如下：12345678$HOME/.pm2 #will contain all PM2 related files$HOME/.pm2/logs #will contain all applications logs$HOME/.pm2/pids #will contain all applications pids$HOME/.pm2/pm2.log #PM2 logs$HOME/.pm2/pm2.pid #PM2 pid$HOME/.pm2/rpc.sock #Socket file for remote commands$HOME/.pm2/pub.sock #Socket file for publishable events$HOME/.pm2/conf.js #PM2 Configuration 自定义启动文件 1、创建一个test.json的示例文件，格式如下： 12345678910111213141516&#123; "apps": &#123; "name": "test", "cwd": "/data/wwwroot/nodejs", "script": "./test.sh", "exec_interpreter": "bash", "min_uptime": "60s", "max_restarts": 30, "exec_mode" : "cluster_mode", "error_file" : "./test-err.log", "out_file": "./test-out.log", "pid_file": "./test.pid" "watch": false &#125;&#125; 2、参数说明： 123456789101112apps：json结构，apps是一个数组，每一个数组成员就是对应一个pm2中运行的应用name：应用程序的名称cwd：应用程序所在的目录script：应用程序的脚本路径exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejsmin_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量max_restarts：设置应用程序异常退出重启的次数，默认15次（从0开始计数）exec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是forkerror_file：自定义应用程序的错误日志文件out_file：自定义应用程序日志文件pid_file：自定义应用程序的pid文件watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 开发汇总]]></title>
    <url>%2F2018%2F04%2F05%2Fvue-tutorial.html</url>
    <content type="text"><![CDATA[教程高阶组件高阶组件(HOC)是 React 生态系统的常用词汇，React 中代码复用的主要方式就是使用高阶组件，并且这也是官方推荐的做法。而 Vue 中复用代码的主要方式是使用 mixins，并且在 Vue 中很少提到高阶组件的概念，这是因为在 Vue 中实现高阶组件并不像 React 中那样简单，原因在于 React 和 Vue 的设计思想不同，但并不是说在 Vue 中就不能使用高阶组件，只不过在 Vue 中使用高阶组件所带来的收益相对于 mixins 并没有质的变化。本篇文章主要从技术性的角度阐述 Vue 高阶组件的实现，且会从 React 与 Vue 两者的角度进行分析。 从 React 说起起初 React 也是使用 mixins 来完成代码复用的，比如为了避免组件不必要的重复渲染我们可以在组件中混入 PureRenderMixin：1234const PureRenderMixin = require('react-addons-pure-render-mixin')const MyComponent = React.createClass(&#123; mixins: [PureRenderMixin]&#125;) 后来 React 抛弃了这种方式，进而使用 shallowCompare：]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github 设置 SSh]]></title>
    <url>%2F2018%2F04%2F02%2Fset-and-add-ssh.html</url>
    <content type="text"><![CDATA[设置添加SSH很多朋友在用github管理项目的时候，都是直接使用https url克隆到本地，当然也有有些人使用 SSH url 克隆到本地。然而，为什么绝大多数人会使用https url克隆呢？ 这是因为，使用https url克隆对初学者来说会比较方便，复制https url 然后到 git Bash 里面直接用clone命令克隆到本地就好了。而使用 SSH url 克隆却需要在克隆之前先配置和添加好 SSH key 。 因此，如果你想要使用 SSH url 克隆的话，你必须是这个项目的拥有者。否则你是无法添加 SSH key 的。 https 和 SSH 的区别：1、前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key ，否则无法克隆。 2、https url 在push的时候是需要验证用户名和密码的；而 SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。 添加 SSH key 的步骤：1、首先需要检查你电脑是否已经有 SSH key运行 git Bash 客户端，输入如下代码： 12$ cd ~/.ssh$ ls 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3。 2、创建一个 SSH key1$ ssh-keygen -t rsa -C "your_email@example.com" 代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。 以上代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如： 12Generating public/private rsa key pair.# Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 当然，你也可以不输入文件名，使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码）， 当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了，如： 12Enter passphrase (empty for no passphrase): # Enter same passphrase again: 接下来，就会显示如下代码提示，如： 1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.# Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 当你看到上面这段代码的收，那就说明，你的 SSH key 已经创建成功，你只需要添加到github的SSH key上就可以了。 3、添加你的 SSH key 到 github或gitlab等上面去即可]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx利用service进行启动]]></title>
    <url>%2F2018%2F04%2F01%2Fnginx-service.html</url>
    <content type="text"><![CDATA[nginx启动、停止、无间断服务重启123[root@example ~]# service nginx start[root@example ~]# service nginx stop[root@example ~]# service nginx reload 在/etc/init.d/目录下编写脚本，名为nginx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#!/bin/sh## nginx Startup script for nginx## chkconfig: - 85 15# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# description: nginx is an HTTP and reverse proxy server#### BEGIN INIT INFO# Provides: nginx# Required-Start: $local_fs $remote_fs $network# Required-Stop: $local_fs $remote_fs $network# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: start and stop nginx### END INIT INFO# Source function library.. /etc/rc.d/init.d/functionsif [ -L $0 ]; then initscript=`/bin/readlink -f $0`else initscript=$0fisysconfig=`/bin/basename $initscript`if [ -f /etc/sysconfig/$sysconfig ]; then . /etc/sysconfig/$sysconfigfinginx=$&#123;NGINX-/usr/sbin/nginx&#125;prog=`/bin/basename $nginx`conffile=$&#123;CONFFILE-/etc/nginx/nginx.conf&#125;lockfile=$&#123;LOCKFILE-/var/lock/subsys/nginx&#125;pidfile=$&#123;PIDFILE-/var/run/nginx.pid&#125;SLEEPMSEC=$&#123;SLEEPMSEC-200000&#125;UPGRADEWAITLOOPS=$&#123;UPGRADEWAITLOOPS-5&#125;RETVAL=0start() &#123; echo -n $"Starting $prog: " daemon --pidfile=$&#123;pidfile&#125; $&#123;nginx&#125; -c $&#123;conffile&#125; RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; touch $&#123;lockfile&#125; return $RETVAL&#125;stop() &#123; echo -n $"Stopping $prog: " killproc -p $&#123;pidfile&#125; $&#123;prog&#125; RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; rm -f $&#123;lockfile&#125; $&#123;pidfile&#125;&#125;reload() &#123; echo -n $"Reloading $prog: " killproc -p $&#123;pidfile&#125; $&#123;prog&#125; -HUP RETVAL=$? echo&#125;upgrade() &#123; oldbinpidfile=$&#123;pidfile&#125;.oldbin configtest -q || return echo -n $"Starting new master $prog: " killproc -p $&#123;pidfile&#125; $&#123;prog&#125; -USR2 echo for i in `/usr/bin/seq $UPGRADEWAITLOOPS`; do /bin/usleep $SLEEPMSEC if [ -f $&#123;oldbinpidfile&#125; -a -f $&#123;pidfile&#125; ]; then echo -n $"Graceful shutdown of old $prog: " killproc -p $&#123;oldbinpidfile&#125; $&#123;prog&#125; -QUIT RETVAL=$? echo return fi done echo $"Upgrade failed!" RETVAL=1&#125;configtest() &#123; if [ "$#" -ne 0 ] ; then case "$1" in -q) FLAG=$1 ;; *) ;; esac shift fi $&#123;nginx&#125; -t -c $&#123;conffile&#125; $FLAG RETVAL=$? return $RETVAL&#125;rh_status() &#123; status -p $&#123;pidfile&#125; -b $&#123;nginx&#125; $&#123;nginx&#125;&#125;# See how we were called.case "$1" in start) rh_status &gt;/dev/null 2&gt;&amp;1 &amp;&amp; exit 0 start ;; stop) stop ;; status) rh_status RETVAL=$? ;; restart) configtest -q || exit $RETVAL stop start ;; upgrade) rh_status &gt;/dev/null 2&gt;&amp;1 || exit 0 upgrade ;; condrestart|try-restart) if rh_status &gt;/dev/null 2&gt;&amp;1; then stop start fi ;; force-reload|reload) reload ;; configtest) configtest ;; *) echo $"Usage: $prog &#123;start|stop|restart|condrestart|try-restart|force-reload|upgrade|reload|status|help|configtest&#125;" RETVAL=2esacexit $RETVAL]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx查看配置文件nginx.conf路径]]></title>
    <url>%2F2018%2F03%2F31%2Fnginx-config-path.html</url>
    <content type="text"><![CDATA[当你执行 nginx -t 得时候，nginx会去测试你得配置文件得语法，并告诉你配置文件是否写得正确，同时也告诉了你配置文件得路径： 123# nginx -tnginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is oknginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful 1$ ps -ef | grep nginx # 确定Nginx是以那个config文件启动的，也可以查看配置文件nginx.conf路径]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>path</tag>
      </tags>
  </entry>
</search>
